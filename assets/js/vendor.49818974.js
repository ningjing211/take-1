function Si(o) {
    if (o === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return o
}
function Ep(o, e) {
    o.prototype = Object.create(e.prototype),
    o.prototype.constructor = o,
    o.__proto__ = e
}
/*!
 * GSAP 3.11.1
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var Sn = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
        lineHeight: ""
    }
}, Ws = {
    duration: .5,
    overwrite: !1,
    delay: 0
}, Uc, Gn, Et, kn = 1e8, ut = 1 / kn, Qu = Math.PI * 2, y_ = Qu / 4, b_ = 0, Ap = Math.sqrt, w_ = Math.cos, M_ = Math.sin, kt = function(e) {
    return typeof e == "string"
}, xt = function(e) {
    return typeof e == "function"
}, Vi = function(e) {
    return typeof e == "number"
}, Bc = function(e) {
    return typeof e > "u"
}, di = function(e) {
    return typeof e == "object"
}, dn = function(e) {
    return e !== !1
}, Cp = function() {
    return typeof window < "u"
}, va = function(e) {
    return xt(e) || kt(e)
}, Lp = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {}
, qt = Array.isArray, Ju = /(?:-?\.?\d|\.)+/gi, Rp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, Rs = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, Ql = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, Pp = /[+-]=-?[.\d]+/, Ip = /[^,'"\[\]\s]+/gi, S_ = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, dt, Pn, ec, Vc, Dn = {}, Ml = {}, Fp, Op = function(e) {
    return (Ml = Kr(e, Dn)) && Tn
}, Gc = function(e, t) {
    return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()")
}, Sl = function(e, t) {
    return !t && console.warn(e)
}, Np = function(e, t) {
    return e && (Dn[e] = t) && Ml && (Ml[e] = t) || Dn
}, Yo = function() {
    return 0
}, D_ = {
    suppressEvents: !0,
    isStart: !0
}, Io = {
    suppressEvents: !0
}, Hc = {}, ar = [], tc = {}, kp, bn = {}, Jl = {}, Ah = 30, ll = [], Wc = "", jc = function(e) {
    var t = e[0], n, i;
    if (di(t) || xt(t) || (e = [e]),
    !(n = (t._gsap || {}).harness)) {
        for (i = ll.length; i-- && !ll[i].targetTest(t); )
            ;
        n = ll[i]
    }
    for (i = e.length; i--; )
        e[i] && (e[i]._gsap || (e[i]._gsap = new sm(e[i],n))) || e.splice(i, 1);
    return e
}, Vr = function(e) {
    return e._gsap || jc(zn(e))[0]._gsap
}, zp = function(e, t, n) {
    return (n = e[t]) && xt(n) ? e[t]() : Bc(n) && e.getAttribute && e.getAttribute(t) || n
}, pn = function(e, t) {
    return (e = e.split(",")).forEach(t) || e
}, wt = function(e) {
    return Math.round(e * 1e5) / 1e5 || 0
}, Bt = function(e) {
    return Math.round(e * 1e7) / 1e7 || 0
}, ks = function(e, t) {
    var n = t.charAt(0)
      , i = parseFloat(t.substr(2));
    return e = parseFloat(e),
    n === "+" ? e + i : n === "-" ? e - i : n === "*" ? e * i : e / i
}, T_ = function(e, t) {
    for (var n = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < n; )
        ;
    return i < n
}, Dl = function() {
    var e = ar.length, t = ar.slice(0), n, i;
    for (tc = {},
    ar.length = 0,
    n = 0; n < e; n++)
        i = t[n],
        i && i._lazy && (i.render(i._lazy[0], i._lazy[1], !0)._lazy = 0)
}, Up = function(e, t, n, i) {
    ar.length && Dl(),
    e.render(t, n, i || Gn),
    ar.length && Dl()
}, Bp = function(e) {
    var t = parseFloat(e);
    return (t || t === 0) && (e + "").match(Ip).length < 2 ? t : kt(e) ? e.trim() : e
}, Vp = function(e) {
    return e
}, jn = function(e, t) {
    for (var n in t)
        n in e || (e[n] = t[n]);
    return e
}, E_ = function(e) {
    return function(t, n) {
        for (var i in n)
            i in t || i === "duration" && e || i === "ease" || (t[i] = n[i])
    }
}, Kr = function(e, t) {
    for (var n in t)
        e[n] = t[n];
    return e
}, Ch = function o(e, t) {
    for (var n in t)
        n !== "__proto__" && n !== "constructor" && n !== "prototype" && (e[n] = di(t[n]) ? o(e[n] || (e[n] = {}), t[n]) : t[n]);
    return e
}, Tl = function(e, t) {
    var n = {}, i;
    for (i in e)
        i in t || (n[i] = e[i]);
    return n
}, Fo = function(e) {
    var t = e.parent || dt
      , n = e.keyframes ? E_(qt(e.keyframes)) : jn;
    if (dn(e.inherit))
        for (; t; )
            n(e, t.vars.defaults),
            t = t.parent || t._dp;
    return e
}, A_ = function(e, t) {
    for (var n = e.length, i = n === t.length; i && n-- && e[n] === t[n]; )
        ;
    return n < 0
}, Gp = function(e, t, n, i, r) {
    n === void 0 && (n = "_first"),
    i === void 0 && (i = "_last");
    var s = e[i], a;
    if (r)
        for (a = t[r]; s && s[r] > a; )
            s = s._prev;
    return s ? (t._next = s._next,
    s._next = t) : (t._next = e[n],
    e[n] = t),
    t._next ? t._next._prev = t : e[i] = t,
    t._prev = s,
    t.parent = t._dp = e,
    t
}, zl = function(e, t, n, i) {
    n === void 0 && (n = "_first"),
    i === void 0 && (i = "_last");
    var r = t._prev
      , s = t._next;
    r ? r._next = s : e[n] === t && (e[n] = s),
    s ? s._prev = r : e[i] === t && (e[i] = r),
    t._next = t._prev = t.parent = null
}, Gi = function(e, t) {
    e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove(e),
    e._act = 0
}, Gr = function(e, t) {
    if (e && (!t || t._end > e._dur || t._start < 0))
        for (var n = e; n; )
            n._dirty = 1,
            n = n.parent;
    return e
}, C_ = function(e) {
    for (var t = e.parent; t && t.parent; )
        t._dirty = 1,
        t.totalDuration(),
        t = t.parent;
    return e
}, nc = function(e, t, n, i) {
    return e._startAt && (Gn ? e._startAt.revert(Io) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, i))
}, L_ = function o(e) {
    return !e || e._ts && o(e.parent)
}, Lh = function(e) {
    return e._repeat ? js(e._tTime, e = e.duration() + e._rDelay) * e : 0
}, js = function(e, t) {
    var n = Math.floor(e /= t);
    return e && n === e ? n - 1 : n
}, El = function(e, t) {
    return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
}, Ul = function(e) {
    return e._end = Bt(e._start + (e._tDur / Math.abs(e._ts || e._rts || ut) || 0))
}, Bl = function(e, t) {
    var n = e._dp;
    return n && n.smoothChildTiming && e._ts && (e._start = Bt(n._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)),
    Ul(e),
    n._dirty || Gr(n, e)),
    e
}, Hp = function(e, t) {
    var n;
    if ((t._time || t._initted && !t._dur) && (n = El(e.rawTime(), t),
    (!t._dur || fa(0, t.totalDuration(), n) - t._tTime > ut) && t.render(n, !0)),
    Gr(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
        if (e._dur < e.duration())
            for (n = e; n._dp; )
                n.rawTime() >= 0 && n.totalTime(n._tTime),
                n = n._dp;
        e._zTime = -ut
    }
}, oi = function(e, t, n, i) {
    return t.parent && Gi(t),
    t._start = Bt((Vi(n) ? n : n || e !== dt ? Rn(e, n, t) : e._time) + t._delay),
    t._end = Bt(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)),
    Gp(e, t, "_first", "_last", e._sort ? "_start" : 0),
    ic(t) || (e._recent = t),
    i || Hp(e, t),
    e._ts < 0 && Bl(e, e._tTime),
    e
}, Wp = function(e, t) {
    return (Dn.ScrollTrigger || Gc("scrollTrigger", t)) && Dn.ScrollTrigger.create(t, e)
}, jp = function(e, t, n, i) {
    if (Xc(e, t),
    !e._initted)
        return 1;
    if (!n && e._pt && (e._dur && e.vars.lazy !== !1 || !e._dur && e.vars.lazy) && kp !== wn.frame)
        return ar.push(e),
        e._lazy = [t, i],
        1
}, R_ = function o(e) {
    var t = e.parent;
    return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || o(t))
}, ic = function(e) {
    var t = e.data;
    return t === "isFromStart" || t === "isStart"
}, P_ = function(e, t, n, i) {
    var r = e.ratio, s = t < 0 || !t && (!e._start && R_(e) && !(!e._initted && ic(e)) || (e._ts < 0 || e._dp._ts < 0) && !ic(e)) ? 0 : 1, a = e._rDelay, l = 0, u, c, h;
    if (a && e._repeat && (l = fa(0, e._tDur, t),
    c = js(l, a),
    e._yoyo && c & 1 && (s = 1 - s),
    c !== js(e._tTime, a) && (r = 1 - s,
    e.vars.repeatRefresh && e._initted && e.invalidate())),
    s !== r || Gn || i || e._zTime === ut || !t && e._zTime) {
        if (!e._initted && jp(e, t, i, n))
            return;
        for (h = e._zTime,
        e._zTime = t || (n ? ut : 0),
        n || (n = t && !h),
        e.ratio = s,
        e._from && (s = 1 - s),
        e._time = 0,
        e._tTime = l,
        u = e._pt; u; )
            u.r(s, u.d),
            u = u._next;
        t < 0 && nc(e, t, n, !0),
        e._onUpdate && !n && Un(e, "onUpdate"),
        l && e._repeat && !n && e.parent && Un(e, "onRepeat"),
        (t >= e._tDur || t < 0) && e.ratio === s && (s && Gi(e, 1),
        !n && !Gn && (Un(e, s ? "onComplete" : "onReverseComplete", !0),
        e._prom && e._prom()))
    } else
        e._zTime || (e._zTime = t)
}, I_ = function(e, t, n) {
    var i;
    if (n > t)
        for (i = e._first; i && i._start <= n; ) {
            if (i.data === "isPause" && i._start > t)
                return i;
            i = i._next
        }
    else
        for (i = e._last; i && i._start >= n; ) {
            if (i.data === "isPause" && i._start < t)
                return i;
            i = i._prev
        }
}, qs = function(e, t, n, i) {
    var r = e._repeat
      , s = Bt(t) || 0
      , a = e._tTime / e._tDur;
    return a && !i && (e._time *= s / e._dur),
    e._dur = s,
    e._tDur = r ? r < 0 ? 1e10 : Bt(s * (r + 1) + e._rDelay * r) : s,
    a > 0 && !i ? Bl(e, e._tTime = e._tDur * a) : e.parent && Ul(e),
    n || Gr(e.parent, e),
    e
}, Rh = function(e) {
    return e instanceof cn ? Gr(e) : qs(e, e._dur)
}, F_ = {
    _start: 0,
    endTime: Yo,
    totalDuration: Yo
}, Rn = function o(e, t, n) {
    var i = e.labels, r = e._recent || F_, s = e.duration() >= kn ? r.endTime(!1) : e._dur, a, l, u;
    return kt(t) && (isNaN(t) || t in i) ? (l = t.charAt(0),
    u = t.substr(-1) === "%",
    a = t.indexOf("="),
    l === "<" || l === ">" ? (a >= 0 && (t = t.replace(/=/, "")),
    (l === "<" ? r._start : r.endTime(r._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (u ? (a < 0 ? r : n).totalDuration() / 100 : 1)) : a < 0 ? (t in i || (i[t] = s),
    i[t]) : (l = parseFloat(t.charAt(a - 1) + t.substr(a + 1)),
    u && n && (l = l / 100 * (qt(n) ? n[0] : n).totalDuration()),
    a > 1 ? o(e, t.substr(0, a - 1), n) + l : s + l)) : t == null ? s : +t
}, Oo = function(e, t, n) {
    var i = Vi(t[1]), r = (i ? 2 : 1) + (e < 2 ? 0 : 1), s = t[r], a, l;
    if (i && (s.duration = t[1]),
    s.parent = n,
    e) {
        for (a = s,
        l = n; l && !("immediateRender"in a); )
            a = l.vars.defaults || {},
            l = dn(l.vars.inherit) && l.parent;
        s.immediateRender = dn(a.immediateRender),
        e < 2 ? s.runBackwards = 1 : s.startAt = t[r - 1]
    }
    return new Rt(t[0],s,t[r + 1])
}, gr = function(e, t) {
    return e || e === 0 ? t(e) : t
}, fa = function(e, t, n) {
    return n < e ? e : n > t ? t : n
}, jt = function(e, t) {
    return !kt(e) || !(t = S_.exec(e)) ? "" : t[1]
}, O_ = function(e, t, n) {
    return gr(n, function(i) {
        return fa(e, t, i)
    })
}, rc = [].slice, qp = function(e, t) {
    return e && di(e) && "length"in e && (!t && !e.length || e.length - 1 in e && di(e[0])) && !e.nodeType && e !== Pn
}, N_ = function(e, t, n) {
    return n === void 0 && (n = []),
    e.forEach(function(i) {
        var r;
        return kt(i) && !t || qp(i, 1) ? (r = n).push.apply(r, zn(i)) : n.push(i)
    }) || n
}, zn = function(e, t, n) {
    return Et && !t && Et.selector ? Et.selector(e) : kt(e) && !n && (ec || !Xs()) ? rc.call((t || Vc).querySelectorAll(e), 0) : qt(e) ? N_(e, n) : qp(e) ? rc.call(e, 0) : e ? [e] : []
}, sc = function(e) {
    return e = zn(e)[0] || Sl("Invalid scope") || {},
    function(t) {
        var n = e.current || e.nativeElement || e;
        return zn(t, n.querySelectorAll ? n : n === e ? Sl("Invalid scope") || Vc.createElement("div") : e)
    }
}, Xp = function(e) {
    return e.sort(function() {
        return .5 - Math.random()
    })
}, Yp = function(e) {
    if (xt(e))
        return e;
    var t = di(e) ? e : {
        each: e
    }
      , n = Hr(t.ease)
      , i = t.from || 0
      , r = parseFloat(t.base) || 0
      , s = {}
      , a = i > 0 && i < 1
      , l = isNaN(i) || a
      , u = t.axis
      , c = i
      , h = i;
    return kt(i) ? c = h = {
        center: .5,
        edges: .5,
        end: 1
    }[i] || 0 : !a && l && (c = i[0],
    h = i[1]),
    function(f, m, _) {
        var d = (_ || t).length, p = s[d], v, x, S, M, T, L, P, A, C;
        if (!p) {
            if (C = t.grid === "auto" ? 0 : (t.grid || [1, kn])[1],
            !C) {
                for (P = -kn; P < (P = _[C++].getBoundingClientRect().left) && C < d; )
                    ;
                C--
            }
            for (p = s[d] = [],
            v = l ? Math.min(C, d) * c - .5 : i % C,
            x = C === kn ? 0 : l ? d * h / C - .5 : i / C | 0,
            P = 0,
            A = kn,
            L = 0; L < d; L++)
                S = L % C - v,
                M = x - (L / C | 0),
                p[L] = T = u ? Math.abs(u === "y" ? M : S) : Ap(S * S + M * M),
                T > P && (P = T),
                T < A && (A = T);
            i === "random" && Xp(p),
            p.max = P - A,
            p.min = A,
            p.v = d = (parseFloat(t.amount) || parseFloat(t.each) * (C > d ? d - 1 : u ? u === "y" ? d / C : C : Math.max(C, d / C)) || 0) * (i === "edges" ? -1 : 1),
            p.b = d < 0 ? r - d : r,
            p.u = jt(t.amount || t.each) || 0,
            n = n && d < 0 ? nm(n) : n
        }
        return d = (p[f] - p.min) / p.max || 0,
        Bt(p.b + (n ? n(d) : d) * p.v) + p.u
    }
}, oc = function(e) {
    var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
    return function(n) {
        var i = Bt(Math.round(parseFloat(n) / e) * e * t);
        return (i - i % 1) / t + (Vi(n) ? 0 : jt(n))
    }
}, Kp = function(e, t) {
    var n = qt(e), i, r;
    return !n && di(e) && (i = n = e.radius || kn,
    e.values ? (e = zn(e.values),
    (r = !Vi(e[0])) && (i *= i)) : e = oc(e.increment)),
    gr(t, n ? xt(e) ? function(s) {
        return r = e(s),
        Math.abs(r - s) <= i ? r : s
    }
    : function(s) {
        for (var a = parseFloat(r ? s.x : s), l = parseFloat(r ? s.y : 0), u = kn, c = 0, h = e.length, f, m; h--; )
            r ? (f = e[h].x - a,
            m = e[h].y - l,
            f = f * f + m * m) : f = Math.abs(e[h] - a),
            f < u && (u = f,
            c = h);
        return c = !i || u <= i ? e[c] : s,
        r || c === s || Vi(s) ? c : c + jt(s)
    }
    : oc(e))
}, $p = function(e, t, n, i) {
    return gr(qt(e) ? !t : n === !0 ? !!(n = 0) : !i, function() {
        return qt(e) ? e[~~(Math.random() * e.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((e - n / 2 + Math.random() * (t - e + n * .99)) / n) * n * i) / i
    })
}, k_ = function() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
    return function(i) {
        return t.reduce(function(r, s) {
            return s(r)
        }, i)
    }
}, z_ = function(e, t) {
    return function(n) {
        return e(parseFloat(n)) + (t || jt(n))
    }
}, U_ = function(e, t, n) {
    return Qp(e, t, 0, 1, n)
}, Zp = function(e, t, n) {
    return gr(n, function(i) {
        return e[~~t(i)]
    })
}, B_ = function o(e, t, n) {
    var i = t - e;
    return qt(e) ? Zp(e, o(0, e.length), t) : gr(n, function(r) {
        return (i + (r - e) % i) % i + e
    })
}, V_ = function o(e, t, n) {
    var i = t - e
      , r = i * 2;
    return qt(e) ? Zp(e, o(0, e.length - 1), t) : gr(n, function(s) {
        return s = (r + (s - e) % r) % r || 0,
        e + (s > i ? r - s : s)
    })
}, Ko = function(e) {
    for (var t = 0, n = "", i, r, s, a; ~(i = e.indexOf("random(", t)); )
        s = e.indexOf(")", i),
        a = e.charAt(i + 7) === "[",
        r = e.substr(i + 7, s - i - 7).match(a ? Ip : Ju),
        n += e.substr(t, i - t) + $p(a ? r : +r[0], a ? 0 : +r[1], +r[2] || 1e-5),
        t = s + 1;
    return n + e.substr(t, e.length - t)
}, Qp = function(e, t, n, i, r) {
    var s = t - e
      , a = i - n;
    return gr(r, function(l) {
        return n + ((l - e) / s * a || 0)
    })
}, G_ = function o(e, t, n, i) {
    var r = isNaN(e + t) ? 0 : function(m) {
        return (1 - m) * e + m * t
    }
    ;
    if (!r) {
        var s = kt(e), a = {}, l, u, c, h, f;
        if (n === !0 && (i = 1) && (n = null),
        s)
            e = {
                p: e
            },
            t = {
                p: t
            };
        else if (qt(e) && !qt(t)) {
            for (c = [],
            h = e.length,
            f = h - 2,
            u = 1; u < h; u++)
                c.push(o(e[u - 1], e[u]));
            h--,
            r = function(_) {
                _ *= h;
                var d = Math.min(f, ~~_);
                return c[d](_ - d)
            }
            ,
            n = t
        } else
            i || (e = Kr(qt(e) ? [] : {}, e));
        if (!c) {
            for (l in t)
                qc.call(a, e, l, "get", t[l]);
            r = function(_) {
                return $c(_, a) || (s ? e.p : e)
            }
        }
    }
    return gr(n, r)
}, Ph = function(e, t, n) {
    var i = e.labels, r = kn, s, a, l;
    for (s in i)
        a = i[s] - t,
        a < 0 == !!n && a && r > (a = Math.abs(a)) && (l = s,
        r = a);
    return l
}, Un = function(e, t, n) {
    var i = e.vars, r = i[t], s = Et, a = e._ctx, l, u, c;
    if (!!r)
        return l = i[t + "Params"],
        u = i.callbackScope || e,
        n && ar.length && Dl(),
        a && (Et = a),
        c = l ? r.apply(u, l) : r.call(u),
        Et = s,
        c
}, To = function(e) {
    return Gi(e),
    e.scrollTrigger && e.scrollTrigger.kill(!1),
    e.progress() < 1 && Un(e, "onInterrupt"),
    e
}, Ps, H_ = function(e) {
    e = !e.name && e.default || e;
    var t = e.name
      , n = xt(e)
      , i = t && !n && e.init ? function() {
        this._props = []
    }
    : e
      , r = {
        init: Yo,
        render: $c,
        add: qc,
        kill: s0,
        modifier: r0,
        rawVars: 0
    }
      , s = {
        targetTest: 0,
        get: 0,
        getSetter: Kc,
        aliases: {},
        register: 0
    };
    if (Xs(),
    e !== i) {
        if (bn[t])
            return;
        jn(i, jn(Tl(e, r), s)),
        Kr(i.prototype, Kr(r, Tl(e, s))),
        bn[i.prop = t] = i,
        e.targetTest && (ll.push(i),
        Hc[t] = 1),
        t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin"
    }
    Np(t, i),
    e.register && e.register(Tn, i, mn)
}, at = 255, Eo = {
    aqua: [0, at, at],
    lime: [0, at, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, at],
    navy: [0, 0, 128],
    white: [at, at, at],
    olive: [128, 128, 0],
    yellow: [at, at, 0],
    orange: [at, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [at, 0, 0],
    pink: [at, 192, 203],
    cyan: [0, at, at],
    transparent: [at, at, at, 0]
}, eu = function(e, t, n) {
    return e += e < 0 ? 1 : e > 1 ? -1 : 0,
    (e * 6 < 1 ? t + (n - t) * e * 6 : e < .5 ? n : e * 3 < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) * at + .5 | 0
}, Jp = function(e, t, n) {
    var i = e ? Vi(e) ? [e >> 16, e >> 8 & at, e & at] : 0 : Eo.black, r, s, a, l, u, c, h, f, m, _;
    if (!i) {
        if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)),
        Eo[e])
            i = Eo[e];
        else if (e.charAt(0) === "#") {
            if (e.length < 6 && (r = e.charAt(1),
            s = e.charAt(2),
            a = e.charAt(3),
            e = "#" + r + r + s + s + a + a + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")),
            e.length === 9)
                return i = parseInt(e.substr(1, 6), 16),
                [i >> 16, i >> 8 & at, i & at, parseInt(e.substr(7), 16) / 255];
            e = parseInt(e.substr(1), 16),
            i = [e >> 16, e >> 8 & at, e & at]
        } else if (e.substr(0, 3) === "hsl") {
            if (i = _ = e.match(Ju),
            !t)
                l = +i[0] % 360 / 360,
                u = +i[1] / 100,
                c = +i[2] / 100,
                s = c <= .5 ? c * (u + 1) : c + u - c * u,
                r = c * 2 - s,
                i.length > 3 && (i[3] *= 1),
                i[0] = eu(l + 1 / 3, r, s),
                i[1] = eu(l, r, s),
                i[2] = eu(l - 1 / 3, r, s);
            else if (~e.indexOf("="))
                return i = e.match(Rp),
                n && i.length < 4 && (i[3] = 1),
                i
        } else
            i = e.match(Ju) || Eo.transparent;
        i = i.map(Number)
    }
    return t && !_ && (r = i[0] / at,
    s = i[1] / at,
    a = i[2] / at,
    h = Math.max(r, s, a),
    f = Math.min(r, s, a),
    c = (h + f) / 2,
    h === f ? l = u = 0 : (m = h - f,
    u = c > .5 ? m / (2 - h - f) : m / (h + f),
    l = h === r ? (s - a) / m + (s < a ? 6 : 0) : h === s ? (a - r) / m + 2 : (r - s) / m + 4,
    l *= 60),
    i[0] = ~~(l + .5),
    i[1] = ~~(u * 100 + .5),
    i[2] = ~~(c * 100 + .5)),
    n && i.length < 4 && (i[3] = 1),
    i
}, em = function(e) {
    var t = []
      , n = []
      , i = -1;
    return e.split(lr).forEach(function(r) {
        var s = r.match(Rs) || [];
        t.push.apply(t, s),
        n.push(i += s.length + 1)
    }),
    t.c = n,
    t
}, Ih = function(e, t, n) {
    var i = "", r = (e + i).match(lr), s = t ? "hsla(" : "rgba(", a = 0, l, u, c, h;
    if (!r)
        return e;
    if (r = r.map(function(f) {
        return (f = Jp(f, t, 1)) && s + (t ? f[0] + "," + f[1] + "%," + f[2] + "%," + f[3] : f.join(",")) + ")"
    }),
    n && (c = em(e),
    l = n.c,
    l.join(i) !== c.c.join(i)))
        for (u = e.replace(lr, "1").split(Rs),
        h = u.length - 1; a < h; a++)
            i += u[a] + (~l.indexOf(a) ? r.shift() || s + "0,0,0,0)" : (c.length ? c : r.length ? r : n).shift());
    if (!u)
        for (u = e.split(lr),
        h = u.length - 1; a < h; a++)
            i += u[a] + r[a];
    return i + u[h]
}, lr = function() {
    var o = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", e;
    for (e in Eo)
        o += "|" + e + "\\b";
    return new RegExp(o + ")","gi")
}(), W_ = /hsl[a]?\(/, tm = function(e) {
    var t = e.join(" "), n;
    if (lr.lastIndex = 0,
    lr.test(t))
        return n = W_.test(t),
        e[1] = Ih(e[1], n),
        e[0] = Ih(e[0], n, em(e[1])),
        !0
}, $o, wn = function() {
    var o = Date.now, e = 500, t = 33, n = o(), i = n, r = 1e3 / 240, s = r, a = [], l, u, c, h, f, m, _ = function d(p) {
        var v = o() - i, x = p === !0, S, M, T, L;
        if (v > e && (n += v - t),
        i += v,
        T = i - n,
        S = T - s,
        (S > 0 || x) && (L = ++h.frame,
        f = T - h.time * 1e3,
        h.time = T = T / 1e3,
        s += S + (S >= r ? 4 : r - S),
        M = 1),
        x || (l = u(d)),
        M)
            for (m = 0; m < a.length; m++)
                a[m](T, f, L, p)
    };
    return h = {
        time: 0,
        frame: 0,
        tick: function() {
            _(!0)
        },
        deltaRatio: function(p) {
            return f / (1e3 / (p || 60))
        },
        wake: function() {
            Fp && (!ec && Cp() && (Pn = ec = window,
            Vc = Pn.document || {},
            Dn.gsap = Tn,
            (Pn.gsapVersions || (Pn.gsapVersions = [])).push(Tn.version),
            Op(Ml || Pn.GreenSockGlobals || !Pn.gsap && Pn || {}),
            c = Pn.requestAnimationFrame),
            l && h.sleep(),
            u = c || function(p) {
                return setTimeout(p, s - h.time * 1e3 + 1 | 0)
            }
            ,
            $o = 1,
            _(2))
        },
        sleep: function() {
            (c ? Pn.cancelAnimationFrame : clearTimeout)(l),
            $o = 0,
            u = Yo
        },
        lagSmoothing: function(p, v) {
            e = p || 1 / ut,
            t = Math.min(v, e, 0)
        },
        fps: function(p) {
            r = 1e3 / (p || 240),
            s = h.time * 1e3 + r
        },
        add: function(p, v, x) {
            var S = v ? function(M, T, L, P) {
                p(M, T, L, P),
                h.remove(S)
            }
            : p;
            return h.remove(p),
            a[x ? "unshift" : "push"](S),
            Xs(),
            S
        },
        remove: function(p, v) {
            ~(v = a.indexOf(p)) && a.splice(v, 1) && m >= v && m--
        },
        _listeners: a
    },
    h
}(), Xs = function() {
    return !$o && wn.wake()
}, Ye = {}, j_ = /^[\d.\-M][\d.\-,\s]/, q_ = /["']/g, X_ = function(e) {
    for (var t = {}, n = e.substr(1, e.length - 3).split(":"), i = n[0], r = 1, s = n.length, a, l, u; r < s; r++)
        l = n[r],
        a = r !== s - 1 ? l.lastIndexOf(",") : l.length,
        u = l.substr(0, a),
        t[i] = isNaN(u) ? u.replace(q_, "").trim() : +u,
        i = l.substr(a + 1).trim();
    return t
}, Y_ = function(e) {
    var t = e.indexOf("(") + 1
      , n = e.indexOf(")")
      , i = e.indexOf("(", t);
    return e.substring(t, ~i && i < n ? e.indexOf(")", n + 1) : n)
}, K_ = function(e) {
    var t = (e + "").split("(")
      , n = Ye[t[0]];
    return n && t.length > 1 && n.config ? n.config.apply(null, ~e.indexOf("{") ? [X_(t[1])] : Y_(e).split(",").map(Bp)) : Ye._CE && j_.test(e) ? Ye._CE("", e) : n
}, nm = function(e) {
    return function(t) {
        return 1 - e(1 - t)
    }
}, im = function o(e, t) {
    for (var n = e._first, i; n; )
        n instanceof cn ? o(n, t) : n.vars.yoyoEase && (!n._yoyo || !n._repeat) && n._yoyo !== t && (n.timeline ? o(n.timeline, t) : (i = n._ease,
        n._ease = n._yEase,
        n._yEase = i,
        n._yoyo = t)),
        n = n._next
}, Hr = function(e, t) {
    return e && (xt(e) ? e : Ye[e] || K_(e)) || t
}, is = function(e, t, n, i) {
    n === void 0 && (n = function(l) {
        return 1 - t(1 - l)
    }
    ),
    i === void 0 && (i = function(l) {
        return l < .5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2
    }
    );
    var r = {
        easeIn: t,
        easeOut: n,
        easeInOut: i
    }, s;
    return pn(e, function(a) {
        Ye[a] = Dn[a] = r,
        Ye[s = a.toLowerCase()] = n;
        for (var l in r)
            Ye[s + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")] = Ye[a + "." + l] = r[l]
    }),
    r
}, rm = function(e) {
    return function(t) {
        return t < .5 ? (1 - e(1 - t * 2)) / 2 : .5 + e((t - .5) * 2) / 2
    }
}, tu = function o(e, t, n) {
    var i = t >= 1 ? t : 1
      , r = (n || (e ? .3 : .45)) / (t < 1 ? t : 1)
      , s = r / Qu * (Math.asin(1 / i) || 0)
      , a = function(c) {
        return c === 1 ? 1 : i * Math.pow(2, -10 * c) * M_((c - s) * r) + 1
    }
      , l = e === "out" ? a : e === "in" ? function(u) {
        return 1 - a(1 - u)
    }
    : rm(a);
    return r = Qu / r,
    l.config = function(u, c) {
        return o(e, u, c)
    }
    ,
    l
}, nu = function o(e, t) {
    t === void 0 && (t = 1.70158);
    var n = function(s) {
        return s ? --s * s * ((t + 1) * s + t) + 1 : 0
    }
      , i = e === "out" ? n : e === "in" ? function(r) {
        return 1 - n(1 - r)
    }
    : rm(n);
    return i.config = function(r) {
        return o(e, r)
    }
    ,
    i
};
pn("Linear,Quad,Cubic,Quart,Quint,Strong", function(o, e) {
    var t = e < 5 ? e + 1 : e;
    is(o + ",Power" + (t - 1), e ? function(n) {
        return Math.pow(n, t)
    }
    : function(n) {
        return n
    }
    , function(n) {
        return 1 - Math.pow(1 - n, t)
    }, function(n) {
        return n < .5 ? Math.pow(n * 2, t) / 2 : 1 - Math.pow((1 - n) * 2, t) / 2
    })
});
Ye.Linear.easeNone = Ye.none = Ye.Linear.easeIn;
is("Elastic", tu("in"), tu("out"), tu());
(function(o, e) {
    var t = 1 / e
      , n = 2 * t
      , i = 2.5 * t
      , r = function(a) {
        return a < t ? o * a * a : a < n ? o * Math.pow(a - 1.5 / e, 2) + .75 : a < i ? o * (a -= 2.25 / e) * a + .9375 : o * Math.pow(a - 2.625 / e, 2) + .984375
    };
    is("Bounce", function(s) {
        return 1 - r(1 - s)
    }, r)
}
)(7.5625, 2.75);
is("Expo", function(o) {
    return o ? Math.pow(2, 10 * (o - 1)) : 0
});
is("Circ", function(o) {
    return -(Ap(1 - o * o) - 1)
});
is("Sine", function(o) {
    return o === 1 ? 1 : -w_(o * y_) + 1
});
is("Back", nu("in"), nu("out"), nu());
Ye.SteppedEase = Ye.steps = Dn.SteppedEase = {
    config: function(e, t) {
        e === void 0 && (e = 1);
        var n = 1 / e
          , i = e + (t ? 0 : 1)
          , r = t ? 1 : 0
          , s = 1 - ut;
        return function(a) {
            return ((i * fa(0, s, a) | 0) + r) * n
        }
    }
};
Ws.ease = Ye["quad.out"];
pn("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(o) {
    return Wc += o + "," + o + "Params,"
});
var sm = function(e, t) {
    this.id = b_++,
    e._gsap = this,
    this.target = e,
    this.harness = t,
    this.get = t ? t.get : zp,
    this.set = t ? t.getSetter : Kc
}
  , Ys = function() {
    function o(t) {
        this.vars = t,
        this._delay = +t.delay || 0,
        (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0,
        this._yoyo = !!t.yoyo || !!t.yoyoEase),
        this._ts = 1,
        qs(this, +t.duration, 1, 1),
        this.data = t.data,
        Et && (this._ctx = Et,
        Et.data.push(this)),
        $o || wn.wake()
    }
    var e = o.prototype;
    return e.delay = function(n) {
        return n || n === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + n - this._delay),
        this._delay = n,
        this) : this._delay
    }
    ,
    e.duration = function(n) {
        return arguments.length ? this.totalDuration(this._repeat > 0 ? n + (n + this._rDelay) * this._repeat : n) : this.totalDuration() && this._dur
    }
    ,
    e.totalDuration = function(n) {
        return arguments.length ? (this._dirty = 0,
        qs(this, this._repeat < 0 ? n : (n - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
    }
    ,
    e.totalTime = function(n, i) {
        if (Xs(),
        !arguments.length)
            return this._tTime;
        var r = this._dp;
        if (r && r.smoothChildTiming && this._ts) {
            for (Bl(this, n),
            !r._dp || r.parent || Hp(r, this); r && r.parent; )
                r.parent._time !== r._start + (r._ts >= 0 ? r._tTime / r._ts : (r.totalDuration() - r._tTime) / -r._ts) && r.totalTime(r._tTime, !0),
                r = r.parent;
            !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && n < this._tDur || this._ts < 0 && n > 0 || !this._tDur && !n) && oi(this._dp, this, this._start - this._delay)
        }
        return (this._tTime !== n || !this._dur && !i || this._initted && Math.abs(this._zTime) === ut || !n && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = n),
        Up(this, n, i)),
        this
    }
    ,
    e.time = function(n, i) {
        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), n + Lh(this)) % (this._dur + this._rDelay) || (n ? this._dur : 0), i) : this._time
    }
    ,
    e.totalProgress = function(n, i) {
        return arguments.length ? this.totalTime(this.totalDuration() * n, i) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
    }
    ,
    e.progress = function(n, i) {
        return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - n : n) + Lh(this), i) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
    }
    ,
    e.iteration = function(n, i) {
        var r = this.duration() + this._rDelay;
        return arguments.length ? this.totalTime(this._time + (n - 1) * r, i) : this._repeat ? js(this._tTime, r) + 1 : 1
    }
    ,
    e.timeScale = function(n) {
        if (!arguments.length)
            return this._rts === -ut ? 0 : this._rts;
        if (this._rts === n)
            return this;
        var i = this.parent && this._ts ? El(this.parent._time, this) : this._tTime;
        return this._rts = +n || 0,
        this._ts = this._ps || n === -ut ? 0 : this._rts,
        this.totalTime(fa(-this._delay, this._tDur, i), !0),
        Ul(this),
        C_(this)
    }
    ,
    e.paused = function(n) {
        return arguments.length ? (this._ps !== n && (this._ps = n,
        n ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()),
        this._ts = this._act = 0) : (Xs(),
        this._ts = this._rts,
        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== ut && (this._tTime -= ut)))),
        this) : this._ps
    }
    ,
    e.startTime = function(n) {
        if (arguments.length) {
            this._start = n;
            var i = this.parent || this._dp;
            return i && (i._sort || !this.parent) && oi(i, this, n - this._delay),
            this
        }
        return this._start
    }
    ,
    e.endTime = function(n) {
        return this._start + (dn(n) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
    }
    ,
    e.rawTime = function(n) {
        var i = this.parent || this._dp;
        return i ? n && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? El(i.rawTime(n), this) : this._tTime : this._tTime
    }
    ,
    e.revert = function(n) {
        n === void 0 && (n = Io);
        var i = Gn;
        return Gn = n,
        this.timeline && this.timeline.revert(n),
        this.totalTime(-.01, n.suppressEvents),
        this.data !== "nested" && Gi(this),
        Gn = i,
        this
    }
    ,
    e.globalTime = function(n) {
        for (var i = this, r = arguments.length ? n : i.rawTime(); i; )
            r = i._start + r / (i._ts || 1),
            i = i._dp;
        return !this.parent && this.vars.immediateRender ? -1 : r
    }
    ,
    e.repeat = function(n) {
        return arguments.length ? (this._repeat = n === 1 / 0 ? -2 : n,
        Rh(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
    }
    ,
    e.repeatDelay = function(n) {
        if (arguments.length) {
            var i = this._time;
            return this._rDelay = n,
            Rh(this),
            i ? this.time(i) : this
        }
        return this._rDelay
    }
    ,
    e.yoyo = function(n) {
        return arguments.length ? (this._yoyo = n,
        this) : this._yoyo
    }
    ,
    e.seek = function(n, i) {
        return this.totalTime(Rn(this, n), dn(i))
    }
    ,
    e.restart = function(n, i) {
        return this.play().totalTime(n ? -this._delay : 0, dn(i))
    }
    ,
    e.play = function(n, i) {
        return n != null && this.seek(n, i),
        this.reversed(!1).paused(!1)
    }
    ,
    e.reverse = function(n, i) {
        return n != null && this.seek(n || this.totalDuration(), i),
        this.reversed(!0).paused(!1)
    }
    ,
    e.pause = function(n, i) {
        return n != null && this.seek(n, i),
        this.paused(!0)
    }
    ,
    e.resume = function() {
        return this.paused(!1)
    }
    ,
    e.reversed = function(n) {
        return arguments.length ? (!!n !== this.reversed() && this.timeScale(-this._rts || (n ? -ut : 0)),
        this) : this._rts < 0
    }
    ,
    e.invalidate = function() {
        return this._initted = this._act = 0,
        this._zTime = -ut,
        this
    }
    ,
    e.isActive = function() {
        var n = this.parent || this._dp, i = this._start, r;
        return !!(!n || this._ts && this._initted && n.isActive() && (r = n.rawTime(!0)) >= i && r < this.endTime(!0) - ut)
    }
    ,
    e.eventCallback = function(n, i, r) {
        var s = this.vars;
        return arguments.length > 1 ? (i ? (s[n] = i,
        r && (s[n + "Params"] = r),
        n === "onUpdate" && (this._onUpdate = i)) : delete s[n],
        this) : s[n]
    }
    ,
    e.then = function(n) {
        var i = this;
        return new Promise(function(r) {
            var s = xt(n) ? n : Vp
              , a = function() {
                var u = i.then;
                i.then = null,
                xt(s) && (s = s(i)) && (s.then || s === i) && (i.then = u),
                r(s),
                i.then = u
            };
            i._initted && i.totalProgress() === 1 && i._ts >= 0 || !i._tTime && i._ts < 0 ? a() : i._prom = a
        }
        )
    }
    ,
    e.kill = function() {
        To(this)
    }
    ,
    o
}();
jn(Ys.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: !1,
    parent: null,
    _initted: !1,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -ut,
    _prom: 0,
    _ps: !1,
    _rts: 1
});
var cn = function(o) {
    Ep(e, o);
    function e(n, i) {
        var r;
        return n === void 0 && (n = {}),
        r = o.call(this, n) || this,
        r.labels = {},
        r.smoothChildTiming = !!n.smoothChildTiming,
        r.autoRemoveChildren = !!n.autoRemoveChildren,
        r._sort = dn(n.sortChildren),
        dt && oi(n.parent || dt, Si(r), i),
        n.reversed && r.reverse(),
        n.paused && r.paused(!0),
        n.scrollTrigger && Wp(Si(r), n.scrollTrigger),
        r
    }
    var t = e.prototype;
    return t.to = function(i, r, s) {
        return Oo(0, arguments, this),
        this
    }
    ,
    t.from = function(i, r, s) {
        return Oo(1, arguments, this),
        this
    }
    ,
    t.fromTo = function(i, r, s, a) {
        return Oo(2, arguments, this),
        this
    }
    ,
    t.set = function(i, r, s) {
        return r.duration = 0,
        r.parent = this,
        Fo(r).repeatDelay || (r.repeat = 0),
        r.immediateRender = !!r.immediateRender,
        new Rt(i,r,Rn(this, s),1),
        this
    }
    ,
    t.call = function(i, r, s) {
        return oi(this, Rt.delayedCall(0, i, r), s)
    }
    ,
    t.staggerTo = function(i, r, s, a, l, u, c) {
        return s.duration = r,
        s.stagger = s.stagger || a,
        s.onComplete = u,
        s.onCompleteParams = c,
        s.parent = this,
        new Rt(i,s,Rn(this, l)),
        this
    }
    ,
    t.staggerFrom = function(i, r, s, a, l, u, c) {
        return s.runBackwards = 1,
        Fo(s).immediateRender = dn(s.immediateRender),
        this.staggerTo(i, r, s, a, l, u, c)
    }
    ,
    t.staggerFromTo = function(i, r, s, a, l, u, c, h) {
        return a.startAt = s,
        Fo(a).immediateRender = dn(a.immediateRender),
        this.staggerTo(i, r, a, l, u, c, h)
    }
    ,
    t.render = function(i, r, s) {
        var a = this._time, l = this._dirty ? this.totalDuration() : this._tDur, u = this._dur, c = i <= 0 ? 0 : Bt(i), h = this._zTime < 0 != i < 0 && (this._initted || !u), f, m, _, d, p, v, x, S, M, T, L, P;
        if (this !== dt && c > l && i >= 0 && (c = l),
        c !== this._tTime || s || h) {
            if (a !== this._time && u && (c += this._time - a,
            i += this._time - a),
            f = c,
            M = this._start,
            S = this._ts,
            v = !S,
            h && (u || (a = this._zTime),
            (i || !r) && (this._zTime = i)),
            this._repeat) {
                if (L = this._yoyo,
                p = u + this._rDelay,
                this._repeat < -1 && i < 0)
                    return this.totalTime(p * 100 + i, r, s);
                if (f = Bt(c % p),
                c === l ? (d = this._repeat,
                f = u) : (d = ~~(c / p),
                d && d === c / p && (f = u,
                d--),
                f > u && (f = u)),
                T = js(this._tTime, p),
                !a && this._tTime && T !== d && (T = d),
                L && d & 1 && (f = u - f,
                P = 1),
                d !== T && !this._lock) {
                    var A = L && T & 1
                      , C = A === (L && d & 1);
                    if (d < T && (A = !A),
                    a = A ? 0 : u,
                    this._lock = 1,
                    this.render(a || (P ? 0 : Bt(d * p)), r, !u)._lock = 0,
                    this._tTime = c,
                    !r && this.parent && Un(this, "onRepeat"),
                    this.vars.repeatRefresh && !P && (this.invalidate()._lock = 1),
                    a && a !== this._time || v !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
                        return this;
                    if (u = this._dur,
                    l = this._tDur,
                    C && (this._lock = 2,
                    a = A ? u : -1e-4,
                    this.render(a, !0),
                    this.vars.repeatRefresh && !P && this.invalidate()),
                    this._lock = 0,
                    !this._ts && !v)
                        return this;
                    im(this, P)
                }
            }
            if (this._hasPause && !this._forcing && this._lock < 2 && (x = I_(this, Bt(a), Bt(f)),
            x && (c -= f - (f = x._start))),
            this._tTime = c,
            this._time = f,
            this._act = !S,
            this._initted || (this._onUpdate = this.vars.onUpdate,
            this._initted = 1,
            this._zTime = i,
            a = 0),
            !a && f && !r && (Un(this, "onStart"),
            this._tTime !== c))
                return this;
            if (f >= a && i >= 0)
                for (m = this._first; m; ) {
                    if (_ = m._next,
                    (m._act || f >= m._start) && m._ts && x !== m) {
                        if (m.parent !== this)
                            return this.render(i, r, s);
                        if (m.render(m._ts > 0 ? (f - m._start) * m._ts : (m._dirty ? m.totalDuration() : m._tDur) + (f - m._start) * m._ts, r, s),
                        f !== this._time || !this._ts && !v) {
                            x = 0,
                            _ && (c += this._zTime = -ut);
                            break
                        }
                    }
                    m = _
                }
            else {
                s = s || Gn,
                m = this._last;
                for (var N = i < 0 ? i : f; m; ) {
                    if (_ = m._prev,
                    (m._act || N <= m._end) && m._ts && x !== m) {
                        if (m.parent !== this)
                            return this.render(i, r, s);
                        if (m.render(m._ts > 0 ? (N - m._start) * m._ts : (m._dirty ? m.totalDuration() : m._tDur) + (N - m._start) * m._ts, r, s),
                        f !== this._time || !this._ts && !v) {
                            x = 0,
                            _ && (c += this._zTime = N ? -ut : ut);
                            break
                        }
                    }
                    m = _
                }
            }
            if (x && !r && (this.pause(),
            x.render(f >= a ? 0 : -ut)._zTime = f >= a ? 1 : -1,
            this._ts))
                return this._start = M,
                Ul(this),
                this.render(i, r, s);
            this._onUpdate && !r && Un(this, "onUpdate", !0),
            (c === l && this._tTime >= this.totalDuration() || !c && a) && (M === this._start || Math.abs(S) !== Math.abs(this._ts)) && (this._lock || ((i || !u) && (c === l && this._ts > 0 || !c && this._ts < 0) && Gi(this, 1),
            !r && !(i < 0 && !a) && (c || a || !l) && (Un(this, c === l && i >= 0 ? "onComplete" : "onReverseComplete", !0),
            this._prom && !(c < l && this.timeScale() > 0) && this._prom())))
        }
        return this
    }
    ,
    t.add = function(i, r) {
        var s = this;
        if (Vi(r) || (r = Rn(this, r, i)),
        !(i instanceof Ys)) {
            if (qt(i))
                return i.forEach(function(a) {
                    return s.add(a, r)
                }),
                this;
            if (kt(i))
                return this.addLabel(i, r);
            if (xt(i))
                i = Rt.delayedCall(0, i);
            else
                return this
        }
        return this !== i ? oi(this, i, r) : this
    }
    ,
    t.getChildren = function(i, r, s, a) {
        i === void 0 && (i = !0),
        r === void 0 && (r = !0),
        s === void 0 && (s = !0),
        a === void 0 && (a = -kn);
        for (var l = [], u = this._first; u; )
            u._start >= a && (u instanceof Rt ? r && l.push(u) : (s && l.push(u),
            i && l.push.apply(l, u.getChildren(!0, r, s)))),
            u = u._next;
        return l
    }
    ,
    t.getById = function(i) {
        for (var r = this.getChildren(1, 1, 1), s = r.length; s--; )
            if (r[s].vars.id === i)
                return r[s]
    }
    ,
    t.remove = function(i) {
        return kt(i) ? this.removeLabel(i) : xt(i) ? this.killTweensOf(i) : (zl(this, i),
        i === this._recent && (this._recent = this._last),
        Gr(this))
    }
    ,
    t.totalTime = function(i, r) {
        return arguments.length ? (this._forcing = 1,
        !this._dp && this._ts && (this._start = Bt(wn.time - (this._ts > 0 ? i / this._ts : (this.totalDuration() - i) / -this._ts))),
        o.prototype.totalTime.call(this, i, r),
        this._forcing = 0,
        this) : this._tTime
    }
    ,
    t.addLabel = function(i, r) {
        return this.labels[i] = Rn(this, r),
        this
    }
    ,
    t.removeLabel = function(i) {
        return delete this.labels[i],
        this
    }
    ,
    t.addPause = function(i, r, s) {
        var a = Rt.delayedCall(0, r || Yo, s);
        return a.data = "isPause",
        this._hasPause = 1,
        oi(this, a, Rn(this, i))
    }
    ,
    t.removePause = function(i) {
        var r = this._first;
        for (i = Rn(this, i); r; )
            r._start === i && r.data === "isPause" && Gi(r),
            r = r._next
    }
    ,
    t.killTweensOf = function(i, r, s) {
        for (var a = this.getTweensOf(i, s), l = a.length; l--; )
            ir !== a[l] && a[l].kill(i, r);
        return this
    }
    ,
    t.getTweensOf = function(i, r) {
        for (var s = [], a = zn(i), l = this._first, u = Vi(r), c; l; )
            l instanceof Rt ? T_(l._targets, a) && (u ? (!ir || l._initted && l._ts) && l.globalTime(0) <= r && l.globalTime(l.totalDuration()) > r : !r || l.isActive()) && s.push(l) : (c = l.getTweensOf(a, r)).length && s.push.apply(s, c),
            l = l._next;
        return s
    }
    ,
    t.tweenTo = function(i, r) {
        r = r || {};
        var s = this, a = Rn(s, i), l = r, u = l.startAt, c = l.onStart, h = l.onStartParams, f = l.immediateRender, m, _ = Rt.to(s, jn({
            ease: r.ease || "none",
            lazy: !1,
            immediateRender: !1,
            time: a,
            overwrite: "auto",
            duration: r.duration || Math.abs((a - (u && "time"in u ? u.time : s._time)) / s.timeScale()) || ut,
            onStart: function() {
                if (s.pause(),
                !m) {
                    var p = r.duration || Math.abs((a - (u && "time"in u ? u.time : s._time)) / s.timeScale());
                    _._dur !== p && qs(_, p, 0, 1).render(_._time, !0, !0),
                    m = 1
                }
                c && c.apply(_, h || [])
            }
        }, r));
        return f ? _.render(0) : _
    }
    ,
    t.tweenFromTo = function(i, r, s) {
        return this.tweenTo(r, jn({
            startAt: {
                time: Rn(this, i)
            }
        }, s))
    }
    ,
    t.recent = function() {
        return this._recent
    }
    ,
    t.nextLabel = function(i) {
        return i === void 0 && (i = this._time),
        Ph(this, Rn(this, i))
    }
    ,
    t.previousLabel = function(i) {
        return i === void 0 && (i = this._time),
        Ph(this, Rn(this, i), 1)
    }
    ,
    t.currentLabel = function(i) {
        return arguments.length ? this.seek(i, !0) : this.previousLabel(this._time + ut)
    }
    ,
    t.shiftChildren = function(i, r, s) {
        s === void 0 && (s = 0);
        for (var a = this._first, l = this.labels, u; a; )
            a._start >= s && (a._start += i,
            a._end += i),
            a = a._next;
        if (r)
            for (u in l)
                l[u] >= s && (l[u] += i);
        return Gr(this)
    }
    ,
    t.invalidate = function() {
        var i = this._first;
        for (this._lock = 0; i; )
            i.invalidate(),
            i = i._next;
        return o.prototype.invalidate.call(this)
    }
    ,
    t.clear = function(i) {
        i === void 0 && (i = !0);
        for (var r = this._first, s; r; )
            s = r._next,
            this.remove(r),
            r = s;
        return this._dp && (this._time = this._tTime = this._pTime = 0),
        i && (this.labels = {}),
        Gr(this)
    }
    ,
    t.totalDuration = function(i) {
        var r = 0, s = this, a = s._last, l = kn, u, c, h;
        if (arguments.length)
            return s.timeScale((s._repeat < 0 ? s.duration() : s.totalDuration()) / (s.reversed() ? -i : i));
        if (s._dirty) {
            for (h = s.parent; a; )
                u = a._prev,
                a._dirty && a.totalDuration(),
                c = a._start,
                c > l && s._sort && a._ts && !s._lock ? (s._lock = 1,
                oi(s, a, c - a._delay, 1)._lock = 0) : l = c,
                c < 0 && a._ts && (r -= c,
                (!h && !s._dp || h && h.smoothChildTiming) && (s._start += c / s._ts,
                s._time -= c,
                s._tTime -= c),
                s.shiftChildren(-c, !1, -1 / 0),
                l = 0),
                a._end > r && a._ts && (r = a._end),
                a = u;
            qs(s, s === dt && s._time > r ? s._time : r, 1, 1),
            s._dirty = 0
        }
        return s._tDur
    }
    ,
    e.updateRoot = function(i) {
        if (dt._ts && (Up(dt, El(i, dt)),
        kp = wn.frame),
        wn.frame >= Ah) {
            Ah += Sn.autoSleep || 120;
            var r = dt._first;
            if ((!r || !r._ts) && Sn.autoSleep && wn._listeners.length < 2) {
                for (; r && !r._ts; )
                    r = r._next;
                r || wn.sleep()
            }
        }
    }
    ,
    e
}(Ys);
jn(cn.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
});
var $_ = function(e, t, n, i, r, s, a) {
    var l = new mn(this._pt,e,t,0,1,hm,null,r), u = 0, c = 0, h, f, m, _, d, p, v, x;
    for (l.b = n,
    l.e = i,
    n += "",
    i += "",
    (v = ~i.indexOf("random(")) && (i = Ko(i)),
    s && (x = [n, i],
    s(x, e, t),
    n = x[0],
    i = x[1]),
    f = n.match(Ql) || []; h = Ql.exec(i); )
        _ = h[0],
        d = i.substring(u, h.index),
        m ? m = (m + 1) % 5 : d.substr(-5) === "rgba(" && (m = 1),
        _ !== f[c++] && (p = parseFloat(f[c - 1]) || 0,
        l._pt = {
            _next: l._pt,
            p: d || c === 1 ? d : ",",
            s: p,
            c: _.charAt(1) === "=" ? ks(p, _) - p : parseFloat(_) - p,
            m: m && m < 4 ? Math.round : 0
        },
        u = Ql.lastIndex);
    return l.c = u < i.length ? i.substring(u, i.length) : "",
    l.fp = a,
    (Pp.test(i) || v) && (l.e = 0),
    this._pt = l,
    l
}, qc = function(e, t, n, i, r, s, a, l, u, c) {
    xt(i) && (i = i(r || 0, e, s));
    var h = e[t], f = n !== "get" ? n : xt(h) ? u ? e[t.indexOf("set") || !xt(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](u) : e[t]() : h, m = xt(h) ? u ? t0 : um : Yc, _;
    if (kt(i) && (~i.indexOf("random(") && (i = Ko(i)),
    i.charAt(1) === "=" && (_ = ks(f, i) + (jt(f) || 0),
    (_ || _ === 0) && (i = _))),
    !c || f !== i || ac)
        return !isNaN(f * i) && i !== "" ? (_ = new mn(this._pt,e,t,+f || 0,i - (f || 0),typeof h == "boolean" ? i0 : cm,0,m),
        u && (_.fp = u),
        a && _.modifier(a, this, e),
        this._pt = _) : (!h && !(t in e) && Gc(t, i),
        $_.call(this, e, t, f, i, m, l || Sn.stringFilter, u))
}, Z_ = function(e, t, n, i, r) {
    if (xt(e) && (e = No(e, r, t, n, i)),
    !di(e) || e.style && e.nodeType || qt(e) || Lp(e))
        return kt(e) ? No(e, r, t, n, i) : e;
    var s = {}, a;
    for (a in e)
        s[a] = No(e[a], r, t, n, i);
    return s
}, om = function(e, t, n, i, r, s) {
    var a, l, u, c;
    if (bn[e] && (a = new bn[e]).init(r, a.rawVars ? t[e] : Z_(t[e], i, r, s, n), n, i, s) !== !1 && (n._pt = l = new mn(n._pt,r,e,0,1,a.render,a,0,a.priority),
    n !== Ps))
        for (u = n._ptLookup[n._targets.indexOf(r)],
        c = a._props.length; c--; )
            u[a._props[c]] = l;
    return a
}, ir, ac, Xc = function o(e, t) {
    var n = e.vars, i = n.ease, r = n.startAt, s = n.immediateRender, a = n.lazy, l = n.onUpdate, u = n.onUpdateParams, c = n.callbackScope, h = n.runBackwards, f = n.yoyoEase, m = n.keyframes, _ = n.autoRevert, d = e._dur, p = e._startAt, v = e._targets, x = e.parent, S = x && x.data === "nested" ? x.vars.targets : v, M = e._overwrite === "auto" && !Uc, T = e.timeline, L, P, A, C, N, G, q, g, w, E, R, z, b;
    if (T && (!m || !i) && (i = "none"),
    e._ease = Hr(i, Ws.ease),
    e._yEase = f ? nm(Hr(f === !0 ? i : f, Ws.ease)) : 0,
    f && e._yoyo && !e._repeat && (f = e._yEase,
    e._yEase = e._ease,
    e._ease = f),
    e._from = !T && !!n.runBackwards,
    !T || m && !n.stagger) {
        if (g = v[0] ? Vr(v[0]).harness : 0,
        z = g && n[g.prop],
        L = Tl(n, Hc),
        p && (t < 0 && h && s && !_ ? p.render(-1, !0) : p.revert(h && d ? Io : D_),
        p._lazy = 0),
        r) {
            if (Gi(e._startAt = Rt.set(v, jn({
                data: "isStart",
                overwrite: !1,
                parent: x,
                immediateRender: !0,
                lazy: dn(a),
                startAt: null,
                delay: 0,
                onUpdate: l,
                onUpdateParams: u,
                callbackScope: c,
                stagger: 0
            }, r))),
            t < 0 && (Gn || !s && !_) && e._startAt.revert(Io),
            s && d && t <= 0) {
                t && (e._zTime = t);
                return
            }
        } else if (h && d && !p) {
            if (t && (s = !1),
            A = jn({
                overwrite: !1,
                data: "isFromStart",
                lazy: s && dn(a),
                immediateRender: s,
                stagger: 0,
                parent: x
            }, L),
            z && (A[g.prop] = z),
            Gi(e._startAt = Rt.set(v, A)),
            t < 0 && (Gn ? e._startAt.revert(Io) : e._startAt.render(-1, !0)),
            e._zTime = t,
            !s)
                o(e._startAt, ut);
            else if (!t)
                return
        }
        for (e._pt = e._ptCache = 0,
        a = d && dn(a) || a && !d,
        P = 0; P < v.length; P++) {
            if (N = v[P],
            q = N._gsap || jc(v)[P]._gsap,
            e._ptLookup[P] = E = {},
            tc[q.id] && ar.length && Dl(),
            R = S === v ? P : S.indexOf(N),
            g && (w = new g).init(N, z || L, e, R, S) !== !1 && (e._pt = C = new mn(e._pt,N,w.name,0,1,w.render,w,0,w.priority),
            w._props.forEach(function(y) {
                E[y] = C
            }),
            w.priority && (G = 1)),
            !g || z)
                for (A in L)
                    bn[A] && (w = om(A, L, e, R, N, S)) ? w.priority && (G = 1) : E[A] = C = qc.call(e, N, A, "get", L[A], R, S, 0, n.stringFilter);
            e._op && e._op[P] && e.kill(N, e._op[P]),
            M && e._pt && (ir = e,
            dt.killTweensOf(N, E, e.globalTime(t)),
            b = !e.parent,
            ir = 0),
            e._pt && a && (tc[q.id] = 1)
        }
        G && fm(e),
        e._onInit && e._onInit(e)
    }
    e._onUpdate = l,
    e._initted = (!e._op || e._pt) && !b,
    m && t <= 0 && T.render(kn, !0, !0)
}, Q_ = function(e, t, n, i, r, s, a) {
    var l = (e._pt && e._ptCache || (e._ptCache = {}))[t], u, c, h, f;
    if (!l)
        for (l = e._ptCache[t] = [],
        h = e._ptLookup,
        f = e._targets.length; f--; ) {
            if (u = h[f][t],
            u && u.d && u.d._pt)
                for (u = u.d._pt; u && u.p !== t && u.fp !== t; )
                    u = u._next;
            if (!u)
                return ac = 1,
                e.vars[t] = "+=0",
                Xc(e, a),
                ac = 0,
                1;
            l.push(u)
        }
    for (f = l.length; f--; )
        c = l[f],
        u = c._pt || c,
        u.s = (i || i === 0) && !r ? i : u.s + (i || 0) + s * u.c,
        u.c = n - u.s,
        c.e && (c.e = wt(n) + jt(c.e)),
        c.b && (c.b = u.s + jt(c.b))
}, J_ = function(e, t) {
    var n = e[0] ? Vr(e[0]).harness : 0, i = n && n.aliases, r, s, a, l;
    if (!i)
        return t;
    r = Kr({}, t);
    for (s in i)
        if (s in r)
            for (l = i[s].split(","),
            a = l.length; a--; )
                r[l[a]] = r[s];
    return r
}, e0 = function(e, t, n, i) {
    var r = t.ease || i || "power1.inOut", s, a;
    if (qt(t))
        a = n[e] || (n[e] = []),
        t.forEach(function(l, u) {
            return a.push({
                t: u / (t.length - 1) * 100,
                v: l,
                e: r
            })
        });
    else
        for (s in t)
            a = n[s] || (n[s] = []),
            s === "ease" || a.push({
                t: parseFloat(e),
                v: t[s],
                e: r
            })
}, No = function(e, t, n, i, r) {
    return xt(e) ? e.call(t, n, i, r) : kt(e) && ~e.indexOf("random(") ? Ko(e) : e
}, am = Wc + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", lm = {};
pn(am + ",id,stagger,delay,duration,paused,scrollTrigger", function(o) {
    return lm[o] = 1
});
var Rt = function(o) {
    Ep(e, o);
    function e(n, i, r, s) {
        var a;
        typeof i == "number" && (r.duration = i,
        i = r,
        r = null),
        a = o.call(this, s ? i : Fo(i)) || this;
        var l = a.vars, u = l.duration, c = l.delay, h = l.immediateRender, f = l.stagger, m = l.overwrite, _ = l.keyframes, d = l.defaults, p = l.scrollTrigger, v = l.yoyoEase, x = i.parent || dt, S = (qt(n) || Lp(n) ? Vi(n[0]) : "length"in i) ? [n] : zn(n), M, T, L, P, A, C, N, G;
        if (a._targets = S.length ? jc(S) : Sl("GSAP target " + n + " not found. https://greensock.com", !Sn.nullTargetWarn) || [],
        a._ptLookup = [],
        a._overwrite = m,
        _ || f || va(u) || va(c)) {
            if (i = a.vars,
            M = a.timeline = new cn({
                data: "nested",
                defaults: d || {},
                targets: x && x.data === "nested" ? x.vars.targets : S
            }),
            M.kill(),
            M.parent = M._dp = Si(a),
            M._start = 0,
            f || va(u) || va(c)) {
                if (P = S.length,
                N = f && Yp(f),
                di(f))
                    for (A in f)
                        ~am.indexOf(A) && (G || (G = {}),
                        G[A] = f[A]);
                for (T = 0; T < P; T++)
                    L = Tl(i, lm),
                    L.stagger = 0,
                    v && (L.yoyoEase = v),
                    G && Kr(L, G),
                    C = S[T],
                    L.duration = +No(u, Si(a), T, C, S),
                    L.delay = (+No(c, Si(a), T, C, S) || 0) - a._delay,
                    !f && P === 1 && L.delay && (a._delay = c = L.delay,
                    a._start += c,
                    L.delay = 0),
                    M.to(C, L, N ? N(T, C, S) : 0),
                    M._ease = Ye.none;
                M.duration() ? u = c = 0 : a.timeline = 0
            } else if (_) {
                Fo(jn(M.vars.defaults, {
                    ease: "none"
                })),
                M._ease = Hr(_.ease || i.ease || "none");
                var q = 0, g, w, E;
                if (qt(_))
                    _.forEach(function(R) {
                        return M.to(S, R, ">")
                    }),
                    M.duration();
                else {
                    L = {};
                    for (A in _)
                        A === "ease" || A === "easeEach" || e0(A, _[A], L, _.easeEach);
                    for (A in L)
                        for (g = L[A].sort(function(R, z) {
                            return R.t - z.t
                        }),
                        q = 0,
                        T = 0; T < g.length; T++)
                            w = g[T],
                            E = {
                                ease: w.e,
                                duration: (w.t - (T ? g[T - 1].t : 0)) / 100 * u
                            },
                            E[A] = w.v,
                            M.to(S, E, q),
                            q += E.duration;
                    M.duration() < u && M.to({}, {
                        duration: u - M.duration()
                    })
                }
            }
            u || a.duration(u = M.duration())
        } else
            a.timeline = 0;
        return m === !0 && !Uc && (ir = Si(a),
        dt.killTweensOf(S),
        ir = 0),
        oi(x, Si(a), r),
        i.reversed && a.reverse(),
        i.paused && a.paused(!0),
        (h || !u && !_ && a._start === Bt(x._time) && dn(h) && L_(Si(a)) && x.data !== "nested") && (a._tTime = -ut,
        a.render(Math.max(0, -c))),
        p && Wp(Si(a), p),
        a
    }
    var t = e.prototype;
    return t.render = function(i, r, s) {
        var a = this._time, l = this._tDur, u = this._dur, c = i < 0, h = i > l - ut && !c ? l : i < ut ? 0 : i, f, m, _, d, p, v, x, S, M;
        if (!u)
            P_(this, i, r, s);
        else if (h !== this._tTime || !i || s || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== c) {
            if (f = h,
            S = this.timeline,
            this._repeat) {
                if (d = u + this._rDelay,
                this._repeat < -1 && c)
                    return this.totalTime(d * 100 + i, r, s);
                if (f = Bt(h % d),
                h === l ? (_ = this._repeat,
                f = u) : (_ = ~~(h / d),
                _ && _ === h / d && (f = u,
                _--),
                f > u && (f = u)),
                v = this._yoyo && _ & 1,
                v && (M = this._yEase,
                f = u - f),
                p = js(this._tTime, d),
                f === a && !s && this._initted)
                    return this._tTime = h,
                    this;
                _ !== p && (S && this._yEase && im(S, v),
                this.vars.repeatRefresh && !v && !this._lock && (this._lock = s = 1,
                this.render(Bt(d * _), !0).invalidate()._lock = 0))
            }
            if (!this._initted) {
                if (jp(this, c ? i : f, s, r))
                    return this._tTime = 0,
                    this;
                if (a !== this._time)
                    return this;
                if (u !== this._dur)
                    return this.render(i, r, s)
            }
            if (this._tTime = h,
            this._time = f,
            !this._act && this._ts && (this._act = 1,
            this._lazy = 0),
            this.ratio = x = (M || this._ease)(f / u),
            this._from && (this.ratio = x = 1 - x),
            f && !a && !r && (Un(this, "onStart"),
            this._tTime !== h))
                return this;
            for (m = this._pt; m; )
                m.r(x, m.d),
                m = m._next;
            S && S.render(i < 0 ? i : !f && v ? -ut : S._dur * S._ease(f / this._dur), r, s) || this._startAt && (this._zTime = i),
            this._onUpdate && !r && (c && nc(this, i, r, s),
            Un(this, "onUpdate")),
            this._repeat && _ !== p && this.vars.onRepeat && !r && this.parent && Un(this, "onRepeat"),
            (h === this._tDur || !h) && this._tTime === h && (c && !this._onUpdate && nc(this, i, !0, !0),
            (i || !u) && (h === this._tDur && this._ts > 0 || !h && this._ts < 0) && Gi(this, 1),
            !r && !(c && !a) && (h || a) && (Un(this, h === l ? "onComplete" : "onReverseComplete", !0),
            this._prom && !(h < l && this.timeScale() > 0) && this._prom()))
        }
        return this
    }
    ,
    t.targets = function() {
        return this._targets
    }
    ,
    t.invalidate = function() {
        return this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0,
        this._ptLookup = [],
        this.timeline && this.timeline.invalidate(),
        o.prototype.invalidate.call(this)
    }
    ,
    t.resetTo = function(i, r, s, a) {
        $o || wn.wake(),
        this._ts || this.play();
        var l = Math.min(this._dur, (this._dp._time - this._start) * this._ts), u;
        return this._initted || Xc(this, l),
        u = this._ease(l / this._dur),
        Q_(this, i, r, s, a, u, l) ? this.resetTo(i, r, s, a) : (Bl(this, 0),
        this.parent || Gp(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0),
        this.render(0))
    }
    ,
    t.kill = function(i, r) {
        if (r === void 0 && (r = "all"),
        !i && (!r || r === "all"))
            return this._lazy = this._pt = 0,
            this.parent ? To(this) : this;
        if (this.timeline) {
            var s = this.timeline.totalDuration();
            return this.timeline.killTweensOf(i, r, ir && ir.vars.overwrite !== !0)._first || To(this),
            this.parent && s !== this.timeline.totalDuration() && qs(this, this._dur * this.timeline._tDur / s, 0, 1),
            this
        }
        var a = this._targets, l = i ? zn(i) : a, u = this._ptLookup, c = this._pt, h, f, m, _, d, p, v;
        if ((!r || r === "all") && A_(a, l))
            return r === "all" && (this._pt = 0),
            To(this);
        for (h = this._op = this._op || [],
        r !== "all" && (kt(r) && (d = {},
        pn(r, function(x) {
            return d[x] = 1
        }),
        r = d),
        r = J_(a, r)),
        v = a.length; v--; )
            if (~l.indexOf(a[v])) {
                f = u[v],
                r === "all" ? (h[v] = r,
                _ = f,
                m = {}) : (m = h[v] = h[v] || {},
                _ = r);
                for (d in _)
                    p = f && f[d],
                    p && ((!("kill"in p.d) || p.d.kill(d) === !0) && zl(this, p, "_pt"),
                    delete f[d]),
                    m !== "all" && (m[d] = 1)
            }
        return this._initted && !this._pt && c && To(this),
        this
    }
    ,
    e.to = function(i, r) {
        return new e(i,r,arguments[2])
    }
    ,
    e.from = function(i, r) {
        return Oo(1, arguments)
    }
    ,
    e.delayedCall = function(i, r, s, a) {
        return new e(r,0,{
            immediateRender: !1,
            lazy: !1,
            overwrite: !1,
            delay: i,
            onComplete: r,
            onReverseComplete: r,
            onCompleteParams: s,
            onReverseCompleteParams: s,
            callbackScope: a
        })
    }
    ,
    e.fromTo = function(i, r, s) {
        return Oo(2, arguments)
    }
    ,
    e.set = function(i, r) {
        return r.duration = 0,
        r.repeatDelay || (r.repeat = 0),
        new e(i,r)
    }
    ,
    e.killTweensOf = function(i, r, s) {
        return dt.killTweensOf(i, r, s)
    }
    ,
    e
}(Ys);
jn(Rt.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
});
pn("staggerTo,staggerFrom,staggerFromTo", function(o) {
    Rt[o] = function() {
        var e = new cn
          , t = rc.call(arguments, 0);
        return t.splice(o === "staggerFromTo" ? 5 : 4, 0, 0),
        e[o].apply(e, t)
    }
});
var Yc = function(e, t, n) {
    return e[t] = n
}
  , um = function(e, t, n) {
    return e[t](n)
}
  , t0 = function(e, t, n, i) {
    return e[t](i.fp, n)
}
  , n0 = function(e, t, n) {
    return e.setAttribute(t, n)
}
  , Kc = function(e, t) {
    return xt(e[t]) ? um : Bc(e[t]) && e.setAttribute ? n0 : Yc
}
  , cm = function(e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t)
}
  , i0 = function(e, t) {
    return t.set(t.t, t.p, !!(t.s + t.c * e), t)
}
  , hm = function(e, t) {
    var n = t._pt
      , i = "";
    if (!e && t.b)
        i = t.b;
    else if (e === 1 && t.e)
        i = t.e;
    else {
        for (; n; )
            i = n.p + (n.m ? n.m(n.s + n.c * e) : Math.round((n.s + n.c * e) * 1e4) / 1e4) + i,
            n = n._next;
        i += t.c
    }
    t.set(t.t, t.p, i, t)
}
  , $c = function(e, t) {
    for (var n = t._pt; n; )
        n.r(e, n.d),
        n = n._next
}
  , r0 = function(e, t, n, i) {
    for (var r = this._pt, s; r; )
        s = r._next,
        r.p === i && r.modifier(e, t, n),
        r = s
}
  , s0 = function(e) {
    for (var t = this._pt, n, i; t; )
        i = t._next,
        t.p === e && !t.op || t.op === e ? zl(this, t, "_pt") : t.dep || (n = 1),
        t = i;
    return !n
}
  , o0 = function(e, t, n, i) {
    i.mSet(e, t, i.m.call(i.tween, n, i.mt), i)
}
  , fm = function(e) {
    for (var t = e._pt, n, i, r, s; t; ) {
        for (n = t._next,
        i = r; i && i.pr > t.pr; )
            i = i._next;
        (t._prev = i ? i._prev : s) ? t._prev._next = t : r = t,
        (t._next = i) ? i._prev = t : s = t,
        t = n
    }
    e._pt = r
}
  , mn = function() {
    function o(t, n, i, r, s, a, l, u, c) {
        this.t = n,
        this.s = r,
        this.c = s,
        this.p = i,
        this.r = a || cm,
        this.d = l || this,
        this.set = u || Yc,
        this.pr = c || 0,
        this._next = t,
        t && (t._prev = this)
    }
    var e = o.prototype;
    return e.modifier = function(n, i, r) {
        this.mSet = this.mSet || this.set,
        this.set = o0,
        this.m = n,
        this.mt = r,
        this.tween = i
    }
    ,
    o
}();
pn(Wc + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(o) {
    return Hc[o] = 1
});
Dn.TweenMax = Dn.TweenLite = Rt;
Dn.TimelineLite = Dn.TimelineMax = cn;
dt = new cn({
    sortChildren: !1,
    defaults: Ws,
    autoRemoveChildren: !0,
    id: "root",
    smoothChildTiming: !0
});
Sn.stringFilter = tm;
var Ks = []
  , ul = {}
  , a0 = []
  , Fh = 0
  , iu = function(e) {
    return (ul[e] || a0).map(function(t) {
        return t()
    })
}
  , lc = function() {
    var e = Date.now()
      , t = [];
    e - Fh > 2 && (iu("matchMediaInit"),
    Ks.forEach(function(n) {
        var i = n.queries, r = n.conditions, s, a, l, u;
        for (a in i)
            s = Pn.matchMedia(i[a]).matches,
            s && (l = 1),
            s !== r[a] && (r[a] = s,
            u = 1);
        u && (n.revert(),
        l && t.push(n))
    }),
    iu("matchMediaRevert"),
    t.forEach(function(n) {
        return n.onMatch(n)
    }),
    Fh = e,
    iu("matchMedia"))
}
  , dm = function() {
    function o(t, n) {
        this.selector = n && sc(n),
        this.data = [],
        this._r = [],
        this.isReverted = !1,
        t && this.add(t)
    }
    var e = o.prototype;
    return e.add = function(n, i, r) {
        xt(n) && (r = i,
        i = n,
        n = xt);
        var s = this
          , a = function() {
            var u = Et, c = s.selector, h;
            return u && u !== s && u.data.push(s),
            r && (s.selector = sc(r)),
            Et = s,
            h = i.apply(s, arguments),
            xt(h) && s._r.push(h),
            Et = u,
            s.selector = c,
            s.isReverted = !1,
            h
        };
        return s.last = a,
        n === xt ? a(s) : n ? s[n] = a : a
    }
    ,
    e.ignore = function(n) {
        var i = Et;
        Et = null,
        n(this),
        Et = i
    }
    ,
    e.getTweens = function() {
        var n = [];
        return this.data.forEach(function(i) {
            return i instanceof o ? n.push.apply(n, i.getTweens()) : i instanceof Rt && n.push(i)
        }),
        n
    }
    ,
    e.clear = function() {
        this._r.length = this.data.length = 0
    }
    ,
    e.kill = function(n, i) {
        var r = this;
        if (n ? (this.getTweens().map(function(a) {
            return {
                g: a.globalTime(0),
                t: a
            }
        }).sort(function(a, l) {
            return l.g - a.g || -1
        }).forEach(function(a) {
            return a.t.revert(n)
        }),
        this.data.forEach(function(a) {
            return !(a instanceof Ys) && a.revert && a.revert(n)
        }),
        this._r.forEach(function(a) {
            return a(n, r)
        }),
        this.isReverted = !0) : this.data.forEach(function(a) {
            return a.kill && a.kill()
        }),
        this.clear(),
        i) {
            var s = Ks.indexOf(this);
            ~s && Ks.splice(s, 1)
        }
    }
    ,
    e.revert = function(n) {
        this.kill(n || {})
    }
    ,
    o
}()
  , l0 = function() {
    function o(t) {
        this.contexts = [],
        this.scope = t
    }
    var e = o.prototype;
    return e.add = function(n, i, r) {
        di(n) || (n = {
            matches: n
        });
        var s = new dm(0,r || this.scope), a = s.conditions = {}, l, u, c;
        this.contexts.push(s),
        i = s.add("onMatch", i),
        s.queries = n;
        for (u in n)
            u === "all" ? c = 1 : (l = Pn.matchMedia(n[u]),
            l && (Ks.indexOf(s) < 0 && Ks.push(s),
            (a[u] = l.matches) && (c = 1),
            l.addListener ? l.addListener(lc) : l.addEventListener("change", lc)));
        return c && i(s),
        this
    }
    ,
    e.revert = function(n) {
        this.kill(n || {})
    }
    ,
    e.kill = function(n) {
        this.contexts.forEach(function(i) {
            return i.kill(n, !0)
        })
    }
    ,
    o
}()
  , Al = {
    registerPlugin: function() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
        t.forEach(function(i) {
            return H_(i)
        })
    },
    timeline: function(e) {
        return new cn(e)
    },
    getTweensOf: function(e, t) {
        return dt.getTweensOf(e, t)
    },
    getProperty: function(e, t, n, i) {
        kt(e) && (e = zn(e)[0]);
        var r = Vr(e || {}).get
          , s = n ? Vp : Bp;
        return n === "native" && (n = ""),
        e && (t ? s((bn[t] && bn[t].get || r)(e, t, n, i)) : function(a, l, u) {
            return s((bn[a] && bn[a].get || r)(e, a, l, u))
        }
        )
    },
    quickSetter: function(e, t, n) {
        if (e = zn(e),
        e.length > 1) {
            var i = e.map(function(c) {
                return Tn.quickSetter(c, t, n)
            })
              , r = i.length;
            return function(c) {
                for (var h = r; h--; )
                    i[h](c)
            }
        }
        e = e[0] || {};
        var s = bn[t]
          , a = Vr(e)
          , l = a.harness && (a.harness.aliases || {})[t] || t
          , u = s ? function(c) {
            var h = new s;
            Ps._pt = 0,
            h.init(e, n ? c + n : c, Ps, 0, [e]),
            h.render(1, h),
            Ps._pt && $c(1, Ps)
        }
        : a.set(e, l);
        return s ? u : function(c) {
            return u(e, l, n ? c + n : c, a, 1)
        }
    },
    quickTo: function(e, t, n) {
        var i, r = Tn.to(e, Kr((i = {},
        i[t] = "+=0.1",
        i.paused = !0,
        i), n || {})), s = function(l, u, c) {
            return r.resetTo(t, l, u, c)
        };
        return s.tween = r,
        s
    },
    isTweening: function(e) {
        return dt.getTweensOf(e, !0).length > 0
    },
    defaults: function(e) {
        return e && e.ease && (e.ease = Hr(e.ease, Ws.ease)),
        Ch(Ws, e || {})
    },
    config: function(e) {
        return Ch(Sn, e || {})
    },
    registerEffect: function(e) {
        var t = e.name
          , n = e.effect
          , i = e.plugins
          , r = e.defaults
          , s = e.extendTimeline;
        (i || "").split(",").forEach(function(a) {
            return a && !bn[a] && !Dn[a] && Sl(t + " effect requires " + a + " plugin.")
        }),
        Jl[t] = function(a, l, u) {
            return n(zn(a), jn(l || {}, r), u)
        }
        ,
        s && (cn.prototype[t] = function(a, l, u) {
            return this.add(Jl[t](a, di(l) ? l : (u = l) && {}, this), u)
        }
        )
    },
    registerEase: function(e, t) {
        Ye[e] = Hr(t)
    },
    parseEase: function(e, t) {
        return arguments.length ? Hr(e, t) : Ye
    },
    getById: function(e) {
        return dt.getById(e)
    },
    exportRoot: function(e, t) {
        e === void 0 && (e = {});
        var n = new cn(e), i, r;
        for (n.smoothChildTiming = dn(e.smoothChildTiming),
        dt.remove(n),
        n._dp = 0,
        n._time = n._tTime = dt._time,
        i = dt._first; i; )
            r = i._next,
            (t || !(!i._dur && i instanceof Rt && i.vars.onComplete === i._targets[0])) && oi(n, i, i._start - i._delay),
            i = r;
        return oi(dt, n, 0),
        n
    },
    context: function(e, t) {
        return e ? new dm(e,t) : Et
    },
    matchMedia: function(e) {
        return new l0(e)
    },
    matchMediaRefresh: function() {
        return Ks.forEach(function(e) {
            var t = e.conditions, n, i;
            for (i in t)
                t[i] && (t[i] = !1,
                n = 1);
            n && e.revert()
        }) || lc()
    },
    addEventListener: function(e, t) {
        var n = ul[e] || (ul[e] = []);
        ~n.indexOf(t) || n.push(t)
    },
    removeEventListener: function(e, t) {
        var n = ul[e]
          , i = n && n.indexOf(t);
        i >= 0 && n.splice(i, 1)
    },
    utils: {
        wrap: B_,
        wrapYoyo: V_,
        distribute: Yp,
        random: $p,
        snap: Kp,
        normalize: U_,
        getUnit: jt,
        clamp: O_,
        splitColor: Jp,
        toArray: zn,
        selector: sc,
        mapRange: Qp,
        pipe: k_,
        unitize: z_,
        interpolate: G_,
        shuffle: Xp
    },
    install: Op,
    effects: Jl,
    ticker: wn,
    updateRoot: cn.updateRoot,
    plugins: bn,
    globalTimeline: dt,
    core: {
        PropTween: mn,
        globals: Np,
        Tween: Rt,
        Timeline: cn,
        Animation: Ys,
        getCache: Vr,
        _removeLinkedListItem: zl,
        reverting: function() {
            return Gn
        },
        context: function(e) {
            return e && Et && (Et.data.push(e),
            e._ctx = Et),
            Et
        },
        suppressOverwrites: function(e) {
            return Uc = e
        }
    }
};
pn("to,from,fromTo,delayedCall,set,killTweensOf", function(o) {
    return Al[o] = Rt[o]
});
wn.add(cn.updateRoot);
Ps = Al.to({}, {
    duration: 0
});
var u0 = function(e, t) {
    for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t; )
        n = n._next;
    return n
}
  , c0 = function(e, t) {
    var n = e._targets, i, r, s;
    for (i in t)
        for (r = n.length; r--; )
            s = e._ptLookup[r][i],
            s && (s = s.d) && (s._pt && (s = u0(s, i)),
            s && s.modifier && s.modifier(t[i], e, n[r], i))
}
  , ru = function(e, t) {
    return {
        name: e,
        rawVars: 1,
        init: function(i, r, s) {
            s._onInit = function(a) {
                var l, u;
                if (kt(r) && (l = {},
                pn(r, function(c) {
                    return l[c] = 1
                }),
                r = l),
                t) {
                    l = {};
                    for (u in r)
                        l[u] = t(r[u]);
                    r = l
                }
                c0(a, r)
            }
        }
    }
}
  , Tn = Al.registerPlugin({
    name: "attr",
    init: function(e, t, n, i, r) {
        var s, a, l;
        this.tween = n;
        for (s in t)
            l = e.getAttribute(s) || "",
            a = this.add(e, "setAttribute", (l || 0) + "", t[s], i, r, 0, 0, s),
            a.op = s,
            a.b = l,
            this._props.push(s)
    },
    render: function(e, t) {
        for (var n = t._pt; n; )
            Gn ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d),
            n = n._next
    }
}, {
    name: "endArray",
    init: function(e, t) {
        for (var n = t.length; n--; )
            this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1)
    }
}, ru("roundProps", oc), ru("modifiers"), ru("snap", Kp)) || Al;
Rt.version = cn.version = Tn.version = "3.11.1";
Fp = 1;
Cp() && Xs();
Ye.Power0;
Ye.Power1;
Ye.Power2;
Ye.Power3;
Ye.Power4;
Ye.Linear;
Ye.Quad;
Ye.Cubic;
Ye.Quart;
Ye.Quint;
Ye.Strong;
Ye.Elastic;
Ye.Back;
Ye.SteppedEase;
Ye.Bounce;
Ye.Sine;
Ye.Expo;
Ye.Circ;
/*!
 * CSSPlugin 3.11.1
 * https://greensock.com
 *
 * Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var Oh, rr, zs, Zc, Ir, Nh, Qc, h0 = function() {
    return typeof window < "u"
}, Hi = {}, Tr = 180 / Math.PI, Us = Math.PI / 180, us = Math.atan2, kh = 1e8, Jc = /([A-Z])/g, f0 = /(left|right|width|margin|padding|x)/i, d0 = /[\s,\(]\S/, Ri = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity"
}, uc = function(e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
}, p0 = function(e, t) {
    return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
}, m0 = function(e, t) {
    return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t)
}, g0 = function(e, t) {
    var n = t.s + t.c * e;
    t.set(t.t, t.p, ~~(n + (n < 0 ? -.5 : .5)) + t.u, t)
}, pm = function(e, t) {
    return t.set(t.t, t.p, e ? t.e : t.b, t)
}, mm = function(e, t) {
    return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t)
}, _0 = function(e, t, n) {
    return e.style[t] = n
}, v0 = function(e, t, n) {
    return e.style.setProperty(t, n)
}, x0 = function(e, t, n) {
    return e._gsap[t] = n
}, y0 = function(e, t, n) {
    return e._gsap.scaleX = e._gsap.scaleY = n
}, b0 = function(e, t, n, i, r) {
    var s = e._gsap;
    s.scaleX = s.scaleY = n,
    s.renderTransform(r, s)
}, w0 = function(e, t, n, i, r) {
    var s = e._gsap;
    s[t] = n,
    s.renderTransform(r, s)
}, vt = "transform", ei = vt + "Origin", M0 = function(e) {
    var t = this
      , n = this.target
      , i = n.style;
    if (e in Hi) {
        if (this.tfm = this.tfm || {},
        e !== "transform" && (e = Ri[e] || e,
        ~e.indexOf(",") ? e.split(",").forEach(function(r) {
            return t.tfm[r] = Ti(n, r)
        }) : this.tfm[e] = n._gsap.x ? n._gsap[e] : Ti(n, e)),
        this.props.indexOf(vt) >= 0)
            return;
        n._gsap.svg && (this.svgo = n.getAttribute("data-svg-origin"),
        this.props.push(ei, "")),
        e = vt
    }
    i && this.props.push(e, i[e])
}, gm = function(e) {
    e.translate && (e.removeProperty("translate"),
    e.removeProperty("scale"),
    e.removeProperty("rotate"))
}, S0 = function() {
    var e = this.props, t = this.target, n = t.style, i = t._gsap, r, s;
    for (r = 0; r < e.length; r += 2)
        e[r + 1] ? n[e[r]] = e[r + 1] : n.removeProperty(e[r].replace(Jc, "-$1").toLowerCase());
    if (this.tfm) {
        for (s in this.tfm)
            i[s] = this.tfm[s];
        i.svg && (i.renderTransform(),
        t.setAttribute("data-svg-origin", this.svgo || "")),
        r = Qc(),
        r && !r.isStart && !n[vt] && (gm(n),
        i.uncache = 1)
    }
}, _m = function(e, t) {
    var n = {
        target: e,
        props: [],
        revert: S0,
        save: M0
    };
    return t && t.split(",").forEach(function(i) {
        return n.save(i)
    }),
    n
}, vm, cc = function(e, t) {
    var n = rr.createElementNS ? rr.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : rr.createElement(e);
    return n.style ? n : rr.createElement(e)
}, ui = function o(e, t, n) {
    var i = getComputedStyle(e);
    return i[t] || i.getPropertyValue(t.replace(Jc, "-$1").toLowerCase()) || i.getPropertyValue(t) || !n && o(e, $s(t) || t, 1) || ""
}, zh = "O,Moz,ms,Ms,Webkit".split(","), $s = function(e, t, n) {
    var i = t || Ir
      , r = i.style
      , s = 5;
    if (e in r && !n)
        return e;
    for (e = e.charAt(0).toUpperCase() + e.substr(1); s-- && !(zh[s] + e in r); )
        ;
    return s < 0 ? null : (s === 3 ? "ms" : s >= 0 ? zh[s] : "") + e
}, hc = function() {
    h0() && window.document && (Oh = window,
    rr = Oh.document,
    zs = rr.documentElement,
    Ir = cc("div") || {
        style: {}
    },
    cc("div"),
    vt = $s(vt),
    ei = vt + "Origin",
    Ir.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0",
    vm = !!$s("perspective"),
    Qc = Tn.core.reverting,
    Zc = 1)
}, su = function o(e) {
    var t = cc("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), n = this.parentNode, i = this.nextSibling, r = this.style.cssText, s;
    if (zs.appendChild(t),
    t.appendChild(this),
    this.style.display = "block",
    e)
        try {
            s = this.getBBox(),
            this._gsapBBox = this.getBBox,
            this.getBBox = o
        } catch {}
    else
        this._gsapBBox && (s = this._gsapBBox());
    return n && (i ? n.insertBefore(this, i) : n.appendChild(this)),
    zs.removeChild(t),
    this.style.cssText = r,
    s
}, Uh = function(e, t) {
    for (var n = t.length; n--; )
        if (e.hasAttribute(t[n]))
            return e.getAttribute(t[n])
}, xm = function(e) {
    var t;
    try {
        t = e.getBBox()
    } catch {
        t = su.call(e, !0)
    }
    return t && (t.width || t.height) || e.getBBox === su || (t = su.call(e, !0)),
    t && !t.width && !t.x && !t.y ? {
        x: +Uh(e, ["x", "cx", "x1"]) || 0,
        y: +Uh(e, ["y", "cy", "y1"]) || 0,
        width: 0,
        height: 0
    } : t
}, ym = function(e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && xm(e))
}, Zo = function(e, t) {
    if (t) {
        var n = e.style;
        t in Hi && t !== ei && (t = vt),
        n.removeProperty ? ((t.substr(0, 2) === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t),
        n.removeProperty(t.replace(Jc, "-$1").toLowerCase())) : n.removeAttribute(t)
    }
}, sr = function(e, t, n, i, r, s) {
    var a = new mn(e._pt,t,n,0,1,s ? mm : pm);
    return e._pt = a,
    a.b = i,
    a.e = r,
    e._props.push(n),
    a
}, Bh = {
    deg: 1,
    rad: 1,
    turn: 1
}, D0 = {
    grid: 1,
    flex: 1
}, fr = function o(e, t, n, i) {
    var r = parseFloat(n) || 0, s = (n + "").trim().substr((r + "").length) || "px", a = Ir.style, l = f0.test(t), u = e.tagName.toLowerCase() === "svg", c = (u ? "client" : "offset") + (l ? "Width" : "Height"), h = 100, f = i === "px", m = i === "%", _, d, p, v;
    return i === s || !r || Bh[i] || Bh[s] ? r : (s !== "px" && !f && (r = o(e, t, n, "px")),
    v = e.getCTM && ym(e),
    (m || s === "%") && (Hi[t] || ~t.indexOf("adius")) ? (_ = v ? e.getBBox()[l ? "width" : "height"] : e[c],
    wt(m ? r / _ * h : r / 100 * _)) : (a[l ? "width" : "height"] = h + (f ? s : i),
    d = ~t.indexOf("adius") || i === "em" && e.appendChild && !u ? e : e.parentNode,
    v && (d = (e.ownerSVGElement || {}).parentNode),
    (!d || d === rr || !d.appendChild) && (d = rr.body),
    p = d._gsap,
    p && m && p.width && l && p.time === wn.time && !p.uncache ? wt(r / p.width * h) : ((m || s === "%") && !D0[ui(d, "display")] && (a.position = ui(e, "position")),
    d === e && (a.position = "static"),
    d.appendChild(Ir),
    _ = Ir[c],
    d.removeChild(Ir),
    a.position = "absolute",
    l && m && (p = Vr(d),
    p.time = wn.time,
    p.width = d[c]),
    wt(f ? _ * r / h : _ && r ? h / _ * r : 0))))
}, Ti = function(e, t, n, i) {
    var r;
    return Zc || hc(),
    t in Ri && t !== "transform" && (t = Ri[t],
    ~t.indexOf(",") && (t = t.split(",")[0])),
    Hi[t] && t !== "transform" ? (r = Jo(e, i),
    r = t !== "transformOrigin" ? r[t] : r.svg ? r.origin : Ll(ui(e, ei)) + " " + r.zOrigin + "px") : (r = e.style[t],
    (!r || r === "auto" || i || ~(r + "").indexOf("calc(")) && (r = Cl[t] && Cl[t](e, t, n) || ui(e, t) || zp(e, t) || (t === "opacity" ? 1 : 0))),
    n && !~(r + "").trim().indexOf(" ") ? fr(e, t, r, n) + n : r
}, T0 = function(e, t, n, i) {
    if (!n || n === "none") {
        var r = $s(t, e, 1)
          , s = r && ui(e, r, 1);
        s && s !== n ? (t = r,
        n = s) : t === "borderColor" && (n = ui(e, "borderTopColor"))
    }
    var a = new mn(this._pt,e.style,t,0,1,hm), l = 0, u = 0, c, h, f, m, _, d, p, v, x, S, M, T;
    if (a.b = n,
    a.e = i,
    n += "",
    i += "",
    i === "auto" && (e.style[t] = i,
    i = ui(e, t) || i,
    e.style[t] = n),
    c = [n, i],
    tm(c),
    n = c[0],
    i = c[1],
    f = n.match(Rs) || [],
    T = i.match(Rs) || [],
    T.length) {
        for (; h = Rs.exec(i); )
            p = h[0],
            x = i.substring(l, h.index),
            _ ? _ = (_ + 1) % 5 : (x.substr(-5) === "rgba(" || x.substr(-5) === "hsla(") && (_ = 1),
            p !== (d = f[u++] || "") && (m = parseFloat(d) || 0,
            M = d.substr((m + "").length),
            p.charAt(1) === "=" && (p = ks(m, p) + M),
            v = parseFloat(p),
            S = p.substr((v + "").length),
            l = Rs.lastIndex - S.length,
            S || (S = S || Sn.units[t] || M,
            l === i.length && (i += S,
            a.e += S)),
            M !== S && (m = fr(e, t, d, S) || 0),
            a._pt = {
                _next: a._pt,
                p: x || u === 1 ? x : ",",
                s: m,
                c: v - m,
                m: _ && _ < 4 || t === "zIndex" ? Math.round : 0
            });
        a.c = l < i.length ? i.substring(l, i.length) : ""
    } else
        a.r = t === "display" && i === "none" ? mm : pm;
    return Pp.test(i) && (a.e = 0),
    this._pt = a,
    a
}, Vh = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%"
}, E0 = function(e) {
    var t = e.split(" ")
      , n = t[0]
      , i = t[1] || "50%";
    return (n === "top" || n === "bottom" || i === "left" || i === "right") && (e = n,
    n = i,
    i = e),
    t[0] = Vh[n] || n,
    t[1] = Vh[i] || i,
    t.join(" ")
}, A0 = function(e, t) {
    if (t.tween && t.tween._time === t.tween._dur) {
        var n = t.t, i = n.style, r = t.u, s = n._gsap, a, l, u;
        if (r === "all" || r === !0)
            i.cssText = "",
            l = 1;
        else
            for (r = r.split(","),
            u = r.length; --u > -1; )
                a = r[u],
                Hi[a] && (l = 1,
                a = a === "transformOrigin" ? ei : vt),
                Zo(n, a);
        l && (Zo(n, vt),
        s && (s.svg && n.removeAttribute("transform"),
        Jo(n, 1),
        s.uncache = 1,
        gm(i)))
    }
}, Cl = {
    clearProps: function(e, t, n, i, r) {
        if (r.data !== "isFromStart") {
            var s = e._pt = new mn(e._pt,t,n,0,0,A0);
            return s.u = i,
            s.pr = -10,
            s.tween = r,
            e._props.push(n),
            1
        }
    }
}, Qo = [1, 0, 0, 1, 0, 0], bm = {}, wm = function(e) {
    return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e
}, Gh = function(e) {
    var t = ui(e, vt);
    return wm(t) ? Qo : t.substr(7).match(Rp).map(wt)
}, eh = function(e, t) {
    var n = e._gsap || Vr(e), i = e.style, r = Gh(e), s, a, l, u;
    return n.svg && e.getAttribute("transform") ? (l = e.transform.baseVal.consolidate().matrix,
    r = [l.a, l.b, l.c, l.d, l.e, l.f],
    r.join(",") === "1,0,0,1,0,0" ? Qo : r) : (r === Qo && !e.offsetParent && e !== zs && !n.svg && (l = i.display,
    i.display = "block",
    s = e.parentNode,
    (!s || !e.offsetParent) && (u = 1,
    a = e.nextElementSibling,
    zs.appendChild(e)),
    r = Gh(e),
    l ? i.display = l : Zo(e, "display"),
    u && (a ? s.insertBefore(e, a) : s ? s.appendChild(e) : zs.removeChild(e))),
    t && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r)
}, fc = function(e, t, n, i, r, s) {
    var a = e._gsap, l = r || eh(e, !0), u = a.xOrigin || 0, c = a.yOrigin || 0, h = a.xOffset || 0, f = a.yOffset || 0, m = l[0], _ = l[1], d = l[2], p = l[3], v = l[4], x = l[5], S = t.split(" "), M = parseFloat(S[0]) || 0, T = parseFloat(S[1]) || 0, L, P, A, C;
    n ? l !== Qo && (P = m * p - _ * d) && (A = M * (p / P) + T * (-d / P) + (d * x - p * v) / P,
    C = M * (-_ / P) + T * (m / P) - (m * x - _ * v) / P,
    M = A,
    T = C) : (L = xm(e),
    M = L.x + (~S[0].indexOf("%") ? M / 100 * L.width : M),
    T = L.y + (~(S[1] || S[0]).indexOf("%") ? T / 100 * L.height : T)),
    i || i !== !1 && a.smooth ? (v = M - u,
    x = T - c,
    a.xOffset = h + (v * m + x * d) - v,
    a.yOffset = f + (v * _ + x * p) - x) : a.xOffset = a.yOffset = 0,
    a.xOrigin = M,
    a.yOrigin = T,
    a.smooth = !!i,
    a.origin = t,
    a.originIsAbsolute = !!n,
    e.style[ei] = "0px 0px",
    s && (sr(s, a, "xOrigin", u, M),
    sr(s, a, "yOrigin", c, T),
    sr(s, a, "xOffset", h, a.xOffset),
    sr(s, a, "yOffset", f, a.yOffset)),
    e.setAttribute("data-svg-origin", M + " " + T)
}, Jo = function(e, t) {
    var n = e._gsap || new sm(e);
    if ("x"in n && !t && !n.uncache)
        return n;
    var i = e.style, r = n.scaleX < 0, s = "px", a = "deg", l = getComputedStyle(e), u = ui(e, ei) || "0", c, h, f, m, _, d, p, v, x, S, M, T, L, P, A, C, N, G, q, g, w, E, R, z, b, y, D, I, F, B, H, W;
    return c = h = f = d = p = v = x = S = M = 0,
    m = _ = 1,
    n.svg = !!(e.getCTM && ym(e)),
    l.translate && ((l.translate !== "none" || l.scale !== "none" || l.rotate !== "none") && (i[vt] = (l.translate !== "none" ? "translate3d(" + (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") + (l.scale !== "none" ? "scale(" + l.scale.split(" ").join(",") + ") " : "") + l[vt]),
    i.scale = i.rotate = i.translate = "none"),
    P = eh(e, n.svg),
    n.svg && (n.uncache ? (b = e.getBBox(),
    u = n.xOrigin - b.x + "px " + (n.yOrigin - b.y) + "px",
    z = "") : z = !t && e.getAttribute("data-svg-origin"),
    fc(e, z || u, !!z || n.originIsAbsolute, n.smooth !== !1, P)),
    T = n.xOrigin || 0,
    L = n.yOrigin || 0,
    P !== Qo && (G = P[0],
    q = P[1],
    g = P[2],
    w = P[3],
    c = E = P[4],
    h = R = P[5],
    P.length === 6 ? (m = Math.sqrt(G * G + q * q),
    _ = Math.sqrt(w * w + g * g),
    d = G || q ? us(q, G) * Tr : 0,
    x = g || w ? us(g, w) * Tr + d : 0,
    x && (_ *= Math.abs(Math.cos(x * Us))),
    n.svg && (c -= T - (T * G + L * g),
    h -= L - (T * q + L * w))) : (W = P[6],
    B = P[7],
    D = P[8],
    I = P[9],
    F = P[10],
    H = P[11],
    c = P[12],
    h = P[13],
    f = P[14],
    A = us(W, F),
    p = A * Tr,
    A && (C = Math.cos(-A),
    N = Math.sin(-A),
    z = E * C + D * N,
    b = R * C + I * N,
    y = W * C + F * N,
    D = E * -N + D * C,
    I = R * -N + I * C,
    F = W * -N + F * C,
    H = B * -N + H * C,
    E = z,
    R = b,
    W = y),
    A = us(-g, F),
    v = A * Tr,
    A && (C = Math.cos(-A),
    N = Math.sin(-A),
    z = G * C - D * N,
    b = q * C - I * N,
    y = g * C - F * N,
    H = w * N + H * C,
    G = z,
    q = b,
    g = y),
    A = us(q, G),
    d = A * Tr,
    A && (C = Math.cos(A),
    N = Math.sin(A),
    z = G * C + q * N,
    b = E * C + R * N,
    q = q * C - G * N,
    R = R * C - E * N,
    G = z,
    E = b),
    p && Math.abs(p) + Math.abs(d) > 359.9 && (p = d = 0,
    v = 180 - v),
    m = wt(Math.sqrt(G * G + q * q + g * g)),
    _ = wt(Math.sqrt(R * R + W * W)),
    A = us(E, R),
    x = Math.abs(A) > 2e-4 ? A * Tr : 0,
    M = H ? 1 / (H < 0 ? -H : H) : 0),
    n.svg && (z = e.getAttribute("transform"),
    n.forceCSS = e.setAttribute("transform", "") || !wm(ui(e, vt)),
    z && e.setAttribute("transform", z))),
    Math.abs(x) > 90 && Math.abs(x) < 270 && (r ? (m *= -1,
    x += d <= 0 ? 180 : -180,
    d += d <= 0 ? 180 : -180) : (_ *= -1,
    x += x <= 0 ? 180 : -180)),
    t = t || n.uncache,
    n.x = c - ((n.xPercent = c && (!t && n.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-c) ? -50 : 0))) ? e.offsetWidth * n.xPercent / 100 : 0) + s,
    n.y = h - ((n.yPercent = h && (!t && n.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-h) ? -50 : 0))) ? e.offsetHeight * n.yPercent / 100 : 0) + s,
    n.z = f + s,
    n.scaleX = wt(m),
    n.scaleY = wt(_),
    n.rotation = wt(d) + a,
    n.rotationX = wt(p) + a,
    n.rotationY = wt(v) + a,
    n.skewX = x + a,
    n.skewY = S + a,
    n.transformPerspective = M + s,
    (n.zOrigin = parseFloat(u.split(" ")[2]) || 0) && (i[ei] = Ll(u)),
    n.xOffset = n.yOffset = 0,
    n.force3D = Sn.force3D,
    n.renderTransform = n.svg ? L0 : vm ? Mm : C0,
    n.uncache = 0,
    n
}, Ll = function(e) {
    return (e = e.split(" "))[0] + " " + e[1]
}, ou = function(e, t, n) {
    var i = jt(t);
    return wt(parseFloat(t) + parseFloat(fr(e, "x", n + "px", i))) + i
}, C0 = function(e, t) {
    t.z = "0px",
    t.rotationY = t.rotationX = "0deg",
    t.force3D = 0,
    Mm(e, t)
}, yr = "0deg", mo = "0px", br = ") ", Mm = function(e, t) {
    var n = t || this
      , i = n.xPercent
      , r = n.yPercent
      , s = n.x
      , a = n.y
      , l = n.z
      , u = n.rotation
      , c = n.rotationY
      , h = n.rotationX
      , f = n.skewX
      , m = n.skewY
      , _ = n.scaleX
      , d = n.scaleY
      , p = n.transformPerspective
      , v = n.force3D
      , x = n.target
      , S = n.zOrigin
      , M = ""
      , T = v === "auto" && e && e !== 1 || v === !0;
    if (S && (h !== yr || c !== yr)) {
        var L = parseFloat(c) * Us, P = Math.sin(L), A = Math.cos(L), C;
        L = parseFloat(h) * Us,
        C = Math.cos(L),
        s = ou(x, s, P * C * -S),
        a = ou(x, a, -Math.sin(L) * -S),
        l = ou(x, l, A * C * -S + S)
    }
    p !== mo && (M += "perspective(" + p + br),
    (i || r) && (M += "translate(" + i + "%, " + r + "%) "),
    (T || s !== mo || a !== mo || l !== mo) && (M += l !== mo || T ? "translate3d(" + s + ", " + a + ", " + l + ") " : "translate(" + s + ", " + a + br),
    u !== yr && (M += "rotate(" + u + br),
    c !== yr && (M += "rotateY(" + c + br),
    h !== yr && (M += "rotateX(" + h + br),
    (f !== yr || m !== yr) && (M += "skew(" + f + ", " + m + br),
    (_ !== 1 || d !== 1) && (M += "scale(" + _ + ", " + d + br),
    x.style[vt] = M || "translate(0, 0)"
}, L0 = function(e, t) {
    var n = t || this, i = n.xPercent, r = n.yPercent, s = n.x, a = n.y, l = n.rotation, u = n.skewX, c = n.skewY, h = n.scaleX, f = n.scaleY, m = n.target, _ = n.xOrigin, d = n.yOrigin, p = n.xOffset, v = n.yOffset, x = n.forceCSS, S = parseFloat(s), M = parseFloat(a), T, L, P, A, C;
    l = parseFloat(l),
    u = parseFloat(u),
    c = parseFloat(c),
    c && (c = parseFloat(c),
    u += c,
    l += c),
    l || u ? (l *= Us,
    u *= Us,
    T = Math.cos(l) * h,
    L = Math.sin(l) * h,
    P = Math.sin(l - u) * -f,
    A = Math.cos(l - u) * f,
    u && (c *= Us,
    C = Math.tan(u - c),
    C = Math.sqrt(1 + C * C),
    P *= C,
    A *= C,
    c && (C = Math.tan(c),
    C = Math.sqrt(1 + C * C),
    T *= C,
    L *= C)),
    T = wt(T),
    L = wt(L),
    P = wt(P),
    A = wt(A)) : (T = h,
    A = f,
    L = P = 0),
    (S && !~(s + "").indexOf("px") || M && !~(a + "").indexOf("px")) && (S = fr(m, "x", s, "px"),
    M = fr(m, "y", a, "px")),
    (_ || d || p || v) && (S = wt(S + _ - (_ * T + d * P) + p),
    M = wt(M + d - (_ * L + d * A) + v)),
    (i || r) && (C = m.getBBox(),
    S = wt(S + i / 100 * C.width),
    M = wt(M + r / 100 * C.height)),
    C = "matrix(" + T + "," + L + "," + P + "," + A + "," + S + "," + M + ")",
    m.setAttribute("transform", C),
    x && (m.style[vt] = C)
}, R0 = function(e, t, n, i, r) {
    var s = 360, a = kt(r), l = parseFloat(r) * (a && ~r.indexOf("rad") ? Tr : 1), u = l - i, c = i + u + "deg", h, f;
    return a && (h = r.split("_")[1],
    h === "short" && (u %= s,
    u !== u % (s / 2) && (u += u < 0 ? s : -s)),
    h === "cw" && u < 0 ? u = (u + s * kh) % s - ~~(u / s) * s : h === "ccw" && u > 0 && (u = (u - s * kh) % s - ~~(u / s) * s)),
    e._pt = f = new mn(e._pt,t,n,i,u,p0),
    f.e = c,
    f.u = "deg",
    e._props.push(n),
    f
}, Hh = function(e, t) {
    for (var n in t)
        e[n] = t[n];
    return e
}, P0 = function(e, t, n) {
    var i = Hh({}, n._gsap), r = "perspective,force3D,transformOrigin,svgOrigin", s = n.style, a, l, u, c, h, f, m, _;
    i.svg ? (u = n.getAttribute("transform"),
    n.setAttribute("transform", ""),
    s[vt] = t,
    a = Jo(n, 1),
    Zo(n, vt),
    n.setAttribute("transform", u)) : (u = getComputedStyle(n)[vt],
    s[vt] = t,
    a = Jo(n, 1),
    s[vt] = u);
    for (l in Hi)
        u = i[l],
        c = a[l],
        u !== c && r.indexOf(l) < 0 && (m = jt(u),
        _ = jt(c),
        h = m !== _ ? fr(n, l, u, _) : parseFloat(u),
        f = parseFloat(c),
        e._pt = new mn(e._pt,a,l,h,f - h,uc),
        e._pt.u = _ || 0,
        e._props.push(l));
    Hh(a, i)
};
pn("padding,margin,Width,Radius", function(o, e) {
    var t = "Top"
      , n = "Right"
      , i = "Bottom"
      , r = "Left"
      , s = (e < 3 ? [t, n, i, r] : [t + r, t + n, i + n, i + r]).map(function(a) {
        return e < 2 ? o + a : "border" + a + o
    });
    Cl[e > 1 ? "border" + o : o] = function(a, l, u, c, h) {
        var f, m;
        if (arguments.length < 4)
            return f = s.map(function(_) {
                return Ti(a, _, u)
            }),
            m = f.join(" "),
            m.split(f[0]).length === 5 ? f[0] : m;
        f = (c + "").split(" "),
        m = {},
        s.forEach(function(_, d) {
            return m[_] = f[d] = f[d] || f[(d - 1) / 2 | 0]
        }),
        a.init(l, m, h)
    }
});
var Sm = {
    name: "css",
    register: hc,
    targetTest: function(e) {
        return e.style && e.nodeType
    },
    init: function(e, t, n, i, r) {
        var s = this._props, a = e.style, l = n.vars.startAt, u, c, h, f, m, _, d, p, v, x, S, M, T, L, P, A;
        Zc || hc(),
        this.styles = this.styles || _m(e),
        A = this.styles.props,
        this.tween = n;
        for (d in t)
            if (d !== "autoRound" && (c = t[d],
            !(bn[d] && om(d, t, n, i, e, r)))) {
                if (m = typeof c,
                _ = Cl[d],
                m === "function" && (c = c.call(n, i, e, r),
                m = typeof c),
                m === "string" && ~c.indexOf("random(") && (c = Ko(c)),
                _)
                    _(this, e, d, c, n) && (P = 1);
                else if (d.substr(0, 2) === "--")
                    u = (getComputedStyle(e).getPropertyValue(d) + "").trim(),
                    c += "",
                    lr.lastIndex = 0,
                    lr.test(u) || (p = jt(u),
                    v = jt(c)),
                    v ? p !== v && (u = fr(e, d, u, v) + v) : p && (c += p),
                    this.add(a, "setProperty", u, c, i, r, 0, 0, d),
                    s.push(d),
                    A.push(d, a[d]);
                else if (m !== "undefined") {
                    if (l && d in l ? (u = typeof l[d] == "function" ? l[d].call(n, i, e, r) : l[d],
                    kt(u) && ~u.indexOf("random(") && (u = Ko(u)),
                    jt(u + "") || (u += Sn.units[d] || jt(Ti(e, d)) || ""),
                    (u + "").charAt(1) === "=" && (u = Ti(e, d))) : u = Ti(e, d),
                    f = parseFloat(u),
                    x = m === "string" && c.charAt(1) === "=" && c.substr(0, 2),
                    x && (c = c.substr(2)),
                    h = parseFloat(c),
                    d in Ri && (d === "autoAlpha" && (f === 1 && Ti(e, "visibility") === "hidden" && h && (f = 0),
                    A.push("visibility", a.visibility),
                    sr(this, a, "visibility", f ? "inherit" : "hidden", h ? "inherit" : "hidden", !h)),
                    d !== "scale" && d !== "transform" && (d = Ri[d],
                    ~d.indexOf(",") && (d = d.split(",")[0]))),
                    S = d in Hi,
                    S) {
                        if (this.styles.save(d),
                        M || (T = e._gsap,
                        T.renderTransform && !t.parseTransform || Jo(e, t.parseTransform),
                        L = t.smoothOrigin !== !1 && T.smooth,
                        M = this._pt = new mn(this._pt,a,vt,0,1,T.renderTransform,T,0,-1),
                        M.dep = 1),
                        d === "scale")
                            this._pt = new mn(this._pt,T,"scaleY",T.scaleY,(x ? ks(T.scaleY, x + h) : h) - T.scaleY || 0,uc),
                            this._pt.u = 0,
                            s.push("scaleY", d),
                            d += "X";
                        else if (d === "transformOrigin") {
                            A.push(ei, a[ei]),
                            c = E0(c),
                            T.svg ? fc(e, c, 0, L, 0, this) : (v = parseFloat(c.split(" ")[2]) || 0,
                            v !== T.zOrigin && sr(this, T, "zOrigin", T.zOrigin, v),
                            sr(this, a, d, Ll(u), Ll(c)));
                            continue
                        } else if (d === "svgOrigin") {
                            fc(e, c, 1, L, 0, this);
                            continue
                        } else if (d in bm) {
                            R0(this, T, d, f, x ? ks(f, x + c) : c);
                            continue
                        } else if (d === "smoothOrigin") {
                            sr(this, T, "smooth", T.smooth, c);
                            continue
                        } else if (d === "force3D") {
                            T[d] = c;
                            continue
                        } else if (d === "transform") {
                            P0(this, c, e);
                            continue
                        }
                    } else
                        d in a || (d = $s(d) || d);
                    if (S || (h || h === 0) && (f || f === 0) && !d0.test(c) && d in a)
                        p = (u + "").substr((f + "").length),
                        h || (h = 0),
                        v = jt(c) || (d in Sn.units ? Sn.units[d] : p),
                        p !== v && (f = fr(e, d, u, v)),
                        this._pt = new mn(this._pt,S ? T : a,d,f,(x ? ks(f, x + h) : h) - f,!S && (v === "px" || d === "zIndex") && t.autoRound !== !1 ? g0 : uc),
                        this._pt.u = v || 0,
                        p !== v && v !== "%" && (this._pt.b = u,
                        this._pt.r = m0);
                    else if (d in a)
                        T0.call(this, e, d, u, x ? x + c : c);
                    else if (d in e)
                        this.add(e, d, u || e[d], x ? x + c : c, i, r);
                    else {
                        Gc(d, c);
                        continue
                    }
                    S || A.push(d, a[d]),
                    s.push(d)
                }
            }
        P && fm(this)
    },
    render: function(e, t) {
        if (t.tween._time || !Qc())
            for (var n = t._pt; n; )
                n.r(e, n.d),
                n = n._next;
        else
            t.styles.revert()
    },
    get: Ti,
    aliases: Ri,
    getSetter: function(e, t, n) {
        var i = Ri[t];
        return i && i.indexOf(",") < 0 && (t = i),
        t in Hi && t !== ei && (e._gsap.x || Ti(e, "x")) ? n && Nh === n ? t === "scale" ? y0 : x0 : (Nh = n || {}) && (t === "scale" ? b0 : w0) : e.style && !Bc(e.style[t]) ? _0 : ~t.indexOf("-") ? v0 : Kc(e, t)
    },
    core: {
        _removeProperty: Zo,
        _getMatrix: eh
    }
};
Tn.utils.checkPrefix = $s;
Tn.core.getStyleSaver = _m;
(function(o, e, t, n) {
    var i = pn(o + "," + e + "," + t, function(r) {
        Hi[r] = 1
    });
    pn(e, function(r) {
        Sn.units[r] = "deg",
        bm[r] = 1
    }),
    Ri[i[13]] = o + "," + e,
    pn(n, function(r) {
        var s = r.split(":");
        Ri[s[1]] = i[s[0]]
    })
}
)("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
pn("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(o) {
    Sn.units[o] = "px"
});
Tn.registerPlugin(Sm);
var I0 = Tn.registerPlugin(Sm) || Tn;
I0.core.Tween;
/*!
 * paths 3.11.1
 * https://greensock.com
 *
 * Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var F0 = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig
  , O0 = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/ig
  , N0 = Math.PI / 180
  , xa = Math.sin
  , ya = Math.cos
  , ko = Math.abs
  , go = Math.sqrt
  , k0 = function(e) {
    return typeof e == "number"
}
  , Wh = 1e5
  , qi = function(e) {
    return Math.round(e * Wh) / Wh || 0
};
function z0(o, e, t, n, i, r, s) {
    for (var a = o.length, l, u, c, h, f; --a > -1; )
        for (l = o[a],
        u = l.length,
        c = 0; c < u; c += 2)
            h = l[c],
            f = l[c + 1],
            l[c] = h * e + f * n + r,
            l[c + 1] = h * t + f * i + s;
    return o._dirty = 1,
    o
}
function U0(o, e, t, n, i, r, s, a, l) {
    if (!(o === a && e === l)) {
        t = ko(t),
        n = ko(n);
        var u = i % 360 * N0
          , c = ya(u)
          , h = xa(u)
          , f = Math.PI
          , m = f * 2
          , _ = (o - a) / 2
          , d = (e - l) / 2
          , p = c * _ + h * d
          , v = -h * _ + c * d
          , x = p * p
          , S = v * v
          , M = x / (t * t) + S / (n * n);
        M > 1 && (t = go(M) * t,
        n = go(M) * n);
        var T = t * t
          , L = n * n
          , P = (T * L - T * S - L * x) / (T * S + L * x);
        P < 0 && (P = 0);
        var A = (r === s ? -1 : 1) * go(P)
          , C = A * (t * v / n)
          , N = A * -(n * p / t)
          , G = (o + a) / 2
          , q = (e + l) / 2
          , g = G + (c * C - h * N)
          , w = q + (h * C + c * N)
          , E = (p - C) / t
          , R = (v - N) / n
          , z = (-p - C) / t
          , b = (-v - N) / n
          , y = E * E + R * R
          , D = (R < 0 ? -1 : 1) * Math.acos(E / go(y))
          , I = (E * b - R * z < 0 ? -1 : 1) * Math.acos((E * z + R * b) / go(y * (z * z + b * b)));
        isNaN(I) && (I = f),
        !s && I > 0 ? I -= m : s && I < 0 && (I += m),
        D %= m,
        I %= m;
        var F = Math.ceil(ko(I) / (m / 4)), B = [], H = I / F, W = 4 / 3 * xa(H / 2) / (1 + ya(H / 2)), U = c * t, K = h * t, te = h * -n, he = c * n, ne;
        for (ne = 0; ne < F; ne++)
            i = D + ne * H,
            p = ya(i),
            v = xa(i),
            E = ya(i += H),
            R = xa(i),
            B.push(p - W * v, v + W * p, E + W * R, R - W * E, E, R);
        for (ne = 0; ne < B.length; ne += 2)
            p = B[ne],
            v = B[ne + 1],
            B[ne] = p * U + v * te + g,
            B[ne + 1] = p * K + v * he + w;
        return B[ne - 2] = a,
        B[ne - 1] = l,
        B
    }
}
function B0(o) {
    var e = (o + "").replace(O0, function(C) {
        var N = +C;
        return N < 1e-4 && N > -1e-4 ? 0 : N
    }).match(F0) || [], t = [], n = 0, i = 0, r = 2 / 3, s = e.length, a = 0, l = "ERROR: malformed path: " + o, u, c, h, f, m, _, d, p, v, x, S, M, T, L, P, A = function(N, G, q, g) {
        x = (q - N) / 3,
        S = (g - G) / 3,
        d.push(N + x, G + S, q - x, g - S, q, g)
    };
    if (!o || !isNaN(e[0]) || isNaN(e[1]))
        return console.log(l),
        t;
    for (u = 0; u < s; u++)
        if (T = m,
        isNaN(e[u]) ? (m = e[u].toUpperCase(),
        _ = m !== e[u]) : u--,
        h = +e[u + 1],
        f = +e[u + 2],
        _ && (h += n,
        f += i),
        u || (p = h,
        v = f),
        m === "M")
            d && (d.length < 8 ? t.length -= 1 : a += d.length),
            n = p = h,
            i = v = f,
            d = [h, f],
            t.push(d),
            u += 2,
            m = "L";
        else if (m === "C")
            d || (d = [0, 0]),
            _ || (n = i = 0),
            d.push(h, f, n + e[u + 3] * 1, i + e[u + 4] * 1, n += e[u + 5] * 1, i += e[u + 6] * 1),
            u += 6;
        else if (m === "S")
            x = n,
            S = i,
            (T === "C" || T === "S") && (x += n - d[d.length - 4],
            S += i - d[d.length - 3]),
            _ || (n = i = 0),
            d.push(x, S, h, f, n += e[u + 3] * 1, i += e[u + 4] * 1),
            u += 4;
        else if (m === "Q")
            x = n + (h - n) * r,
            S = i + (f - i) * r,
            _ || (n = i = 0),
            n += e[u + 3] * 1,
            i += e[u + 4] * 1,
            d.push(x, S, n + (h - n) * r, i + (f - i) * r, n, i),
            u += 4;
        else if (m === "T")
            x = n - d[d.length - 4],
            S = i - d[d.length - 3],
            d.push(n + x, i + S, h + (n + x * 1.5 - h) * r, f + (i + S * 1.5 - f) * r, n = h, i = f),
            u += 2;
        else if (m === "H")
            A(n, i, n = h, i),
            u += 1;
        else if (m === "V")
            A(n, i, n, i = h + (_ ? i - n : 0)),
            u += 1;
        else if (m === "L" || m === "Z")
            m === "Z" && (h = p,
            f = v,
            d.closed = !0),
            (m === "L" || ko(n - h) > .5 || ko(i - f) > .5) && (A(n, i, h, f),
            m === "L" && (u += 2)),
            n = h,
            i = f;
        else if (m === "A") {
            if (L = e[u + 4],
            P = e[u + 5],
            x = e[u + 6],
            S = e[u + 7],
            c = 7,
            L.length > 1 && (L.length < 3 ? (S = x,
            x = P,
            c--) : (S = P,
            x = L.substr(2),
            c -= 2),
            P = L.charAt(1),
            L = L.charAt(0)),
            M = U0(n, i, +e[u + 1], +e[u + 2], +e[u + 3], +L, +P, (_ ? n : 0) + x * 1, (_ ? i : 0) + S * 1),
            u += c,
            M)
                for (c = 0; c < M.length; c++)
                    d.push(M[c]);
            n = d[d.length - 2],
            i = d[d.length - 1]
        } else
            console.log(l);
    return u = d.length,
    u < 6 ? (t.pop(),
    u = 0) : d[0] === d[u - 2] && d[1] === d[u - 1] && (d.closed = !0),
    t.totalPoints = a + u,
    t
}
function V0(o) {
    k0(o[0]) && (o = [o]);
    var e = "", t = o.length, n, i, r, s;
    for (i = 0; i < t; i++) {
        for (s = o[i],
        e += "M" + qi(s[0]) + "," + qi(s[1]) + " C",
        n = s.length,
        r = 2; r < n; r++)
            e += qi(s[r++]) + "," + qi(s[r++]) + " " + qi(s[r++]) + "," + qi(s[r++]) + " " + qi(s[r++]) + "," + qi(s[r]) + " ";
        s.closed && (e += "z")
    }
    return e
}
/*!
 * CustomEase 3.11.1
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var ln, Dm, Tm = function() {
    return ln || typeof window < "u" && (ln = window.gsap) && ln.registerPlugin && ln
}, jh = function() {
    ln = Tm(),
    ln ? (ln.registerEase("_CE", th.create),
    Dm = 1) : console.warn("Please gsap.registerPlugin(CustomEase)")
}, G0 = 1e20, ba = function(e) {
    return ~~(e * 1e3 + (e < 0 ? -.5 : .5)) / 1e3
}, H0 = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi, W0 = /[cLlsSaAhHvVtTqQ]/g, j0 = function(e) {
    var t = e.length, n = G0, i;
    for (i = 1; i < t; i += 6)
        +e[i] < n && (n = +e[i]);
    return n
}, q0 = function(e, t, n) {
    !n && n !== 0 && (n = Math.max(+e[e.length - 1], +e[1]));
    var i = +e[0] * -1, r = -n, s = e.length, a = 1 / (+e[s - 2] + i), l = -t || (Math.abs(+e[s - 1] - +e[1]) < .01 * (+e[s - 2] - +e[0]) ? j0(e) + r : +e[s - 1] + r), u;
    for (l ? l = 1 / l : l = -a,
    u = 0; u < s; u += 2)
        e[u] = (+e[u] + i) * a,
        e[u + 1] = (+e[u + 1] + r) * l
}, X0 = function o(e, t, n, i, r, s, a, l, u, c, h) {
    var f = (e + n) / 2, m = (t + i) / 2, _ = (n + r) / 2, d = (i + s) / 2, p = (r + a) / 2, v = (s + l) / 2, x = (f + _) / 2, S = (m + d) / 2, M = (_ + p) / 2, T = (d + v) / 2, L = (x + M) / 2, P = (S + T) / 2, A = a - e, C = l - t, N = Math.abs((n - a) * C - (i - l) * A), G = Math.abs((r - a) * C - (s - l) * A), q;
    return c || (c = [{
        x: e,
        y: t
    }, {
        x: a,
        y: l
    }],
    h = 1),
    c.splice(h || c.length - 1, 0, {
        x: L,
        y: P
    }),
    (N + G) * (N + G) > u * (A * A + C * C) && (q = c.length,
    o(e, t, f, m, x, S, L, P, u, c, h),
    o(L, P, M, T, p, v, a, l, u, c, h + 1 + (c.length - q))),
    c
}, th = function() {
    function o(t, n, i) {
        Dm || jh(),
        this.id = t,
        this.setData(n, i)
    }
    var e = o.prototype;
    return e.setData = function(n, i) {
        i = i || {},
        n = n || "0,0,1,1";
        var r = n.match(H0), s = 1, a = [], l = [], u = i.precision || 1, c = u <= 1, h, f, m, _, d, p, v, x, S;
        if (this.data = n,
        (W0.test(n) || ~n.indexOf("M") && n.indexOf("C") < 0) && (r = B0(n)[0]),
        h = r.length,
        h === 4)
            r.unshift(0, 0),
            r.push(1, 1),
            h = 8;
        else if ((h - 2) % 6)
            throw "Invalid CustomEase";
        for ((+r[0] != 0 || +r[h - 2] != 1) && q0(r, i.height, i.originY),
        this.segment = r,
        _ = 2; _ < h; _ += 6)
            f = {
                x: +r[_ - 2],
                y: +r[_ - 1]
            },
            m = {
                x: +r[_ + 4],
                y: +r[_ + 5]
            },
            a.push(f, m),
            X0(f.x, f.y, +r[_], +r[_ + 1], +r[_ + 2], +r[_ + 3], m.x, m.y, 1 / (u * 2e5), a, a.length - 1);
        for (h = a.length,
        _ = 0; _ < h; _++)
            v = a[_],
            x = a[_ - 1] || v,
            (v.x > x.x || x.y !== v.y && x.x === v.x || v === x) && v.x <= 1 ? (x.cx = v.x - x.x,
            x.cy = v.y - x.y,
            x.n = v,
            x.nx = v.x,
            c && _ > 1 && Math.abs(x.cy / x.cx - a[_ - 2].cy / a[_ - 2].cx) > 2 && (c = 0),
            x.cx < s && (x.cx ? s = x.cx : (x.cx = .001,
            _ === h - 1 && (x.x -= .001,
            s = Math.min(s, .001),
            c = 0)))) : (a.splice(_--, 1),
            h--);
        if (h = 1 / s + 1 | 0,
        d = 1 / h,
        p = 0,
        v = a[0],
        c) {
            for (_ = 0; _ < h; _++)
                S = _ * d,
                v.nx < S && (v = a[++p]),
                f = v.y + (S - v.x) / v.cx * v.cy,
                l[_] = {
                    x: S,
                    cx: d,
                    y: f,
                    cy: 0,
                    nx: 9
                },
                _ && (l[_ - 1].cy = f - l[_ - 1].y);
            l[h - 1].cy = a[a.length - 1].y - f
        } else {
            for (_ = 0; _ < h; _++)
                v.nx < _ * d && (v = a[++p]),
                l[_] = v;
            p < a.length - 1 && (l[_ - 1] = a[a.length - 2])
        }
        return this.ease = function(M) {
            var T = l[M * h | 0] || l[h - 1];
            return T.nx < M && (T = T.n),
            T.y + (M - T.x) / T.cx * T.cy
        }
        ,
        this.ease.custom = this,
        this.id && ln && ln.registerEase(this.id, this.ease),
        this
    }
    ,
    e.getSVGData = function(n) {
        return o.getSVGData(this, n)
    }
    ,
    o.create = function(n, i, r) {
        return new o(n,i,r).ease
    }
    ,
    o.register = function(n) {
        ln = n,
        jh()
    }
    ,
    o.get = function(n) {
        return ln.parseEase(n)
    }
    ,
    o.getSVGData = function(n, i) {
        i = i || {};
        var r = i.width || 100, s = i.height || 100, a = i.x || 0, l = (i.y || 0) + s, u = ln.utils.toArray(i.path)[0], c, h, f, m, _, d, p, v, x, S;
        if (i.invert && (s = -s,
        l = 0),
        typeof n == "string" && (n = ln.parseEase(n)),
        n.custom && (n = n.custom),
        n instanceof o)
            c = V0(z0([n.segment], r, 0, 0, -s, a, l));
        else {
            for (c = [a, l],
            p = Math.max(5, (i.precision || 1) * 200),
            m = 1 / p,
            p += 2,
            v = 5 / p,
            x = ba(a + m * r),
            S = ba(l + n(m) * -s),
            h = (S - l) / (x - a),
            f = 2; f < p; f++)
                _ = ba(a + f * m * r),
                d = ba(l + n(f * m) * -s),
                (Math.abs((d - S) / (_ - x) - h) > v || f === p - 1) && (c.push(x, S),
                h = (d - S) / (_ - x)),
                x = _,
                S = d;
            c = "M" + c.join(",")
        }
        return u && u.setAttribute("d", c),
        c
    }
    ,
    o
}();
Tm() && ln.registerPlugin(th);
th.version = "3.11.1";
function qh(o, e) {
    for (var t = 0; t < e.length; t++) {
        var n = e[t];
        n.enumerable = n.enumerable || !1,
        n.configurable = !0,
        "value"in n && (n.writable = !0),
        Object.defineProperty(o, n.key, n)
    }
}
function Y0(o, e, t) {
    return e && qh(o.prototype, e),
    t && qh(o, t),
    o
}
/*!
 * Observer 3.11.1
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var en, dc, Mn, Fr, Or, Bs, Em, Er, zo, Am, Pi, Zn, Cm = function() {
    return en || typeof window < "u" && (en = window.gsap) && en.registerPlugin && en
}, Lm = 1, Is = [], et = [], ci = [], Uo = Date.now, pc = function(e, t) {
    return t
}, K0 = function() {
    var e = zo.core
      , t = e.bridge || {}
      , n = e._scrollers
      , i = e._proxies;
    n.push.apply(n, et),
    i.push.apply(i, ci),
    et = n,
    ci = i,
    pc = function(s, a) {
        return t[s](a)
    }
}, ur = function(e, t) {
    return ~ci.indexOf(e) && ci[ci.indexOf(e) + 1][t]
}, cl = function(e) {
    return !!~Am.indexOf(e)
}, on = function(e, t, n, i, r) {
    return e.addEventListener(t, n, {
        passive: !i,
        capture: !!r
    })
}, Yt = function(e, t, n, i) {
    return e.removeEventListener(t, n, !!i)
}, wa = "scrollLeft", Ma = "scrollTop", Xh = function() {
    return Pi && Pi.isPressed || et.cache++
}, Rl = function(e, t) {
    var n = function i(r) {
        if (r || r === 0) {
            Lm && (Mn.history.scrollRestoration = "manual");
            var s = Pi && Pi.isPressed;
            r = i.v = Math.round(r) || (Pi && Pi.iOS ? 1 : 0),
            e(r),
            i.cacheID = et.cache,
            s && pc("ss", r)
        } else
            (t || et.cache !== i.cacheID || pc("ref")) && (i.cacheID = et.cache,
            i.v = e());
        return i.v + i.offset
    };
    return n.offset = 0,
    e && n
}, Jt = {
    s: wa,
    p: "left",
    p2: "Left",
    os: "right",
    os2: "Right",
    d: "width",
    d2: "Width",
    a: "x",
    sc: Rl(function(o) {
        return arguments.length ? Mn.scrollTo(o, Pt.sc()) : Mn.pageXOffset || Fr[wa] || Or[wa] || Bs[wa] || 0
    })
}, Pt = {
    s: Ma,
    p: "top",
    p2: "Top",
    os: "bottom",
    os2: "Bottom",
    d: "height",
    d2: "Height",
    a: "y",
    op: Jt,
    sc: Rl(function(o) {
        return arguments.length ? Mn.scrollTo(Jt.sc(), o) : Mn.pageYOffset || Fr[Ma] || Or[Ma] || Bs[Ma] || 0
    })
}, an = function(e) {
    return en.utils.toArray(e)[0] || (typeof e == "string" && en.config().nullTargetWarn !== !1 ? console.warn("Element not found:", e) : null)
}, dr = function(e, t) {
    var n = t.s
      , i = t.sc
      , r = et.indexOf(e)
      , s = i === Pt.sc ? 1 : 2;
    return !~r && (r = et.push(e) - 1),
    et[r + s] || (et[r + s] = Rl(ur(e, n), !0) || (cl(e) ? i : Rl(function(a) {
        return arguments.length ? e[n] = a : e[n]
    })))
}, mc = function(e, t, n) {
    var i = e
      , r = e
      , s = Uo()
      , a = s
      , l = t || 50
      , u = Math.max(500, l * 3)
      , c = function(_, d) {
        var p = Uo();
        d || p - s > l ? (r = i,
        i = _,
        a = s,
        s = p) : n ? i += _ : i = r + (_ - r) / (p - a) * (s - a)
    }
      , h = function() {
        r = i = n ? 0 : i,
        a = s = 0
    }
      , f = function(_) {
        var d = a
          , p = r
          , v = Uo();
        return (_ || _ === 0) && _ !== i && c(_),
        s === a || v - a > u ? 0 : (i + (n ? p : -p)) / ((n ? v : s) - d) * 1e3
    };
    return {
        update: c,
        reset: h,
        getVelocity: f
    }
}, _o = function(e, t) {
    return t && !e._gsapAllow && e.preventDefault(),
    e.changedTouches ? e.changedTouches[0] : e
}, Yh = function(e) {
    var t = Math.max.apply(Math, e)
      , n = Math.min.apply(Math, e);
    return Math.abs(t) >= Math.abs(n) ? t : n
}, Rm = function() {
    zo = en.core.globals().ScrollTrigger,
    zo && zo.core && K0()
}, Pm = function(e) {
    return en = e || Cm(),
    en && typeof document < "u" && document.body && (Mn = window,
    Fr = document,
    Or = Fr.documentElement,
    Bs = Fr.body,
    Am = [Mn, Fr, Or, Bs],
    en.utils.clamp,
    Er = "onpointerenter"in Bs ? "pointer" : "mouse",
    Em = At.isTouch = Mn.matchMedia && Mn.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart"in Mn || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0,
    Zn = At.eventTypes = ("ontouchstart"in Or ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown"in Or ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","),
    setTimeout(function() {
        return Lm = 0
    }, 500),
    Rm(),
    dc = 1),
    dc
};
Jt.op = Pt;
et.cache = 0;
var At = function() {
    function o(t) {
        this.init(t)
    }
    var e = o.prototype;
    return e.init = function(n) {
        dc || Pm(en) || console.warn("Please gsap.registerPlugin(Observer)"),
        zo || Rm();
        var i = n.tolerance
          , r = n.dragMinimum
          , s = n.type
          , a = n.target
          , l = n.lineHeight
          , u = n.debounce
          , c = n.preventDefault
          , h = n.onStop
          , f = n.onStopDelay
          , m = n.ignore
          , _ = n.wheelSpeed
          , d = n.event
          , p = n.onDragStart
          , v = n.onDragEnd
          , x = n.onDrag
          , S = n.onPress
          , M = n.onRelease
          , T = n.onRight
          , L = n.onLeft
          , P = n.onUp
          , A = n.onDown
          , C = n.onChangeX
          , N = n.onChangeY
          , G = n.onChange
          , q = n.onToggleX
          , g = n.onToggleY
          , w = n.onHover
          , E = n.onHoverEnd
          , R = n.onMove
          , z = n.ignoreCheck
          , b = n.isNormalizer
          , y = n.onGestureStart
          , D = n.onGestureEnd
          , I = n.onWheel
          , F = n.onEnable
          , B = n.onDisable
          , H = n.onClick
          , W = n.scrollSpeed
          , U = n.capture
          , K = n.allowClicks
          , te = n.lockAxis
          , he = n.onLockAxis;
        this.target = a = an(a) || Or,
        this.vars = n,
        m && (m = en.utils.toArray(m)),
        i = i || 1e-9,
        r = r || 0,
        _ = _ || 1,
        W = W || 1,
        s = s || "wheel,touch,pointer",
        u = u !== !1,
        l || (l = parseFloat(Mn.getComputedStyle(Bs).lineHeight) || 22);
        var ne, ce, oe, ue, Oe, qe, Ue, J = this, Ve = 0, ye = 0, Ft = dr(a, Jt), Ct = dr(a, Pt), V = Ft(), O = Ct(), re = ~s.indexOf("touch") && !~s.indexOf("pointer") && Zn[0] === "pointerdown", le = cl(a), ae = a.ownerDocument || Fr, fe = [0, 0, 0], Se = [0, 0, 0], ee = 0, we = function() {
            return ee = Uo()
        }, ve = function(se, Ee) {
            return (J.event = se) && m && ~m.indexOf(se.target) || Ee && re && se.pointerType !== "touch" || z && z(se, Ee)
        }, De = function() {
            J._vx.reset(),
            J._vy.reset(),
            ce.pause(),
            h && h(J)
        }, xe = function() {
            var se = J.deltaX = Yh(fe)
              , Ee = J.deltaY = Yh(Se)
              , Me = Math.abs(se) >= i
              , Ie = Math.abs(Ee) >= i;
            G && (Me || Ie) && G(J, se, Ee, fe, Se),
            Me && (T && J.deltaX > 0 && T(J),
            L && J.deltaX < 0 && L(J),
            C && C(J),
            q && J.deltaX < 0 != Ve < 0 && q(J),
            Ve = J.deltaX,
            fe[0] = fe[1] = fe[2] = 0),
            Ie && (A && J.deltaY > 0 && A(J),
            P && J.deltaY < 0 && P(J),
            N && N(J),
            g && J.deltaY < 0 != ye < 0 && g(J),
            ye = J.deltaY,
            Se[0] = Se[1] = Se[2] = 0),
            (ue || oe) && (R && R(J),
            oe && (x(J),
            oe = !1),
            ue = !1),
            qe && !(qe = !1) && he && he(J),
            Oe && (I(J),
            Oe = !1),
            ne = 0
        }, Fe = function(se, Ee, Me) {
            fe[Me] += se,
            Se[Me] += Ee,
            J._vx.update(se),
            J._vy.update(Ee),
            u ? ne || (ne = requestAnimationFrame(xe)) : xe()
        }, Ge = function(se, Ee) {
            te && !Ue && (J.axis = Ue = Math.abs(se) > Math.abs(Ee) ? "x" : "y",
            qe = !0),
            Ue !== "y" && (fe[2] += se,
            J._vx.update(se, !0)),
            Ue !== "x" && (Se[2] += Ee,
            J._vy.update(Ee, !0)),
            u ? ne || (ne = requestAnimationFrame(xe)) : xe()
        }, Re = function(se) {
            if (!ve(se, 1)) {
                se = _o(se, c);
                var Ee = se.clientX
                  , Me = se.clientY
                  , Ie = Ee - J.x
                  , bt = Me - J.y
                  , ke = J.isDragging;
                J.x = Ee,
                J.y = Me,
                (ke || Math.abs(J.startX - Ee) >= r || Math.abs(J.startY - Me) >= r) && (x && (oe = !0),
                ke || (J.isDragging = !0),
                Ge(Ie, bt),
                ke || p && p(J))
            }
        }, j = J.onPress = function(Ne) {
            ve(Ne, 1) || (J.axis = Ue = null,
            ce.pause(),
            J.isPressed = !0,
            Ne = _o(Ne),
            Ve = ye = 0,
            J.startX = J.x = Ne.clientX,
            J.startY = J.y = Ne.clientY,
            J._vx.reset(),
            J._vy.reset(),
            on(b ? a : ae, Zn[1], Re, c, !0),
            J.deltaX = J.deltaY = 0,
            S && S(J))
        }
        , de = function(se) {
            if (!ve(se, 1)) {
                Yt(b ? a : ae, Zn[1], Re, !0);
                var Ee = J.isDragging && (Math.abs(J.x - J.startX) > 3 || Math.abs(J.y - J.startY) > 3)
                  , Me = _o(se);
                Ee || (J._vx.reset(),
                J._vy.reset(),
                c && K && en.delayedCall(.08, function() {
                    if (Uo() - ee > 300 && !se.defaultPrevented) {
                        if (se.target.click)
                            se.target.click();
                        else if (ae.createEvent) {
                            var Ie = ae.createEvent("MouseEvents");
                            Ie.initMouseEvent("click", !0, !0, Mn, 1, Me.screenX, Me.screenY, Me.clientX, Me.clientY, !1, !1, !1, !1, 0, null),
                            se.target.dispatchEvent(Ie)
                        }
                    }
                })),
                J.isDragging = J.isGesturing = J.isPressed = !1,
                h && !b && ce.restart(!0),
                v && Ee && v(J),
                M && M(J, Ee)
            }
        }, Q = function(se) {
            return se.touches && se.touches.length > 1 && (J.isGesturing = !0) && y(se, J.isDragging)
        }, pe = function() {
            return (J.isGesturing = !1) || D(J)
        }, me = function(se) {
            if (!ve(se)) {
                var Ee = Ft()
                  , Me = Ct();
                Fe((Ee - V) * W, (Me - O) * W, 1),
                V = Ee,
                O = Me,
                h && ce.restart(!0)
            }
        }, Be = function(se) {
            if (!ve(se)) {
                se = _o(se, c),
                I && (Oe = !0);
                var Ee = (se.deltaMode === 1 ? l : se.deltaMode === 2 ? Mn.innerHeight : 1) * _;
                Fe(se.deltaX * Ee, se.deltaY * Ee, 0),
                h && !b && ce.restart(!0)
            }
        }, ht = function(se) {
            if (!ve(se)) {
                var Ee = se.clientX
                  , Me = se.clientY
                  , Ie = Ee - J.x
                  , bt = Me - J.y;
                J.x = Ee,
                J.y = Me,
                ue = !0,
                (Ie || bt) && Ge(Ie, bt)
            }
        }, Je = function(se) {
            J.event = se,
            w(J)
        }, sn = function(se) {
            J.event = se,
            E(J)
        }, st = function(se) {
            return ve(se) || _o(se, c) && H(J)
        };
        ce = J._dc = en.delayedCall(f || .25, De).pause(),
        J.deltaX = J.deltaY = 0,
        J._vx = mc(0, 50, !0),
        J._vy = mc(0, 50, !0),
        J.scrollX = Ft,
        J.scrollY = Ct,
        J.isDragging = J.isGesturing = J.isPressed = !1,
        J.enable = function(Ne) {
            return J.isEnabled || (on(le ? ae : a, "scroll", Xh),
            s.indexOf("scroll") >= 0 && on(le ? ae : a, "scroll", me, c, U),
            s.indexOf("wheel") >= 0 && on(a, "wheel", Be, c, U),
            (s.indexOf("touch") >= 0 && Em || s.indexOf("pointer") >= 0) && (on(a, Zn[0], j, c, U),
            on(ae, Zn[2], de),
            on(ae, Zn[3], de),
            K && on(a, "click", we, !1, !0),
            H && on(a, "click", st),
            y && on(ae, "gesturestart", Q),
            D && on(ae, "gestureend", pe),
            w && on(a, Er + "enter", Je),
            E && on(a, Er + "leave", sn),
            R && on(a, Er + "move", ht)),
            J.isEnabled = !0,
            Ne && Ne.type && j(Ne),
            F && F(J)),
            J
        }
        ,
        J.disable = function() {
            J.isEnabled && (Is.filter(function(Ne) {
                return Ne !== J && cl(Ne.target)
            }).length || Yt(le ? ae : a, "scroll", Xh),
            J.isPressed && (J._vx.reset(),
            J._vy.reset(),
            Yt(b ? a : ae, Zn[1], Re, !0)),
            Yt(le ? ae : a, "scroll", me, U),
            Yt(a, "wheel", Be, U),
            Yt(a, Zn[0], j, U),
            Yt(ae, Zn[2], de),
            Yt(ae, Zn[3], de),
            Yt(a, "click", we, !0),
            Yt(a, "click", st),
            Yt(ae, "gesturestart", Q),
            Yt(ae, "gestureend", pe),
            Yt(a, Er + "enter", Je),
            Yt(a, Er + "leave", sn),
            Yt(a, Er + "move", ht),
            J.isEnabled = J.isPressed = J.isDragging = !1,
            B && B(J))
        }
        ,
        J.kill = function() {
            J.disable();
            var Ne = Is.indexOf(J);
            Ne >= 0 && Is.splice(Ne, 1),
            Pi === J && (Pi = 0)
        }
        ,
        Is.push(J),
        b && cl(a) && (Pi = J),
        J.enable(d)
    }
    ,
    Y0(o, [{
        key: "velocityX",
        get: function() {
            return this._vx.getVelocity()
        }
    }, {
        key: "velocityY",
        get: function() {
            return this._vy.getVelocity()
        }
    }]),
    o
}();
At.version = "3.11.1";
At.create = function(o) {
    return new At(o)
}
;
At.register = Pm;
At.getAll = function() {
    return Is.slice()
}
;
At.getById = function(o) {
    return Is.filter(function(e) {
        return e.vars.id === o
    })[0]
}
;
Cm() && en.registerPlugin(At);
/*!
 * ScrollToPlugin 3.11.1
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var hn, Im, zi, li, cr, Fm, Om, Nm = function() {
    return typeof window < "u"
}, km = function() {
    return hn || Nm() && (hn = window.gsap) && hn.registerPlugin && hn
}, zm = function(e) {
    return typeof e == "string"
}, Kh = function(e) {
    return typeof e == "function"
}, ea = function(e, t) {
    var n = t === "x" ? "Width" : "Height"
      , i = "scroll" + n
      , r = "client" + n;
    return e === zi || e === li || e === cr ? Math.max(li[i], cr[i]) - (zi["inner" + n] || li[r] || cr[r]) : e[i] - e["offset" + n]
}, ta = function(e, t) {
    var n = "scroll" + (t === "x" ? "Left" : "Top");
    return e === zi && (e.pageXOffset != null ? n = "page" + t.toUpperCase() + "Offset" : e = li[n] != null ? li : cr),
    function() {
        return e[n]
    }
}, $0 = function(e, t, n, i) {
    if (Kh(e) && (e = e(t, n, i)),
    typeof e != "object")
        return zm(e) && e !== "max" && e.charAt(1) !== "=" ? {
            x: e,
            y: e
        } : {
            y: e
        };
    if (e.nodeType)
        return {
            y: e,
            x: e
        };
    var r = {}, s;
    for (s in e)
        r[s] = s !== "onAutoKill" && Kh(e[s]) ? e[s](t, n, i) : e[s];
    return r
}, Um = function(e, t) {
    if (e = Fm(e)[0],
    !e || !e.getBoundingClientRect)
        return console.warn("scrollTo target doesn't exist. Using 0") || {
            x: 0,
            y: 0
        };
    var n = e.getBoundingClientRect()
      , i = !t || t === zi || t === cr
      , r = i ? {
        top: li.clientTop - (zi.pageYOffset || li.scrollTop || cr.scrollTop || 0),
        left: li.clientLeft - (zi.pageXOffset || li.scrollLeft || cr.scrollLeft || 0)
    } : t.getBoundingClientRect()
      , s = {
        x: n.left - r.left,
        y: n.top - r.top
    };
    return !i && t && (s.x += ta(t, "x")(),
    s.y += ta(t, "y")()),
    s
}, $h = function(e, t, n, i, r) {
    return !isNaN(e) && typeof e != "object" ? parseFloat(e) - r : zm(e) && e.charAt(1) === "=" ? parseFloat(e.substr(2)) * (e.charAt(0) === "-" ? -1 : 1) + i - r : e === "max" ? ea(t, n) - r : Math.min(ea(t, n), Um(e, t)[n] - r)
}, Zh = function() {
    hn = km(),
    Nm() && hn && document.body && (zi = window,
    cr = document.body,
    li = document.documentElement,
    Fm = hn.utils.toArray,
    hn.config({
        autoKillThreshold: 7
    }),
    Om = hn.config(),
    Im = 1)
}, Vl = {
    version: "3.11.1",
    name: "scrollTo",
    rawVars: 1,
    register: function(e) {
        hn = e,
        Zh()
    },
    init: function(e, t, n, i, r) {
        Im || Zh();
        var s = this
          , a = hn.getProperty(e, "scrollSnapType");
        s.isWin = e === zi,
        s.target = e,
        s.tween = n,
        t = $0(t, i, e, r),
        s.vars = t,
        s.autoKill = !!t.autoKill,
        s.getX = ta(e, "x"),
        s.getY = ta(e, "y"),
        s.x = s.xPrev = s.getX(),
        s.y = s.yPrev = s.getY(),
        hn.getProperty(e, "scrollBehavior") === "smooth" && hn.set(e, {
            scrollBehavior: "auto"
        }),
        a && a !== "none" && (s.snap = 1,
        s.snapInline = e.style.scrollSnapType,
        e.style.scrollSnapType = "none"),
        t.x != null ? (s.add(s, "x", s.x, $h(t.x, e, "x", s.x, t.offsetX || 0), i, r),
        s._props.push("scrollTo_x")) : s.skipX = 1,
        t.y != null ? (s.add(s, "y", s.y, $h(t.y, e, "y", s.y, t.offsetY || 0), i, r),
        s._props.push("scrollTo_y")) : s.skipY = 1
    },
    render: function(e, t) {
        for (var n = t._pt, i = t.target, r = t.tween, s = t.autoKill, a = t.xPrev, l = t.yPrev, u = t.isWin, c = t.snap, h = t.snapInline, f, m, _, d, p; n; )
            n.r(e, n.d),
            n = n._next;
        f = u || !t.skipX ? t.getX() : a,
        m = u || !t.skipY ? t.getY() : l,
        _ = m - l,
        d = f - a,
        p = Om.autoKillThreshold,
        t.x < 0 && (t.x = 0),
        t.y < 0 && (t.y = 0),
        s && (!t.skipX && (d > p || d < -p) && f < ea(i, "x") && (t.skipX = 1),
        !t.skipY && (_ > p || _ < -p) && m < ea(i, "y") && (t.skipY = 1),
        t.skipX && t.skipY && (r.kill(),
        t.vars.onAutoKill && t.vars.onAutoKill.apply(r, t.vars.onAutoKillParams || []))),
        u ? zi.scrollTo(t.skipX ? f : t.x, t.skipY ? m : t.y) : (t.skipY || (i.scrollTop = t.y),
        t.skipX || (i.scrollLeft = t.x)),
        c && (e === 1 || e === 0) && (m = i.scrollTop,
        f = i.scrollLeft,
        h ? i.style.scrollSnapType = h : i.style.removeProperty("scroll-snap-type"),
        i.scrollTop = m + 1,
        i.scrollLeft = f + 1,
        i.scrollTop = m,
        i.scrollLeft = f),
        t.xPrev = t.x,
        t.yPrev = t.y
    },
    kill: function(e) {
        var t = e === "scrollTo";
        (t || e === "scrollTo_x") && (this.skipX = 1),
        (t || e === "scrollTo_y") && (this.skipY = 1)
    }
};
Vl.max = ea;
Vl.getOffset = Um;
Vl.buildGetter = ta;
km() && hn.registerPlugin(Vl);
/*!
 * ScrollTrigger 3.11.1
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var Ae, As, $e, gt, Ii, _t, Bm, Pl, Il, Fs, hl, Sa, zt, Gl, gc, Zt, Qh, Jh, Cs, Vm, au, Gm, In, Hm, Wm, jm, nr, _c, lu, Da = 1, Qt = Date.now, uu = Qt(), Hn = 0, Ta = 0, ef = function() {
    return Gl = 1
}, tf = function() {
    return Gl = 0
}, ri = function(e) {
    return e
}, Ao = function(e) {
    return Math.round(e * 1e5) / 1e5 || 0
}, qm = function() {
    return typeof window < "u"
}, Xm = function() {
    return Ae || qm() && (Ae = window.gsap) && Ae.registerPlugin && Ae
}, $r = function(e) {
    return !!~Bm.indexOf(e)
}, Ym = function(e) {
    return ur(e, "getBoundingClientRect") || ($r(e) ? function() {
        return vl.width = $e.innerWidth,
        vl.height = $e.innerHeight,
        vl
    }
    : function() {
        return Ai(e)
    }
    )
}, Z0 = function(e, t, n) {
    var i = n.d
      , r = n.d2
      , s = n.a;
    return (s = ur(e, "getBoundingClientRect")) ? function() {
        return s()[i]
    }
    : function() {
        return (t ? $e["inner" + r] : e["client" + r]) || 0
    }
}, Q0 = function(e, t) {
    return !t || ~ci.indexOf(e) ? Ym(e) : function() {
        return vl
    }
}, or = function(e, t) {
    var n = t.s
      , i = t.d2
      , r = t.d
      , s = t.a;
    return (n = "scroll" + i) && (s = ur(e, n)) ? s() - Ym(e)()[r] : $r(e) ? (Ii[n] || _t[n]) - ($e["inner" + i] || Ii["client" + i] || _t["client" + i]) : e[n] - e["offset" + i]
}, Ea = function(e, t) {
    for (var n = 0; n < Cs.length; n += 3)
        (!t || ~t.indexOf(Cs[n + 1])) && e(Cs[n], Cs[n + 1], Cs[n + 2])
}, ii = function(e) {
    return typeof e == "string"
}, Fi = function(e) {
    return typeof e == "function"
}, Co = function(e) {
    return typeof e == "number"
}, fl = function(e) {
    return typeof e == "object"
}, vo = function(e, t, n) {
    return e && e.progress(t ? 0 : 1) && n && e.pause()
}, cu = function(e, t) {
    if (e.enabled) {
        var n = t(e);
        n && n.totalTime && (e.callbackAnimation = n)
    }
}, cs = Math.abs, Km = "left", $m = "top", nh = "right", ih = "bottom", Wr = "width", jr = "height", Bo = "Right", Vo = "Left", Go = "Top", Ho = "Bottom", Dt = "padding", Fn = "margin", Zs = "Width", rh = "Height", $t = "px", ai = function(e) {
    return $e.getComputedStyle(e)
}, J0 = function(e) {
    var t = ai(e).position;
    e.style.position = t === "absolute" || t === "fixed" ? t : "relative"
}, nf = function(e, t) {
    for (var n in t)
        n in e || (e[n] = t[n]);
    return e
}, Ai = function(e, t) {
    var n = t && ai(e)[gc] !== "matrix(1, 0, 0, 1, 0, 0)" && Ae.to(e, {
        x: 0,
        y: 0,
        xPercent: 0,
        yPercent: 0,
        rotation: 0,
        rotationX: 0,
        rotationY: 0,
        scale: 1,
        skewX: 0,
        skewY: 0
    }).progress(1)
      , i = e.getBoundingClientRect();
    return n && n.progress(0).kill(),
    i
}, vc = function(e, t) {
    var n = t.d2;
    return e["offset" + n] || e["client" + n] || 0
}, Zm = function(e) {
    var t = [], n = e.labels, i = e.duration(), r;
    for (r in n)
        t.push(n[r] / i);
    return t
}, ev = function(e) {
    return function(t) {
        return Ae.utils.snap(Zm(e), t)
    }
}, sh = function(e) {
    var t = Ae.utils.snap(e)
      , n = Array.isArray(e) && e.slice(0).sort(function(i, r) {
        return i - r
    });
    return n ? function(i, r, s) {
        s === void 0 && (s = .001);
        var a;
        if (!r)
            return t(i);
        if (r > 0) {
            for (i -= s,
            a = 0; a < n.length; a++)
                if (n[a] >= i)
                    return n[a];
            return n[a - 1]
        } else
            for (a = n.length,
            i += s; a--; )
                if (n[a] <= i)
                    return n[a];
        return n[0]
    }
    : function(i, r, s) {
        s === void 0 && (s = .001);
        var a = t(i);
        return !r || Math.abs(a - i) < s || a - i < 0 == r < 0 ? a : t(r < 0 ? i - e : i + e)
    }
}, tv = function(e) {
    return function(t, n) {
        return sh(Zm(e))(t, n.direction)
    }
}, Aa = function(e, t, n, i) {
    return n.split(",").forEach(function(r) {
        return e(t, r, i)
    })
}, Ut = function(e, t, n, i, r) {
    return e.addEventListener(t, n, {
        passive: !i,
        capture: !!r
    })
}, Nt = function(e, t, n, i) {
    return e.removeEventListener(t, n, !!i)
}, Ca = function(e, t, n) {
    return n && n.wheelHandler && e(t, "wheel", n)
}, rf = {
    startColor: "green",
    endColor: "red",
    indent: 0,
    fontSize: "16px",
    fontWeight: "normal"
}, La = {
    toggleActions: "play",
    anticipatePin: 0
}, Fl = {
    top: 0,
    left: 0,
    center: .5,
    bottom: 1,
    right: 1
}, dl = function(e, t) {
    if (ii(e)) {
        var n = e.indexOf("=")
          , i = ~n ? +(e.charAt(n - 1) + 1) * parseFloat(e.substr(n + 1)) : 0;
        ~n && (e.indexOf("%") > n && (i *= t / 100),
        e = e.substr(0, n - 1)),
        e = i + (e in Fl ? Fl[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0)
    }
    return e
}, Ra = function(e, t, n, i, r, s, a, l) {
    var u = r.startColor
      , c = r.endColor
      , h = r.fontSize
      , f = r.indent
      , m = r.fontWeight
      , _ = gt.createElement("div")
      , d = $r(n) || ur(n, "pinType") === "fixed"
      , p = e.indexOf("scroller") !== -1
      , v = d ? _t : n
      , x = e.indexOf("start") !== -1
      , S = x ? u : c
      , M = "border-color:" + S + ";font-size:" + h + ";color:" + S + ";font-weight:" + m + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
    return M += "position:" + ((p || l) && d ? "fixed;" : "absolute;"),
    (p || l || !d) && (M += (i === Pt ? nh : ih) + ":" + (s + parseFloat(f)) + "px;"),
    a && (M += "box-sizing:border-box;text-align:left;width:" + a.offsetWidth + "px;"),
    _._isStart = x,
    _.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")),
    _.style.cssText = M,
    _.innerText = t || t === 0 ? e + "-" + t : e,
    v.children[0] ? v.insertBefore(_, v.children[0]) : v.appendChild(_),
    _._offset = _["offset" + i.op.d2],
    pl(_, 0, i, x),
    _
}, pl = function(e, t, n, i) {
    var r = {
        display: "block"
    }
      , s = n[i ? "os2" : "p2"]
      , a = n[i ? "p2" : "os2"];
    e._isFlipped = i,
    r[n.a + "Percent"] = i ? -100 : 0,
    r[n.a] = i ? "1px" : 0,
    r["border" + s + Zs] = 1,
    r["border" + a + Zs] = 0,
    r[n.p] = t + "px",
    Ae.set(e, r)
}, Xe = [], xc = {}, yc, sf = function() {
    return Qt() - Hn > 34 && na()
}, hs = function() {
    (!In || !In.isPressed || In.startX > _t.clientWidth) && (et.cache++,
    yc || (yc = requestAnimationFrame(na)),
    Hn || Qr("scrollStart"),
    Hn = Qt())
}, of = function() {
    jm = $e.innerWidth,
    Wm = $e.innerHeight
}, Lo = function() {
    et.cache++,
    !zt && !Gm && !gt.fullscreenElement && !gt.webkitFullscreenElement && (!Hm || jm !== $e.innerWidth || Math.abs($e.innerHeight - Wm) > $e.innerHeight * .25) && Pl.restart(!0)
}, Zr = {}, nv = [], Qm = function o() {
    return Nt(nt, "scrollEnd", o) || Os(!0)
}, Qr = function(e) {
    return Zr[e] && Zr[e].map(function(t) {
        return t()
    }) || nv
}, yn = [], Jm = function(e) {
    for (var t = 0; t < yn.length; t += 5)
        (!e || yn[t + 4] && yn[t + 4].query === e) && (yn[t].style.cssText = yn[t + 1],
        yn[t].getBBox && yn[t].setAttribute("transform", yn[t + 2] || ""),
        yn[t + 3].uncache = 1)
}, oh = function(e, t) {
    var n;
    for (Zt = 0; Zt < Xe.length; Zt++)
        n = Xe[Zt],
        n && (!t || n._ctx === t) && (e ? n.kill(1) : n.revert(!0, !0));
    t && Jm(t),
    t || Qr("revert")
}, eg = function() {
    return et.cache++ && et.forEach(function(e) {
        return typeof e == "function" && (e.rec = 0)
    })
}, Ei, ml = 0, Os = function(e, t) {
    if (Hn && !e) {
        Ut(nt, "scrollEnd", Qm);
        return
    }
    Ei = !0;
    var n = Qr("refreshInit");
    Vm && nt.sort(),
    t || oh(),
    Xe.slice(0).forEach(function(i) {
        return i.refresh()
    }),
    Xe.forEach(function(i) {
        return i.vars.end === "max" && i.setPositions(i.start, Math.max(i.start + 1, or(i.scroller, i._dir)))
    }),
    n.forEach(function(i) {
        return i && i.render && i.render(-1)
    }),
    et.forEach(function(i) {
        return typeof i == "function" && i(i.rec)
    }),
    eg(),
    Pl.pause(),
    ml++,
    Ei = !1,
    Qr("refresh")
}, af = 0, gl = 1, Rr, na = function() {
    if (!Ei) {
        nt.isUpdating = !0,
        Rr && Rr.update(0);
        var e = Xe.length
          , t = Qt()
          , n = t - uu >= 50
          , i = e && Xe[0].scroll();
        if (gl = af > i ? -1 : 1,
        af = i,
        n && (Hn && !Gl && t - Hn > 200 && (Hn = 0,
        Qr("scrollEnd")),
        hl = uu,
        uu = t),
        gl < 0) {
            for (Zt = e; Zt-- > 0; )
                Xe[Zt] && Xe[Zt].update(0, n);
            gl = 1
        } else
            for (Zt = 0; Zt < e; Zt++)
                Xe[Zt] && Xe[Zt].update(0, n);
        nt.isUpdating = !1
    }
    yc = 0
}, bc = [Km, $m, ih, nh, Fn + Ho, Fn + Bo, Fn + Go, Fn + Vo, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], _l = bc.concat([Wr, jr, "boxSizing", "max" + Zs, "max" + rh, "position", Fn, Dt, Dt + Go, Dt + Bo, Dt + Ho, Dt + Vo]), iv = function(e, t, n) {
    ia(n);
    var i = e._gsap;
    if (i.spacerIsNative)
        ia(i.spacerState);
    else if (e._gsap.swappedIn) {
        var r = t.parentNode;
        r && (r.insertBefore(e, t),
        r.removeChild(t))
    }
    e._gsap.swappedIn = !1
}, hu = function(e, t, n, i) {
    if (!e._gsap.swappedIn) {
        for (var r = bc.length, s = t.style, a = e.style, l; r--; )
            l = bc[r],
            s[l] = n[l];
        s.position = n.position === "absolute" ? "absolute" : "relative",
        n.display === "inline" && (s.display = "inline-block"),
        a[ih] = a[nh] = "auto",
        s.flexBasis = n.flexBasis || "auto",
        s.overflow = "visible",
        s.boxSizing = "border-box",
        s[Wr] = vc(e, Jt) + $t,
        s[jr] = vc(e, Pt) + $t,
        s[Dt] = a[Fn] = a[$m] = a[Km] = "0",
        ia(i),
        a[Wr] = a["max" + Zs] = n[Wr],
        a[jr] = a["max" + rh] = n[jr],
        a[Dt] = n[Dt],
        e.parentNode !== t && (e.parentNode.insertBefore(t, e),
        t.appendChild(e)),
        e._gsap.swappedIn = !0
    }
}, rv = /([A-Z])/g, ia = function(e) {
    if (e) {
        var t = e.t.style, n = e.length, i = 0, r, s;
        for ((e.t._gsap || Ae.core.getCache(e.t)).uncache = 1; i < n; i += 2)
            s = e[i + 1],
            r = e[i],
            s ? t[r] = s : t[r] && t.removeProperty(r.replace(rv, "-$1").toLowerCase())
    }
}, Pa = function(e) {
    for (var t = _l.length, n = e.style, i = [], r = 0; r < t; r++)
        i.push(_l[r], n[_l[r]]);
    return i.t = e,
    i
}, sv = function(e, t, n) {
    for (var i = [], r = e.length, s = n ? 8 : 0, a; s < r; s += 2)
        a = e[s],
        i.push(a, a in t ? t[a] : e[s + 1]);
    return i.t = e.t,
    i
}, vl = {
    left: 0,
    top: 0
}, lf = function(e, t, n, i, r, s, a, l, u, c, h, f, m) {
    Fi(e) && (e = e(l)),
    ii(e) && e.substr(0, 3) === "max" && (e = f + (e.charAt(4) === "=" ? dl("0" + e.substr(3), n) : 0));
    var _ = m ? m.time() : 0, d, p, v;
    if (m && m.seek(0),
    Co(e))
        a && pl(a, n, i, !0);
    else {
        Fi(t) && (t = t(l));
        var x = (e || "0").split(" "), S, M, T, L;
        v = an(t) || _t,
        S = Ai(v) || {},
        (!S || !S.left && !S.top) && ai(v).display === "none" && (L = v.style.display,
        v.style.display = "block",
        S = Ai(v),
        L ? v.style.display = L : v.style.removeProperty("display")),
        M = dl(x[0], S[i.d]),
        T = dl(x[1] || "0", n),
        e = S[i.p] - u[i.p] - c + M + r - T,
        a && pl(a, T, i, n - T < 20 || a._isStart && T > 20),
        n -= n - T
    }
    if (s) {
        var P = e + n
          , A = s._isStart;
        d = "scroll" + i.d2,
        pl(s, P, i, A && P > 20 || !A && (h ? Math.max(_t[d], Ii[d]) : s.parentNode[d]) <= P + 1),
        h && (u = Ai(a),
        h && (s.style[i.op.p] = u[i.op.p] - i.op.m - s._offset + $t))
    }
    return m && v && (d = Ai(v),
    m.seek(f),
    p = Ai(v),
    m._caScrollDist = d[i.p] - p[i.p],
    e = e / m._caScrollDist * f),
    m && m.seek(_),
    m ? e : Math.round(e)
}, ov = /(webkit|moz|length|cssText|inset)/i, uf = function(e, t, n, i) {
    if (e.parentNode !== t) {
        var r = e.style, s, a;
        if (t === _t) {
            e._stOrig = r.cssText,
            a = ai(e);
            for (s in a)
                !+s && !ov.test(s) && a[s] && typeof r[s] == "string" && s !== "0" && (r[s] = a[s]);
            r.top = n,
            r.left = i
        } else
            r.cssText = e._stOrig;
        Ae.core.getCache(e).uncache = 1,
        t.appendChild(e)
    }
}, cf = function(e, t) {
    var n = dr(e, t), i = "_scroll" + t.p2, r, s, a = function l(u, c, h, f, m) {
        var _ = l.tween
          , d = c.onComplete
          , p = {};
        return h = h || n(),
        m = f && m || 0,
        f = f || u - h,
        _ && _.kill(),
        r = Math.round(h),
        c[i] = u,
        c.modifiers = p,
        p[i] = function(v) {
            return v = Math.round(n()),
            v !== r && v !== s && Math.abs(v - r) > 3 && Math.abs(v - s) > 3 ? (_.kill(),
            l.tween = 0) : v = h + f * _.ratio + m * _.ratio * _.ratio,
            s = r,
            r = Math.round(v)
        }
        ,
        c.onComplete = function() {
            l.tween = 0,
            d && d.call(_)
        }
        ,
        _ = l.tween = Ae.to(e, c),
        _
    };
    return e[i] = n,
    n.wheelHandler = function() {
        return a.tween && a.tween.kill() && (a.tween = 0)
    }
    ,
    Ut(e, "wheel", n.wheelHandler),
    a
}, nt = function() {
    function o(t, n) {
        As || o.register(Ae) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
        this.init(t, n)
    }
    var e = o.prototype;
    return e.init = function(n, i) {
        if (this.progress = this.start = 0,
        this.vars && this.kill(!0, !0),
        !Ta) {
            this.update = this.refresh = this.kill = ri;
            return
        }
        n = nf(ii(n) || Co(n) || n.nodeType ? {
            trigger: n
        } : n, La);
        var r = n, s = r.onUpdate, a = r.toggleClass, l = r.id, u = r.onToggle, c = r.onRefresh, h = r.scrub, f = r.trigger, m = r.pin, _ = r.pinSpacing, d = r.invalidateOnRefresh, p = r.anticipatePin, v = r.onScrubComplete, x = r.onSnapComplete, S = r.once, M = r.snap, T = r.pinReparent, L = r.pinSpacer, P = r.containerAnimation, A = r.fastScrollEnd, C = r.preventOverlaps, N = n.horizontal || n.containerAnimation && n.horizontal !== !1 ? Jt : Pt, G = !h && h !== 0, q = an(n.scroller || $e), g = Ae.core.getCache(q), w = $r(q), E = ("pinType"in n ? n.pinType : ur(q, "pinType") || w && "fixed") === "fixed", R = [n.onEnter, n.onLeave, n.onEnterBack, n.onLeaveBack], z = G && n.toggleActions.split(" "), b = "markers"in n ? n.markers : La.markers, y = w ? 0 : parseFloat(ai(q)["border" + N.p2 + Zs]) || 0, D = this, I = n.onRefreshInit && function() {
            return n.onRefreshInit(D)
        }
        , F = Z0(q, w, N), B = Q0(q, w), H = 0, W = 0, U = dr(q, N), K, te, he, ne, ce, oe, ue, Oe, qe, Ue, J, Ve, ye, Ft, Ct, V, O, re, le, ae, fe, Se, ee, we, ve, De, xe, Fe, Ge, Re, j, de, Q, pe, me, Be, ht, Je;
        if (_c(D),
        D._dir = N,
        p *= 45,
        D.scroller = q,
        D.scroll = P ? P.time.bind(P) : U,
        ne = U(),
        D.vars = n,
        i = i || n.animation,
        "refreshPriority"in n && (Vm = 1,
        n.refreshPriority === -9999 && (Rr = D)),
        g.tweenScroll = g.tweenScroll || {
            top: cf(q, Pt),
            left: cf(q, Jt)
        },
        D.tweenTo = K = g.tweenScroll[N.p],
        D.scrubDuration = function(se) {
            j = Co(se) && se,
            j ? Re ? Re.duration(se) : Re = Ae.to(i, {
                ease: "expo",
                totalProgress: "+=0.001",
                duration: j,
                paused: !0,
                onComplete: function() {
                    return v && v(D)
                }
            }) : (Re && Re.progress(1).kill(),
            Re = 0)
        }
        ,
        i && (i.vars.lazy = !1,
        i._initted || i.vars.immediateRender !== !1 && n.immediateRender !== !1 && i.render(0, !0, !0),
        D.animation = i.pause(),
        i.scrollTrigger = D,
        D.scrubDuration(h),
        Fe = 0,
        l || (l = i.vars.id)),
        Xe.push(D),
        M && ((!fl(M) || M.push) && (M = {
            snapTo: M
        }),
        "scrollBehavior"in _t.style && Ae.set(w ? [_t, Ii] : q, {
            scrollBehavior: "auto"
        }),
        he = Fi(M.snapTo) ? M.snapTo : M.snapTo === "labels" ? ev(i) : M.snapTo === "labelsDirectional" ? tv(i) : M.directional !== !1 ? function(se, Ee) {
            return sh(M.snapTo)(se, Qt() - W < 500 ? 0 : Ee.direction)
        }
        : Ae.utils.snap(M.snapTo),
        de = M.duration || {
            min: .1,
            max: 2
        },
        de = fl(de) ? Fs(de.min, de.max) : Fs(de, de),
        Q = Ae.delayedCall(M.delay || j / 2 || .1, function() {
            var se = U()
              , Ee = Qt() - W < 500
              , Me = K.tween;
            if ((Ee || Math.abs(D.getVelocity()) < 10) && !Me && !Gl && H !== se) {
                var Ie = (se - oe) / ye
                  , bt = i && !G ? i.totalProgress() : Ie
                  , ke = Ee ? 0 : (bt - Ge) / (Qt() - hl) * 1e3 || 0
                  , mt = Ae.utils.clamp(-Ie, 1 - Ie, cs(ke / 2) * ke / .185)
                  , k = Ie + (M.inertia === !1 ? 0 : mt)
                  , $ = Fs(0, 1, he(k, D))
                  , Z = Math.round(oe + $ * ye)
                  , Y = M
                  , ie = Y.onStart
                  , _e = Y.onInterrupt
                  , be = Y.onComplete;
                if (se <= ue && se >= oe && Z !== se) {
                    if (Me && !Me._initted && Me.data <= cs(Z - se))
                        return;
                    M.inertia === !1 && (mt = $ - Ie),
                    K(Z, {
                        duration: de(cs(Math.max(cs(k - bt), cs($ - bt)) * .185 / ke / .05 || 0)),
                        ease: M.ease || "power3",
                        data: cs(Z - se),
                        onInterrupt: function() {
                            return Q.restart(!0) && _e && _e(D)
                        },
                        onComplete: function() {
                            D.update(),
                            H = U(),
                            Fe = Ge = i && !G ? i.totalProgress() : D.progress,
                            x && x(D),
                            be && be(D)
                        }
                    }, se, mt * ye, Z - se - mt * ye),
                    ie && ie(D, K.tween)
                }
            } else
                D.isActive && H !== se && Q.restart(!0)
        }).pause()),
        l && (xc[l] = D),
        f = D.trigger = an(f || m),
        Je = f && f._gsap && f._gsap.stRevert,
        Je && (Je = Je(D)),
        m = m === !0 ? f : an(m),
        ii(a) && (a = {
            targets: f,
            className: a
        }),
        m && (_ === !1 || _ === Fn || (_ = !_ && ai(m.parentNode).display === "flex" ? !1 : Dt),
        D.pin = m,
        n.force3D !== !1 && Ae.set(m, {
            force3D: !0
        }),
        te = Ae.core.getCache(m),
        te.spacer ? Ft = te.pinState : (L && (L = an(L),
        L && !L.nodeType && (L = L.current || L.nativeElement),
        te.spacerIsNative = !!L,
        L && (te.spacerState = Pa(L))),
        te.spacer = O = L || gt.createElement("div"),
        O.classList.add("pin-spacer"),
        l && O.classList.add("pin-spacer-" + l),
        te.pinState = Ft = Pa(m)),
        D.spacer = O = te.spacer,
        xe = ai(m),
        ee = xe[_ + N.os2],
        le = Ae.getProperty(m),
        ae = Ae.quickSetter(m, N.a, $t),
        hu(m, O, xe),
        V = Pa(m)),
        b) {
            Ve = fl(b) ? nf(b, rf) : rf,
            Ue = Ra("scroller-start", l, q, N, Ve, 0),
            J = Ra("scroller-end", l, q, N, Ve, 0, Ue),
            re = Ue["offset" + N.op.d2];
            var sn = an(ur(q, "content") || q);
            Oe = this.markerStart = Ra("start", l, sn, N, Ve, re, 0, P),
            qe = this.markerEnd = Ra("end", l, sn, N, Ve, re, 0, P),
            P && (ht = Ae.quickSetter([Oe, qe], N.a, $t)),
            !E && !(ci.length && ur(q, "fixedMarkers") === !0) && (J0(w ? _t : q),
            Ae.set([Ue, J], {
                force3D: !0
            }),
            ve = Ae.quickSetter(Ue, N.a, $t),
            De = Ae.quickSetter(J, N.a, $t))
        }
        if (P) {
            var st = P.vars.onUpdate
              , Ne = P.vars.onUpdateParams;
            P.eventCallback("onUpdate", function() {
                D.update(0, 0, 1),
                st && st.apply(Ne || [])
            })
        }
        D.previous = function() {
            return Xe[Xe.indexOf(D) - 1]
        }
        ,
        D.next = function() {
            return Xe[Xe.indexOf(D) + 1]
        }
        ,
        D.revert = function(se, Ee) {
            if (!Ee)
                return D.kill(!0);
            var Me = se !== !1 || !D.enabled
              , Ie = zt;
            Me !== D.isReverted && (Me && (!D.scroll.rec && (zt || Ei) && (D.scroll.rec = U(),
            Ei && U(0)),
            me = Math.max(U(), D.scroll.rec || 0),
            pe = D.progress,
            Be = i && i.progress()),
            Oe && [Oe, qe, Ue, J].forEach(function(bt) {
                return bt.style.display = Me ? "none" : "block"
            }),
            Me && (zt = 1),
            D.update(Me),
            zt = Ie,
            m && (Me ? iv(m, O, Ft) : (!T || !D.isActive) && hu(m, O, ai(m), we)),
            D.isReverted = Me)
        }
        ,
        D.refresh = function(se, Ee) {
            if (!((zt || !D.enabled) && !Ee)) {
                if (m && se && Hn) {
                    Ut(o, "scrollEnd", Qm);
                    return
                }
                !Ei && I && I(D),
                zt = 1,
                W = Qt(),
                K.tween && (K.tween.kill(),
                K.tween = 0),
                Re && Re.pause(),
                d && i && i.revert().invalidate(),
                D.isReverted || D.revert(!0, !0);
                for (var Me = F(), Ie = B(), bt = P ? P.duration() : or(q, N), ke = 0, mt = 0, k = n.end, $ = n.endTrigger || f, Z = n.start || (n.start === 0 || !f ? 0 : m ? "0 0" : "0 100%"), Y = D.pinnedContainer = n.pinnedContainer && an(n.pinnedContainer), ie = f && Math.max(0, Xe.indexOf(D)) || 0, _e = ie, be, Te, Pe, He, Le, Ce, Qe, qn, gi, En; _e--; )
                    Ce = Xe[_e],
                    Ce.end || Ce.refresh(0, 1) || (zt = 1),
                    Qe = Ce.pin,
                    Qe && (Qe === f || Qe === m) && !Ce.isReverted && (En || (En = []),
                    En.unshift(Ce),
                    Ce.revert(!0, !0)),
                    Ce !== Xe[_e] && (ie--,
                    _e--);
                for (Fi(Z) && (Z = Z(D)),
                oe = lf(Z, f, Me, N, U(), Oe, Ue, D, Ie, y, E, bt, P) || (m ? -.001 : 0),
                Fi(k) && (k = k(D)),
                ii(k) && !k.indexOf("+=") && (~k.indexOf(" ") ? k = (ii(Z) ? Z.split(" ")[0] : "") + k : (ke = dl(k.substr(2), Me),
                k = ii(Z) ? Z : oe + ke,
                $ = f)),
                ue = Math.max(oe, lf(k || ($ ? "100% 0" : bt), $, Me, N, U() + ke, qe, J, D, Ie, y, E, bt, P)) || -.001,
                ye = ue - oe || (oe -= .01) && .001,
                ke = 0,
                _e = ie; _e--; )
                    Ce = Xe[_e],
                    Qe = Ce.pin,
                    Qe && Ce.start - Ce._pinPush < oe && !P && Ce.end > 0 && (be = Ce.end - Ce.start,
                    (Qe === f || Qe === Y) && !Co(Z) && (ke += be * (1 - Ce.progress)),
                    Qe === m && (mt += be));
                if (oe += ke,
                ue += ke,
                D._pinPush = mt,
                Oe && ke && (be = {},
                be[N.a] = "+=" + ke,
                Y && (be[N.p] = "-=" + U()),
                Ae.set([Oe, qe], be)),
                m)
                    be = ai(m),
                    He = N === Pt,
                    Pe = U(),
                    fe = parseFloat(le(N.a)) + mt,
                    !bt && ue > 1 && ((w ? _t : q).style["overflow-" + N.a] = "scroll"),
                    hu(m, O, be),
                    V = Pa(m),
                    Te = Ai(m, !0),
                    qn = E && dr(q, He ? Jt : Pt)(),
                    _ && (we = [_ + N.os2, ye + mt + $t],
                    we.t = O,
                    _e = _ === Dt ? vc(m, N) + ye + mt : 0,
                    _e && we.push(N.d, _e + $t),
                    ia(we),
                    E && U(me)),
                    E && (Le = {
                        top: Te.top + (He ? Pe - oe : qn) + $t,
                        left: Te.left + (He ? qn : Pe - oe) + $t,
                        boxSizing: "border-box",
                        position: "fixed"
                    },
                    Le[Wr] = Le["max" + Zs] = Math.ceil(Te.width) + $t,
                    Le[jr] = Le["max" + rh] = Math.ceil(Te.height) + $t,
                    Le[Fn] = Le[Fn + Go] = Le[Fn + Bo] = Le[Fn + Ho] = Le[Fn + Vo] = "0",
                    Le[Dt] = be[Dt],
                    Le[Dt + Go] = be[Dt + Go],
                    Le[Dt + Bo] = be[Dt + Bo],
                    Le[Dt + Ho] = be[Dt + Ho],
                    Le[Dt + Vo] = be[Dt + Vo],
                    Ct = sv(Ft, Le, T),
                    Ei && U(0)),
                    i ? (gi = i._initted,
                    au(1),
                    i.render(i.duration(), !0, !0),
                    Se = le(N.a) - fe + ye + mt,
                    ye !== Se && E && Ct.splice(Ct.length - 2, 2),
                    i.render(0, !0, !0),
                    gi || i.invalidate(),
                    au(0)) : Se = ye;
                else if (f && U() && !P)
                    for (Te = f.parentNode; Te && Te !== _t; )
                        Te._pinOffset && (oe -= Te._pinOffset,
                        ue -= Te._pinOffset),
                        Te = Te.parentNode;
                En && En.forEach(function(An) {
                    return An.revert(!1, !0)
                }),
                D.start = oe,
                D.end = ue,
                ne = ce = U(),
                !P && !Ei && (ne < me && U(me),
                D.scroll.rec = 0),
                D.revert(!1, !0),
                Q && (H = -1,
                D.isActive && U(oe + ye * pe),
                Q.restart(!0)),
                zt = 0,
                i && G && (i._initted || Be) && i.progress() !== Be && i.progress(Be, !0).render(i.time(), !0, !0),
                (pe !== D.progress || P) && (i && !G && i.totalProgress(pe, !0),
                D.progress = (ne - oe) / ye === pe ? 0 : pe,
                D.update(0, 0, 1)),
                m && _ && (O._pinOffset = Math.round(D.progress * Se)),
                c && c(D)
            }
        }
        ,
        D.getVelocity = function() {
            return (U() - ce) / (Qt() - hl) * 1e3 || 0
        }
        ,
        D.endAnimation = function() {
            vo(D.callbackAnimation),
            i && (Re ? Re.progress(1) : i.paused() ? G || vo(i, D.direction < 0, 1) : vo(i, i.reversed()))
        }
        ,
        D.labelToScroll = function(se) {
            return i && i.labels && (oe || D.refresh() || oe) + i.labels[se] / i.duration() * ye || 0
        }
        ,
        D.getTrailing = function(se) {
            var Ee = Xe.indexOf(D)
              , Me = D.direction > 0 ? Xe.slice(0, Ee).reverse() : Xe.slice(Ee + 1);
            return (ii(se) ? Me.filter(function(Ie) {
                return Ie.vars.preventOverlaps === se
            }) : Me).filter(function(Ie) {
                return D.direction > 0 ? Ie.end <= oe : Ie.start >= ue
            })
        }
        ,
        D.update = function(se, Ee, Me) {
            if (!(P && !Me && !se)) {
                var Ie = D.scroll(), bt = se ? 0 : (Ie - oe) / ye, ke = bt < 0 ? 0 : bt > 1 ? 1 : bt || 0, mt = D.progress, k, $, Z, Y, ie, _e, be, Te;
                if (Ee && (ce = ne,
                ne = P ? U() : Ie,
                M && (Ge = Fe,
                Fe = i && !G ? i.totalProgress() : ke)),
                p && !ke && m && !zt && !Da && Hn && oe < Ie + (Ie - ce) / (Qt() - hl) * p && (ke = 1e-4),
                ke !== mt && D.enabled) {
                    if (k = D.isActive = !!ke && ke < 1,
                    $ = !!mt && mt < 1,
                    _e = k !== $,
                    ie = _e || !!ke != !!mt,
                    D.direction = ke > mt ? 1 : -1,
                    D.progress = ke,
                    ie && !zt && (Z = ke && !mt ? 0 : ke === 1 ? 1 : mt === 1 ? 2 : 3,
                    G && (Y = !_e && z[Z + 1] !== "none" && z[Z + 1] || z[Z],
                    Te = i && (Y === "complete" || Y === "reset" || Y in i))),
                    C && (_e || Te) && (Te || h || !i) && (Fi(C) ? C(D) : D.getTrailing(C).forEach(function(Ce) {
                        return Ce.endAnimation()
                    })),
                    G || (Re && !zt && !Da ? ((P || Rr && Rr !== D) && Re.render(Re._dp._time - Re._start),
                    Re.resetTo ? Re.resetTo("totalProgress", ke, i._tTime / i._tDur) : (Re.vars.totalProgress = ke,
                    Re.invalidate().restart())) : i && i.totalProgress(ke, !!zt)),
                    m) {
                        if (se && _ && (O.style[_ + N.os2] = ee),
                        !E)
                            ae(Ao(fe + Se * ke));
                        else if (ie) {
                            if (be = !se && ke > mt && ue + 1 > Ie && Ie + 1 >= or(q, N),
                            T)
                                if (!se && (k || be)) {
                                    var Pe = Ai(m, !0)
                                      , He = Ie - oe;
                                    uf(m, _t, Pe.top + (N === Pt ? He : 0) + $t, Pe.left + (N === Pt ? 0 : He) + $t)
                                } else
                                    uf(m, O);
                            ia(k || be ? Ct : V),
                            Se !== ye && ke < 1 && k || ae(fe + (ke === 1 && !be ? Se : 0))
                        }
                    }
                    M && !K.tween && !zt && !Da && Q.restart(!0),
                    a && (_e || S && ke && (ke < 1 || !lu)) && Il(a.targets).forEach(function(Ce) {
                        return Ce.classList[k || S ? "add" : "remove"](a.className)
                    }),
                    s && !G && !se && s(D),
                    ie && !zt ? (G && (Te && (Y === "complete" ? i.pause().totalProgress(1) : Y === "reset" ? i.restart(!0).pause() : Y === "restart" ? i.restart(!0) : i[Y]()),
                    s && s(D)),
                    (_e || !lu) && (u && _e && cu(D, u),
                    R[Z] && cu(D, R[Z]),
                    S && (ke === 1 ? D.kill(!1, 1) : R[Z] = 0),
                    _e || (Z = ke === 1 ? 1 : 3,
                    R[Z] && cu(D, R[Z]))),
                    A && !k && Math.abs(D.getVelocity()) > (Co(A) ? A : 2500) && (vo(D.callbackAnimation),
                    Re ? Re.progress(1) : vo(i, Y === "reverse" ? 1 : !ke, 1))) : G && s && !zt && s(D)
                }
                if (De) {
                    var Le = P ? Ie / P.duration() * (P._caScrollDist || 0) : Ie;
                    ve(Le + (Ue._isFlipped ? 1 : 0)),
                    De(Le)
                }
                ht && ht(-Ie / P.duration() * (P._caScrollDist || 0))
            }
        }
        ,
        D.enable = function(se, Ee) {
            D.enabled || (D.enabled = !0,
            Ut(q, "resize", Lo),
            Ut(w ? gt : q, "scroll", hs),
            I && Ut(o, "refreshInit", I),
            se !== !1 && (D.progress = pe = 0,
            ne = ce = H = U()),
            Ee !== !1 && D.refresh())
        }
        ,
        D.getTween = function(se) {
            return se && K ? K.tween : Re
        }
        ,
        D.setPositions = function(se, Ee) {
            m && (fe += se - oe,
            Se += Ee - se - ye),
            D.start = oe = se,
            D.end = ue = Ee,
            ye = Ee - se,
            D.update()
        }
        ,
        D.disable = function(se, Ee) {
            if (D.enabled && (se !== !1 && D.revert(!0, !0),
            D.enabled = D.isActive = !1,
            Ee || Re && Re.pause(),
            me = 0,
            te && (te.uncache = 1),
            I && Nt(o, "refreshInit", I),
            Q && (Q.pause(),
            K.tween && K.tween.kill() && (K.tween = 0)),
            !w)) {
                for (var Me = Xe.length; Me--; )
                    if (Xe[Me].scroller === q && Xe[Me] !== D)
                        return;
                Nt(q, "resize", Lo),
                Nt(q, "scroll", hs)
            }
        }
        ,
        D.kill = function(se, Ee) {
            D.disable(se, Ee),
            Re && !Ee && Re.kill(),
            l && delete xc[l];
            var Me = Xe.indexOf(D);
            Me >= 0 && Xe.splice(Me, 1),
            Me === Zt && gl > 0 && Zt--,
            Me = 0,
            Xe.forEach(function(Ie) {
                return Ie.scroller === D.scroller && (Me = 1)
            }),
            Me || Ei || (D.scroll.rec = 0),
            i && (i.scrollTrigger = null,
            se && i.render(-1),
            Ee || i.kill()),
            Oe && [Oe, qe, Ue, J].forEach(function(Ie) {
                return Ie.parentNode && Ie.parentNode.removeChild(Ie)
            }),
            Rr === D && (Rr = 0),
            m && (te && (te.uncache = 1),
            Me = 0,
            Xe.forEach(function(Ie) {
                return Ie.pin === m && Me++
            }),
            Me || (te.spacer = 0)),
            n.onKill && n.onKill(D)
        }
        ,
        D.enable(!1, !1),
        Je && Je(D),
        !i || !i.add || ye ? D.refresh() : Ae.delayedCall(.01, function() {
            return oe || ue || D.refresh()
        }) && (ye = .01) && (oe = ue = 0)
    }
    ,
    o.register = function(n) {
        return As || (Ae = n || Xm(),
        qm() && window.document && o.enable(),
        As = Ta),
        As
    }
    ,
    o.defaults = function(n) {
        if (n)
            for (var i in n)
                La[i] = n[i];
        return La
    }
    ,
    o.disable = function(n, i) {
        Ta = 0,
        Xe.forEach(function(s) {
            return s[i ? "kill" : "disable"](n)
        }),
        Nt($e, "wheel", hs),
        Nt(gt, "scroll", hs),
        clearInterval(Sa),
        Nt(gt, "touchcancel", ri),
        Nt(_t, "touchstart", ri),
        Aa(Nt, gt, "pointerdown,touchstart,mousedown", ef),
        Aa(Nt, gt, "pointerup,touchend,mouseup", tf),
        Pl.kill(),
        Ea(Nt);
        for (var r = 0; r < et.length; r += 3)
            Ca(Nt, et[r], et[r + 1]),
            Ca(Nt, et[r], et[r + 2])
    }
    ,
    o.enable = function() {
        if ($e = window,
        gt = document,
        Ii = gt.documentElement,
        _t = gt.body,
        Ae && (Il = Ae.utils.toArray,
        Fs = Ae.utils.clamp,
        _c = Ae.core.context || ri,
        au = Ae.core.suppressOverwrites || ri,
        Ae.core.globals("ScrollTrigger", o),
        _t)) {
            Ta = 1,
            At.register(Ae),
            o.isTouch = At.isTouch,
            nr = At.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent),
            Ut($e, "wheel", hs),
            Bm = [$e, gt, Ii, _t],
            Ae.matchMedia ? (o.matchMedia = function(l) {
                var u = Ae.matchMedia(), c;
                for (c in l)
                    u.add(c, l[c]);
                return u
            }
            ,
            Ae.addEventListener("matchMediaInit", function() {
                return oh()
            }),
            Ae.addEventListener("matchMediaRevert", function() {
                return Jm()
            }),
            Ae.addEventListener("matchMedia", function() {
                Os(0, 1),
                Qr("matchMedia")
            }),
            Ae.matchMedia("(orientation: portrait)", function() {
                return of(),
                of
            })) : console.warn("Requires GSAP 3.11.0 or later"),
            Ut(gt, "scroll", hs);
            var n = _t.style, i = n.borderTopStyle, r = Ae.core.Animation.prototype, s, a;
            for (r.revert || Object.defineProperty(r, "revert", {
                value: function() {
                    return this.time(-.01, !0)
                }
            }),
            n.borderTopStyle = "solid",
            s = Ai(_t),
            Pt.m = Math.round(s.top + Pt.sc()) || 0,
            Jt.m = Math.round(s.left + Jt.sc()) || 0,
            i ? n.borderTopStyle = i : n.removeProperty("border-top-style"),
            Sa = setInterval(sf, 250),
            Ae.delayedCall(.5, function() {
                return Da = 0
            }),
            Ut(gt, "touchcancel", ri),
            Ut(_t, "touchstart", ri),
            Aa(Ut, gt, "pointerdown,touchstart,mousedown", ef),
            Aa(Ut, gt, "pointerup,touchend,mouseup", tf),
            gc = Ae.utils.checkPrefix("transform"),
            _l.push(gc),
            As = Qt(),
            Pl = Ae.delayedCall(.2, Os).pause(),
            Cs = [gt, "visibilitychange", function() {
                var l = $e.innerWidth
                  , u = $e.innerHeight;
                gt.hidden ? (Qh = l,
                Jh = u) : (Qh !== l || Jh !== u) && Lo()
            }
            , gt, "DOMContentLoaded", Os, $e, "load", Os, $e, "resize", Lo],
            Ea(Ut),
            Xe.forEach(function(l) {
                return l.enable(0, 1)
            }),
            a = 0; a < et.length; a += 3)
                Ca(Nt, et[a], et[a + 1]),
                Ca(Nt, et[a], et[a + 2])
        }
    }
    ,
    o.config = function(n) {
        "limitCallbacks"in n && (lu = !!n.limitCallbacks);
        var i = n.syncInterval;
        i && clearInterval(Sa) || (Sa = i) && setInterval(sf, i),
        "ignoreMobileResize"in n && (Hm = o.isTouch === 1 && n.ignoreMobileResize),
        "autoRefreshEvents"in n && (Ea(Nt) || Ea(Ut, n.autoRefreshEvents || "none"),
        Gm = (n.autoRefreshEvents + "").indexOf("resize") === -1)
    }
    ,
    o.scrollerProxy = function(n, i) {
        var r = an(n)
          , s = et.indexOf(r)
          , a = $r(r);
        ~s && et.splice(s, a ? 6 : 2),
        i && (a ? ci.unshift($e, i, _t, i, Ii, i) : ci.unshift(r, i))
    }
    ,
    o.clearMatchMedia = function(n) {
        Xe.forEach(function(i) {
            return i._ctx && i._ctx.query === n && i._ctx.kill(!0, !0)
        })
    }
    ,
    o.isInViewport = function(n, i, r) {
        var s = (ii(n) ? an(n) : n).getBoundingClientRect()
          , a = s[r ? Wr : jr] * i || 0;
        return r ? s.right - a > 0 && s.left + a < $e.innerWidth : s.bottom - a > 0 && s.top + a < $e.innerHeight
    }
    ,
    o.positionInViewport = function(n, i, r) {
        ii(n) && (n = an(n));
        var s = n.getBoundingClientRect()
          , a = s[r ? Wr : jr]
          , l = i == null ? a / 2 : i in Fl ? Fl[i] * a : ~i.indexOf("%") ? parseFloat(i) * a / 100 : parseFloat(i) || 0;
        return r ? (s.left + l) / $e.innerWidth : (s.top + l) / $e.innerHeight
    }
    ,
    o.killAll = function(n) {
        if (Xe.forEach(function(r) {
            return r.vars.id !== "ScrollSmoother" && r.kill()
        }),
        n !== !0) {
            var i = Zr.killAll || [];
            Zr = {},
            i.forEach(function(r) {
                return r()
            })
        }
    }
    ,
    o
}();
nt.version = "3.11.1";
nt.saveStyles = function(o) {
    return o ? Il(o).forEach(function(e) {
        if (e && e.style) {
            var t = yn.indexOf(e);
            t >= 0 && yn.splice(t, 5),
            yn.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), Ae.core.getCache(e), _c())
        }
    }) : yn
}
;
nt.revert = function(o, e) {
    return oh(!o, e)
}
;
nt.create = function(o, e) {
    return new nt(o,e)
}
;
nt.refresh = function(o) {
    return o ? Lo() : (As || nt.register()) && Os(!0)
}
;
nt.update = na;
nt.clearScrollMemory = eg;
nt.maxScroll = function(o, e) {
    return or(o, e ? Jt : Pt)
}
;
nt.getScrollFunc = function(o, e) {
    return dr(an(o), e ? Jt : Pt)
}
;
nt.getById = function(o) {
    return xc[o]
}
;
nt.getAll = function() {
    return Xe.filter(function(o) {
        return o.vars.id !== "ScrollSmoother"
    })
}
;
nt.isScrolling = function() {
    return !!Hn
}
;
nt.snapDirectional = sh;
nt.addEventListener = function(o, e) {
    var t = Zr[o] || (Zr[o] = []);
    ~t.indexOf(e) || t.push(e)
}
;
nt.removeEventListener = function(o, e) {
    var t = Zr[o]
      , n = t && t.indexOf(e);
    n >= 0 && t.splice(n, 1)
}
;
nt.batch = function(o, e) {
    var t = [], n = {}, i = e.interval || .016, r = e.batchMax || 1e9, s = function(u, c) {
        var h = []
          , f = []
          , m = Ae.delayedCall(i, function() {
            c(h, f),
            h = [],
            f = []
        }).pause();
        return function(_) {
            h.length || m.restart(!0),
            h.push(_.trigger),
            f.push(_),
            r <= h.length && m.progress(1)
        }
    }, a;
    for (a in e)
        n[a] = a.substr(0, 2) === "on" && Fi(e[a]) && a !== "onRefreshInit" ? s(a, e[a]) : e[a];
    return Fi(r) && (r = r(),
    Ut(nt, "refresh", function() {
        return r = e.batchMax()
    })),
    Il(o).forEach(function(l) {
        var u = {};
        for (a in n)
            u[a] = n[a];
        u.trigger = l,
        t.push(nt.create(u))
    }),
    t
}
;
var hf = function(e, t, n, i) {
    return t > i ? e(i) : t < 0 && e(0),
    n > i ? (i - t) / (n - t) : n < 0 ? t / (t - n) : 1
}, fu = function o(e, t) {
    t === !0 ? e.style.removeProperty("touch-action") : e.style.touchAction = t === !0 ? "auto" : t ? "pan-" + t + (At.isTouch ? " pinch-zoom" : "") : "none",
    e === Ii && o(_t, t)
}, ff = {
    auto: 1,
    scroll: 1
}, av = function(e) {
    var t = e.event, n = e.target, i = e.axis, r = (t.changedTouches ? t.changedTouches[0] : t).target, s = r._gsap || Ae.core.getCache(r), a = Qt(), l;
    if (!s._isScrollT || a - s._isScrollT > 2e3) {
        for (; r && r.scrollHeight <= r.clientHeight; )
            r = r.parentNode;
        s._isScroll = r && !$r(r) && r !== n && (ff[(l = ai(r)).overflowY] || ff[l.overflowX]),
        s._isScrollT = a
    }
    (s._isScroll || i === "x") && (t.stopPropagation(),
    t._gsapAllow = !0)
}, tg = function(e, t, n, i) {
    return At.create({
        target: e,
        capture: !0,
        debounce: !1,
        lockAxis: !0,
        type: t,
        onWheel: i = i && av,
        onPress: i,
        onDrag: i,
        onScroll: i,
        onEnable: function() {
            return n && Ut(gt, At.eventTypes[0], pf, !1, !0)
        },
        onDisable: function() {
            return Nt(gt, At.eventTypes[0], pf, !0)
        }
    })
}, lv = /(input|label|select|textarea)/i, df, pf = function(e) {
    var t = lv.test(e.target.tagName);
    (t || df) && (e._gsapAllow = !0,
    df = t)
}, uv = function(e) {
    fl(e) || (e = {}),
    e.preventDefault = e.isNormalizer = e.allowClicks = !0,
    e.type || (e.type = "wheel,touch"),
    e.debounce = !!e.debounce,
    e.id = e.id || "normalizer";
    var t = e, n = t.normalizeScrollX, i = t.momentum, r = t.allowNestedScroll, s, a, l = an(e.target) || Ii, u = Ae.core.globals().ScrollSmoother, c = u && u.get(), h = nr && (e.content && an(e.content) || c && e.content !== !1 && !c.smooth() && c.content()), f = dr(l, Pt), m = dr(l, Jt), _ = 1, d = (At.isTouch && $e.visualViewport ? $e.visualViewport.scale * $e.visualViewport.width : $e.outerWidth) / $e.innerWidth, p = 0, v = Fi(i) ? function() {
        return i(s)
    }
    : function() {
        return i || 2.8
    }
    , x, S, M = tg(l, e.type, !0, r), T = function() {
        return S = !1
    }, L = ri, P = ri, A = function() {
        a = or(l, Pt),
        P = Fs(nr ? 1 : 0, a),
        n && (L = Fs(0, or(l, Jt))),
        x = ml
    }, C = function() {
        h._gsap.y = Ao(parseFloat(h._gsap.y) + f.offset) + "px",
        h.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(h._gsap.y) + ", 0, 1)",
        f.offset = f.cacheID = 0
    }, N = function() {
        if (S) {
            requestAnimationFrame(T);
            var z = Ao(s.deltaY / 2)
              , b = P(f.v - z);
            if (h && b !== f.v + f.offset) {
                f.offset = b - f.v;
                var y = Ao((parseFloat(h && h._gsap.y) || 0) - f.offset);
                h.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + y + ", 0, 1)",
                h._gsap.y = y + "px",
                f.cacheID = et.cache,
                na()
            }
            return !0
        }
        f.offset && C(),
        S = !0
    }, G, q, g, w, E = function() {
        A(),
        G.isActive() && G.vars.scrollY > a && (f() > a ? G.progress(1) && f(a) : G.resetTo("scrollY", a))
    };
    return h && Ae.set(h, {
        y: "+=0"
    }),
    e.ignoreCheck = function(R) {
        return nr && R.type === "touchmove" && N() || _ > 1.05 && R.type !== "touchstart" || s.isGesturing || R.touches && R.touches.length > 1
    }
    ,
    e.onPress = function() {
        var R = _;
        _ = Ao(($e.visualViewport && $e.visualViewport.scale || 1) / d),
        G.pause(),
        R !== _ && fu(l, _ > 1.01 ? !0 : n ? !1 : "x"),
        q = m(),
        g = f(),
        A(),
        x = ml
    }
    ,
    e.onRelease = e.onGestureStart = function(R, z) {
        if (f.offset && C(),
        !z)
            w.restart(!0);
        else {
            et.cache++;
            var b = v(), y, D;
            n && (y = m(),
            D = y + b * .05 * -R.velocityX / .227,
            b *= hf(m, y, D, or(l, Jt)),
            G.vars.scrollX = L(D)),
            y = f(),
            D = y + b * .05 * -R.velocityY / .227,
            b *= hf(f, y, D, or(l, Pt)),
            G.vars.scrollY = P(D),
            G.invalidate().duration(b).play(.01),
            (nr && G.vars.scrollY >= a || y >= a - 1) && Ae.to({}, {
                onUpdate: E,
                duration: b
            })
        }
    }
    ,
    e.onWheel = function() {
        G._ts && G.pause(),
        Qt() - p > 1e3 && (x = 0,
        p = Qt())
    }
    ,
    e.onChange = function(R, z, b, y, D) {
        if (ml !== x && A(),
        z && n && m(L(y[2] === z ? q + (R.startX - R.x) : m() + z - y[1])),
        b) {
            f.offset && C();
            var I = D[2] === b
              , F = I ? g + R.startY - R.y : f() + b - D[1]
              , B = P(F);
            I && F !== B && (g += B - F),
            f(B)
        }
        (b || z) && na()
    }
    ,
    e.onEnable = function() {
        fu(l, n ? !1 : "x"),
        Ut($e, "resize", E),
        M.enable()
    }
    ,
    e.onDisable = function() {
        fu(l, !0),
        Nt($e, "resize", E),
        M.kill()
    }
    ,
    e.lockAxis = e.lockAxis !== !1,
    s = new At(e),
    s.iOS = nr,
    nr && !f() && f(1),
    nr && Ae.ticker.add(ri),
    w = s._dc,
    G = Ae.to(s, {
        ease: "power4",
        paused: !0,
        scrollX: n ? "+=0.1" : "+=0",
        scrollY: "+=0.1",
        onComplete: w.vars.onComplete
    }),
    s
};
nt.sort = function(o) {
    return Xe.sort(o || function(e, t) {
        return (e.vars.refreshPriority || 0) * -1e6 + e.start - (t.start + (t.vars.refreshPriority || 0) * -1e6)
    }
    )
}
;
nt.observe = function(o) {
    return new At(o)
}
;
nt.normalizeScroll = function(o) {
    if (typeof o > "u")
        return In;
    if (o === !0 && In)
        return In.enable();
    if (o === !1)
        return In && In.kill();
    var e = o instanceof At ? o : uv(o);
    return In && In.target === e.target && In.kill(),
    $r(e.target) && (In = e),
    e
}
;
nt.core = {
    _getVelocityProp: mc,
    _inputObserver: tg,
    _scrollers: et,
    _proxies: ci,
    bridge: {
        ss: function() {
            Hn || Qr("scrollStart"),
            Hn = Qt()
        },
        ref: function() {
            return zt
        }
    }
};
Xm() && Ae.registerPlugin(nt);
/*!
 * strings: 3.11.1
 * https://greensock.com
 *
 * Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var cv = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;
function ng(o) {
    var e = o.nodeType
      , t = "";
    if (e === 1 || e === 9 || e === 11) {
        if (typeof o.textContent == "string")
            return o.textContent;
        for (o = o.firstChild; o; o = o.nextSibling)
            t += ng(o)
    } else if (e === 3 || e === 4)
        return o.nodeValue;
    return t
}
/*!
 * SplitText: 3.11.1
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var Nr, ig, rg, hv = /(?:\r|\n|\t\t)/g, fv = /(?:\s\s+)/g, dv = function() {
    Nr = document,
    ig = window,
    rg = 1
}, sg = function(e) {
    return ig.getComputedStyle(e)
}, pv = Array.isArray, mf = [].slice, ah = function(e, t) {
    var n;
    return pv(e) ? e : (n = typeof e) == "string" && !t && e ? mf.call(Nr.querySelectorAll(e), 0) : e && n === "object" && "length"in e ? mf.call(e, 0) : e ? [e] : []
}, lh = function(e) {
    return e.position === "absolute" || e.absolute === !0
}, mv = function(e, t) {
    for (var n = t.length, i; --n > -1; )
        if (i = t[n],
        e.substr(0, i.length) === i)
            return i.length
}, gv = " style='position:relative;display:inline-block;'", gf = function(e, t) {
    e === void 0 && (e = "");
    var n = ~e.indexOf("++")
      , i = 1;
    return n && (e = e.split("++").join("")),
    function() {
        return "<" + t + gv + (e ? " class='" + e + (n ? i++ : "") + "'>" : ">")
    }
}, og = function o(e, t, n) {
    var i = e.nodeType;
    if (i === 1 || i === 9 || i === 11)
        for (e = e.firstChild; e; e = e.nextSibling)
            o(e, t, n);
    else
        (i === 3 || i === 4) && (e.nodeValue = e.nodeValue.split(t).join(n))
}, du = function(e, t) {
    for (var n = t.length; --n > -1; )
        e.push(t[n])
}, _f = function(e, t, n) {
    for (var i; e && e !== t; ) {
        if (i = e._next || e.nextSibling,
        i)
            return i.textContent.charAt(0) === n;
        e = e.parentNode || e._parent
    }
}, _v = function o(e) {
    var t = ah(e.childNodes), n = t.length, i, r;
    for (i = 0; i < n; i++)
        r = t[i],
        r._isSplit ? o(r) : i && r.previousSibling && r.previousSibling.nodeType === 3 ? (r.previousSibling.nodeValue += r.nodeType === 3 ? r.nodeValue : r.firstChild.nodeValue,
        e.removeChild(r)) : r.nodeType !== 3 && (e.insertBefore(r.firstChild, r),
        e.removeChild(r))
}, ni = function(e, t) {
    return parseFloat(t[e]) || 0
}, vv = function(e, t, n, i, r, s, a) {
    var l = sg(e), u = ni("paddingLeft", l), c = -999, h = ni("borderBottomWidth", l) + ni("borderTopWidth", l), f = ni("borderLeftWidth", l) + ni("borderRightWidth", l), m = ni("paddingTop", l) + ni("paddingBottom", l), _ = ni("paddingLeft", l) + ni("paddingRight", l), d = ni("fontSize", l) * (t.lineThreshold || .2), p = l.textAlign, v = [], x = [], S = [], M = t.wordDelimiter || " ", T = t.tag ? t.tag : t.span ? "span" : "div", L = t.type || t.split || "chars,words,lines", P = r && ~L.indexOf("lines") ? [] : null, A = ~L.indexOf("words"), C = ~L.indexOf("chars"), N = lh(t), G = t.linesClass, q = ~(G || "").indexOf("++"), g = [], w = l.display === "flex", E = e.style.display, R, z, b, y, D, I, F, B, H, W, U, K;
    for (q && (G = G.split("++").join("")),
    w && (e.style.display = "block"),
    z = e.getElementsByTagName("*"),
    b = z.length,
    D = [],
    R = 0; R < b; R++)
        D[R] = z[R];
    if (P || N)
        for (R = 0; R < b; R++)
            y = D[R],
            I = y.parentNode === e,
            (I || N || C && !A) && (K = y.offsetTop,
            P && I && Math.abs(K - c) > d && (y.nodeName !== "BR" || R === 0) && (F = [],
            P.push(F),
            c = K),
            N && (y._x = y.offsetLeft,
            y._y = K,
            y._w = y.offsetWidth,
            y._h = y.offsetHeight),
            P && ((y._isSplit && I || !C && I || A && I || !A && y.parentNode.parentNode === e && !y.parentNode._isSplit) && (F.push(y),
            y._x -= u,
            _f(y, e, M) && (y._wordEnd = !0)),
            y.nodeName === "BR" && (y.nextSibling && y.nextSibling.nodeName === "BR" || R === 0) && P.push([])));
    for (R = 0; R < b; R++) {
        if (y = D[R],
        I = y.parentNode === e,
        y.nodeName === "BR") {
            P || N ? (y.parentNode && y.parentNode.removeChild(y),
            D.splice(R--, 1),
            b--) : A || e.appendChild(y);
            continue
        }
        if (N && (H = y.style,
        !A && !I && (y._x += y.parentNode._x,
        y._y += y.parentNode._y),
        H.left = y._x + "px",
        H.top = y._y + "px",
        H.position = "absolute",
        H.display = "block",
        H.width = y._w + 1 + "px",
        H.height = y._h + "px"),
        !A && C)
            if (y._isSplit)
                for (y._next = z = y.nextSibling,
                y.parentNode.appendChild(y); z && z.nodeType === 3 && z.textContent === " "; )
                    y._next = z.nextSibling,
                    y.parentNode.appendChild(z),
                    z = z.nextSibling;
            else
                y.parentNode._isSplit ? (y._parent = y.parentNode,
                !y.previousSibling && y.firstChild && (y.firstChild._isFirst = !0),
                y.nextSibling && y.nextSibling.textContent === " " && !y.nextSibling.nextSibling && g.push(y.nextSibling),
                y._next = y.nextSibling && y.nextSibling._isFirst ? null : y.nextSibling,
                y.parentNode.removeChild(y),
                D.splice(R--, 1),
                b--) : I || (K = !y.nextSibling && _f(y.parentNode, e, M),
                y.parentNode._parent && y.parentNode._parent.appendChild(y),
                K && y.parentNode.appendChild(Nr.createTextNode(" ")),
                T === "span" && (y.style.display = "inline"),
                v.push(y));
        else
            y.parentNode._isSplit && !y._isSplit && y.innerHTML !== "" ? x.push(y) : C && !y._isSplit && (T === "span" && (y.style.display = "inline"),
            v.push(y))
    }
    for (R = g.length; --R > -1; )
        g[R].parentNode.removeChild(g[R]);
    if (P) {
        for (N && (W = Nr.createElement(T),
        e.appendChild(W),
        U = W.offsetWidth + "px",
        K = W.offsetParent === e ? 0 : e.offsetLeft,
        e.removeChild(W)),
        H = e.style.cssText,
        e.style.cssText = "display:none;"; e.firstChild; )
            e.removeChild(e.firstChild);
        for (B = M === " " && (!N || !A && !C),
        R = 0; R < P.length; R++) {
            for (F = P[R],
            W = Nr.createElement(T),
            W.style.cssText = "display:block;text-align:" + p + ";position:" + (N ? "absolute;" : "relative;"),
            G && (W.className = G + (q ? R + 1 : "")),
            S.push(W),
            b = F.length,
            z = 0; z < b; z++)
                F[z].nodeName !== "BR" && (y = F[z],
                W.appendChild(y),
                B && y._wordEnd && W.appendChild(Nr.createTextNode(" ")),
                N && (z === 0 && (W.style.top = y._y + "px",
                W.style.left = u + K + "px"),
                y.style.top = "0px",
                K && (y.style.left = y._x - K + "px")));
            b === 0 ? W.innerHTML = "&nbsp;" : !A && !C && (_v(W),
            og(W, String.fromCharCode(160), " ")),
            N && (W.style.width = U,
            W.style.height = y._h + "px"),
            e.appendChild(W)
        }
        e.style.cssText = H
    }
    N && (a > e.clientHeight && (e.style.height = a - m + "px",
    e.clientHeight < a && (e.style.height = a + h + "px")),
    s > e.clientWidth && (e.style.width = s - _ + "px",
    e.clientWidth < s && (e.style.width = s + f + "px"))),
    w && (E ? e.style.display = E : e.style.removeProperty("display")),
    du(n, v),
    A && du(i, x),
    du(r, S)
}, xv = function(e, t, n, i) {
    var r = t.tag ? t.tag : t.span ? "span" : "div", s = t.type || t.split || "chars,words,lines", a = ~s.indexOf("chars"), l = lh(t), u = t.wordDelimiter || " ", c = u !== " " ? "" : l ? "&#173; " : " ", h = "</" + r + ">", f = 1, m = t.specialChars ? typeof t.specialChars == "function" ? t.specialChars : mv : null, _, d, p, v, x, S, M, T, L = Nr.createElement("div"), P = e.parentNode;
    for (P.insertBefore(L, e),
    L.textContent = e.nodeValue,
    P.removeChild(e),
    e = L,
    _ = ng(e),
    M = _.indexOf("<") !== -1,
    t.reduceWhiteSpace !== !1 && (_ = _.replace(fv, " ").replace(hv, "")),
    M && (_ = _.split("<").join("{{LT}}")),
    x = _.length,
    d = (_.charAt(0) === " " ? c : "") + n(),
    p = 0; p < x; p++)
        if (S = _.charAt(p),
        m && (T = m(_.substr(p), t.specialChars)))
            S = _.substr(p, T || 1),
            d += a && S !== " " ? i() + S + "</" + r + ">" : S,
            p += T - 1;
        else if (S === u && _.charAt(p - 1) !== u && p) {
            for (d += f ? h : "",
            f = 0; _.charAt(p + 1) === u; )
                d += c,
                p++;
            p === x - 1 ? d += c : _.charAt(p + 1) !== ")" && (d += c + n(),
            f = 1)
        } else
            S === "{" && _.substr(p, 6) === "{{LT}}" ? (d += a ? i() + "{{LT}}</" + r + ">" : "{{LT}}",
            p += 5) : S.charCodeAt(0) >= 55296 && S.charCodeAt(0) <= 56319 || _.charCodeAt(p + 1) >= 65024 && _.charCodeAt(p + 1) <= 65039 ? (v = ((_.substr(p, 12).split(cv) || [])[1] || "").length || 2,
            d += a && S !== " " ? i() + _.substr(p, v) + "</" + r + ">" : _.substr(p, v),
            p += v - 1) : d += a && S !== " " ? i() + S + "</" + r + ">" : S;
    e.outerHTML = d + (f ? h : ""),
    M && og(P, "{{LT}}", "<")
}, yv = function o(e, t, n, i) {
    var r = ah(e.childNodes), s = r.length, a = lh(t), l, u;
    if (e.nodeType !== 3 || s > 1) {
        for (t.absolute = !1,
        l = 0; l < s; l++)
            u = r[l],
            u._next = u._isFirst = u._parent = u._wordEnd = null,
            (u.nodeType !== 3 || /\S+/.test(u.nodeValue)) && (a && u.nodeType !== 3 && sg(u).display === "inline" && (u.style.display = "inline-block",
            u.style.position = "relative"),
            u._isSplit = !0,
            o(u, t, n, i));
        t.absolute = a,
        e._isSplit = !0;
        return
    }
    xv(e, t, n, i)
}, bv = function() {
    function o(t, n) {
        rg || dv(),
        this.elements = ah(t),
        this.chars = [],
        this.words = [],
        this.lines = [],
        this._originals = [],
        this.vars = n || {},
        this.split(n)
    }
    var e = o.prototype;
    return e.split = function(n) {
        this.isSplit && this.revert(),
        this.vars = n = n || this.vars,
        this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
        for (var i = this.elements.length, r = n.tag ? n.tag : n.span ? "span" : "div", s = gf(n.wordsClass, r), a = gf(n.charsClass, r), l, u, c; --i > -1; )
            c = this.elements[i],
            this._originals[i] = c.innerHTML,
            l = c.clientHeight,
            u = c.clientWidth,
            yv(c, n, s, a),
            vv(c, n, this.chars, this.words, this.lines, u, l);
        return this.chars.reverse(),
        this.words.reverse(),
        this.lines.reverse(),
        this.isSplit = !0,
        this
    }
    ,
    e.revert = function() {
        var n = this._originals;
        if (!n)
            throw "revert() call wasn't scoped properly.";
        return this.elements.forEach(function(i, r) {
            return i.innerHTML = n[r]
        }),
        this.chars = [],
        this.words = [],
        this.lines = [],
        this.isSplit = !1,
        this
    }
    ,
    o.create = function(n, i) {
        return new o(n,i)
    }
    ,
    o
}();
bv.version = "3.11.1";
if (typeof window < "u")
    try {
        document.querySelector(":scope *")
    } catch {
        (function(e) {
            var t = /:scope(?![\w-])/gi
              , n = a(e.querySelector);
            e.querySelector = function(u) {
                return n.apply(this, arguments)
            }
            ;
            var i = a(e.querySelectorAll);
            if (e.querySelectorAll = function(u) {
                return i.apply(this, arguments)
            }
            ,
            e.matches) {
                var r = a(e.matches);
                e.matches = function(u) {
                    return r.apply(this, arguments)
                }
            }
            if (e.closest) {
                var s = a(e.closest);
                e.closest = function(u) {
                    return s.apply(this, arguments)
                }
            }
            function a(l) {
                return function(u) {
                    var c = u && t.test(u);
                    if (c) {
                        var h = "q" + Math.floor(Math.random() * 9e6) + 1e6;
                        arguments[0] = u.replace(t, "[" + h + "]"),
                        this.setAttribute(h, "");
                        var f = l.apply(this, arguments);
                        return this.removeAttribute(h),
                        f
                    } else
                        return l.apply(this, arguments)
                }
            }
        }
        )(Element.prototype)
    }
var hi = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}
  , ag = {
    exports: {}
};
/*!
 * EventEmitter2
 * https://github.com/hij1nx/EventEmitter2
 *
 * Copyright (c) 2013 hij1nx
 * Licensed under the MIT license.
 */
(function(o, e) {
    (function(t) {
        var n = Object.hasOwnProperty
          , i = Array.isArray ? Array.isArray : function(y) {
            return Object.prototype.toString.call(y) === "[object Array]"
        }
          , r = 10
          , s = typeof process == "object" && typeof process.nextTick == "function"
          , a = typeof Symbol == "function"
          , l = typeof Reflect == "object"
          , u = typeof setImmediate == "function"
          , c = u ? setImmediate : setTimeout
          , h = a ? l && typeof Reflect.ownKeys == "function" ? Reflect.ownKeys : function(b) {
            var y = Object.getOwnPropertyNames(b);
            return y.push.apply(y, Object.getOwnPropertySymbols(b)),
            y
        }
        : Object.keys;
        function f() {
            this._events = {},
            this._conf && m.call(this, this._conf)
        }
        function m(b) {
            b && (this._conf = b,
            b.delimiter && (this.delimiter = b.delimiter),
            b.maxListeners !== t && (this._maxListeners = b.maxListeners),
            b.wildcard && (this.wildcard = b.wildcard),
            b.newListener && (this._newListener = b.newListener),
            b.removeListener && (this._removeListener = b.removeListener),
            b.verboseMemoryLeak && (this.verboseMemoryLeak = b.verboseMemoryLeak),
            b.ignoreErrors && (this.ignoreErrors = b.ignoreErrors),
            this.wildcard && (this.listenerTree = {}))
        }
        function _(b, y) {
            var D = "(node) warning: possible EventEmitter memory leak detected. " + b + " listeners added. Use emitter.setMaxListeners() to increase limit.";
            if (this.verboseMemoryLeak && (D += " Event name: " + y + "."),
            typeof process < "u" && process.emitWarning) {
                var I = new Error(D);
                I.name = "MaxListenersExceededWarning",
                I.emitter = this,
                I.count = b,
                process.emitWarning(I)
            } else
                console.error(D),
                console.trace && console.trace()
        }
        var d = function(b, y, D) {
            var I = arguments.length;
            switch (I) {
            case 0:
                return [];
            case 1:
                return [b];
            case 2:
                return [b, y];
            case 3:
                return [b, y, D];
            default:
                for (var F = new Array(I); I--; )
                    F[I] = arguments[I];
                return F
            }
        };
        function p(b, y) {
            for (var D = {}, I, F = b.length, B = y ? y.length : 0, H = 0; H < F; H++)
                I = b[H],
                D[I] = H < B ? y[H] : t;
            return D
        }
        function v(b, y, D) {
            this._emitter = b,
            this._target = y,
            this._listeners = {},
            this._listenersCount = 0;
            var I, F;
            if ((D.on || D.off) && (I = D.on,
            F = D.off),
            y.addEventListener ? (I = y.addEventListener,
            F = y.removeEventListener) : y.addListener ? (I = y.addListener,
            F = y.removeListener) : y.on && (I = y.on,
            F = y.off),
            !I && !F)
                throw Error("target does not implement any known event API");
            if (typeof I != "function")
                throw TypeError("on method must be a function");
            if (typeof F != "function")
                throw TypeError("off method must be a function");
            this._on = I,
            this._off = F;
            var B = b._observers;
            B ? B.push(this) : b._observers = [this]
        }
        Object.assign(v.prototype, {
            subscribe: function(b, y, D) {
                var I = this
                  , F = this._target
                  , B = this._emitter
                  , H = this._listeners
                  , W = function() {
                    var U = d.apply(null, arguments)
                      , K = {
                        data: U,
                        name: y,
                        original: b
                    };
                    if (D) {
                        var te = D.call(F, K);
                        te !== !1 && B.emit.apply(B, [K.name].concat(U));
                        return
                    }
                    B.emit.apply(B, [y].concat(U))
                };
                if (H[b])
                    throw Error("Event '" + b + "' is already listening");
                this._listenersCount++,
                B._newListener && B._removeListener && !I._onNewListener ? (this._onNewListener = function(U) {
                    U === y && H[b] === null && (H[b] = W,
                    I._on.call(F, b, W))
                }
                ,
                B.on("newListener", this._onNewListener),
                this._onRemoveListener = function(U) {
                    U === y && !B.hasListeners(U) && H[b] && (H[b] = null,
                    I._off.call(F, b, W))
                }
                ,
                H[b] = null,
                B.on("removeListener", this._onRemoveListener)) : (H[b] = W,
                I._on.call(F, b, W))
            },
            unsubscribe: function(b) {
                var y = this, D = this._listeners, I = this._emitter, F, B, H = this._off, W = this._target, U;
                if (b && typeof b != "string")
                    throw TypeError("event must be a string");
                function K() {
                    y._onNewListener && (I.off("newListener", y._onNewListener),
                    I.off("removeListener", y._onRemoveListener),
                    y._onNewListener = null,
                    y._onRemoveListener = null);
                    var te = A.call(I, y);
                    I._observers.splice(te, 1)
                }
                if (b) {
                    if (F = D[b],
                    !F)
                        return;
                    H.call(W, b, F),
                    delete D[b],
                    --this._listenersCount || K()
                } else {
                    for (B = h(D),
                    U = B.length; U-- > 0; )
                        b = B[U],
                        H.call(W, b, D[b]);
                    this._listeners = {},
                    this._listenersCount = 0,
                    K()
                }
            }
        });
        function x(b, y, D, I) {
            var F = Object.assign({}, y);
            if (!b)
                return F;
            if (typeof b != "object")
                throw TypeError("options must be an object");
            var B = Object.keys(b), H = B.length, W, U, K;
            function te(ne) {
                throw Error('Invalid "' + W + '" option value' + (ne ? ". Reason: " + ne : ""))
            }
            for (var he = 0; he < H; he++) {
                if (W = B[he],
                !I && !n.call(y, W))
                    throw Error('Unknown "' + W + '" option');
                U = b[W],
                U !== t && (K = D[W],
                F[W] = K ? K(U, te) : U)
            }
            return F
        }
        function S(b, y) {
            return (typeof b != "function" || !b.hasOwnProperty("prototype")) && y("value must be a constructor"),
            b
        }
        function M(b) {
            var y = "value must be type of " + b.join("|")
              , D = b.length
              , I = b[0]
              , F = b[1];
            return D === 1 ? function(B, H) {
                if (typeof B === I)
                    return B;
                H(y)
            }
            : D === 2 ? function(B, H) {
                var W = typeof B;
                if (W === I || W === F)
                    return B;
                H(y)
            }
            : function(B, H) {
                for (var W = typeof B, U = D; U-- > 0; )
                    if (W === b[U])
                        return B;
                H(y)
            }
        }
        var T = M(["function"])
          , L = M(["object", "function"]);
        function P(b, y, D) {
            var I, F, B = 0, H, W = new b(function(U, K, te) {
                D = x(D, {
                    timeout: 0,
                    overload: !1
                }, {
                    timeout: function(oe, ue) {
                        return oe *= 1,
                        (typeof oe != "number" || oe < 0 || !Number.isFinite(oe)) && ue("timeout must be a positive number"),
                        oe
                    }
                }),
                I = !D.overload && typeof b.prototype.cancel == "function" && typeof te == "function";
                function he() {
                    F && (F = null),
                    B && (clearTimeout(B),
                    B = 0)
                }
                var ne = function(oe) {
                    he(),
                    U(oe)
                }
                  , ce = function(oe) {
                    he(),
                    K(oe)
                };
                I ? y(ne, ce, te) : (F = [function(oe) {
                    ce(oe || Error("canceled"))
                }
                ],
                y(ne, ce, function(oe) {
                    if (H)
                        throw Error("Unable to subscribe on cancel event asynchronously");
                    if (typeof oe != "function")
                        throw TypeError("onCancel callback must be a function");
                    F.push(oe)
                }),
                H = !0),
                D.timeout > 0 && (B = setTimeout(function() {
                    var oe = Error("timeout");
                    oe.code = "ETIMEDOUT",
                    B = 0,
                    W.cancel(oe),
                    K(oe)
                }, D.timeout))
            }
            );
            return I || (W.cancel = function(U) {
                if (!!F) {
                    for (var K = F.length, te = 1; te < K; te++)
                        F[te](U);
                    F[0](U),
                    F = null
                }
            }
            ),
            W
        }
        function A(b) {
            var y = this._observers;
            if (!y)
                return -1;
            for (var D = y.length, I = 0; I < D; I++)
                if (y[I]._target === b)
                    return I;
            return -1
        }
        function C(b, y, D, I, F) {
            if (!D)
                return null;
            if (I === 0) {
                var B = typeof y;
                if (B === "string") {
                    var H, W, U = 0, K = 0, te = this.delimiter, he = te.length;
                    if ((W = y.indexOf(te)) !== -1) {
                        H = new Array(5);
                        do
                            H[U++] = y.slice(K, W),
                            K = W + he;
                        while ((W = y.indexOf(te, K)) !== -1);
                        H[U++] = y.slice(K),
                        y = H,
                        F = U
                    } else
                        y = [y],
                        F = 1
                } else
                    B === "object" ? F = y.length : (y = [y],
                    F = 1)
            }
            var ne = null, ce, oe, ue, Oe, qe, Ue = y[I], J = y[I + 1], Ve, ye;
            if (I === F)
                D._listeners && (typeof D._listeners == "function" ? (b && b.push(D._listeners),
                ne = [D]) : (b && b.push.apply(b, D._listeners),
                ne = [D]));
            else if (Ue === "*") {
                for (Ve = h(D),
                W = Ve.length; W-- > 0; )
                    ce = Ve[W],
                    ce !== "_listeners" && (ye = C(b, y, D[ce], I + 1, F),
                    ye && (ne ? ne.push.apply(ne, ye) : ne = ye));
                return ne
            } else if (Ue === "**") {
                for (qe = I + 1 === F || I + 2 === F && J === "*",
                qe && D._listeners && (ne = C(b, y, D, F, F)),
                Ve = h(D),
                W = Ve.length; W-- > 0; )
                    ce = Ve[W],
                    ce !== "_listeners" && (ce === "*" || ce === "**" ? (D[ce]._listeners && !qe && (ye = C(b, y, D[ce], F, F),
                    ye && (ne ? ne.push.apply(ne, ye) : ne = ye)),
                    ye = C(b, y, D[ce], I, F)) : ce === J ? ye = C(b, y, D[ce], I + 2, F) : ye = C(b, y, D[ce], I, F),
                    ye && (ne ? ne.push.apply(ne, ye) : ne = ye));
                return ne
            } else
                D[Ue] && (ne = C(b, y, D[Ue], I + 1, F));
            if (oe = D["*"],
            oe && C(b, y, oe, I + 1, F),
            ue = D["**"],
            ue)
                if (I < F)
                    for (ue._listeners && C(b, y, ue, F, F),
                    Ve = h(ue),
                    W = Ve.length; W-- > 0; )
                        ce = Ve[W],
                        ce !== "_listeners" && (ce === J ? C(b, y, ue[ce], I + 2, F) : ce === Ue ? C(b, y, ue[ce], I + 1, F) : (Oe = {},
                        Oe[ce] = ue[ce],
                        C(b, y, {
                            "**": Oe
                        }, I + 1, F)));
                else
                    ue._listeners ? C(b, y, ue, F, F) : ue["*"] && ue["*"]._listeners && C(b, y, ue["*"], F, F);
            return ne
        }
        function N(b, y, D) {
            var I = 0, F = 0, B, H = this.delimiter, W = H.length, U;
            if (typeof b == "string")
                if ((B = b.indexOf(H)) !== -1) {
                    U = new Array(5);
                    do
                        U[I++] = b.slice(F, B),
                        F = B + W;
                    while ((B = b.indexOf(H, F)) !== -1);
                    U[I++] = b.slice(F)
                } else
                    U = [b],
                    I = 1;
            else
                U = b,
                I = b.length;
            if (I > 1) {
                for (B = 0; B + 1 < I; B++)
                    if (U[B] === "**" && U[B + 1] === "**")
                        return
            }
            var K = this.listenerTree, te;
            for (B = 0; B < I; B++)
                if (te = U[B],
                K = K[te] || (K[te] = {}),
                B === I - 1)
                    return K._listeners ? (typeof K._listeners == "function" && (K._listeners = [K._listeners]),
                    D ? K._listeners.unshift(y) : K._listeners.push(y),
                    !K._listeners.warned && this._maxListeners > 0 && K._listeners.length > this._maxListeners && (K._listeners.warned = !0,
                    _.call(this, K._listeners.length, te))) : K._listeners = y,
                    !0;
            return !0
        }
        function G(b, y, D, I) {
            for (var F = h(b), B = F.length, H, W, U, K = b._listeners, te; B-- > 0; )
                W = F[B],
                H = b[W],
                W === "_listeners" ? U = D : U = D ? D.concat(W) : [W],
                te = I || typeof W == "symbol",
                K && y.push(te ? U : U.join(this.delimiter)),
                typeof H == "object" && G.call(this, H, y, U, te);
            return y
        }
        function q(b) {
            for (var y = h(b), D = y.length, I, F, B; D-- > 0; )
                F = y[D],
                I = b[F],
                I && (B = !0,
                F !== "_listeners" && !q(I) && delete b[F]);
            return B
        }
        function g(b, y, D) {
            this.emitter = b,
            this.event = y,
            this.listener = D
        }
        g.prototype.off = function() {
            return this.emitter.off(this.event, this.listener),
            this
        }
        ;
        function w(b, y, D) {
            if (D === !0)
                F = !0;
            else if (D === !1)
                I = !0;
            else {
                if (!D || typeof D != "object")
                    throw TypeError("options should be an object or true");
                var I = D.async
                  , F = D.promisify
                  , B = D.nextTick
                  , H = D.objectify
            }
            if (I || B || F) {
                var W = y
                  , U = y._origin || y;
                if (B && !s)
                    throw Error("process.nextTick is not supported");
                F === t && (F = y.constructor.name === "AsyncFunction"),
                y = function() {
                    var K = arguments
                      , te = this
                      , he = this.event;
                    return F ? B ? Promise.resolve() : new Promise(function(ne) {
                        c(ne)
                    }
                    ).then(function() {
                        return te.event = he,
                        W.apply(te, K)
                    }) : (B ? process.nextTick : c)(function() {
                        te.event = he,
                        W.apply(te, K)
                    })
                }
                ,
                y._async = !0,
                y._origin = U
            }
            return [y, H ? new g(this,b,y) : this]
        }
        function E(b) {
            this._events = {},
            this._newListener = !1,
            this._removeListener = !1,
            this.verboseMemoryLeak = !1,
            m.call(this, b)
        }
        E.EventEmitter2 = E,
        E.prototype.listenTo = function(b, y, D) {
            if (typeof b != "object")
                throw TypeError("target musts be an object");
            var I = this;
            D = x(D, {
                on: t,
                off: t,
                reducers: t
            }, {
                on: T,
                off: T,
                reducers: L
            });
            function F(B) {
                if (typeof B != "object")
                    throw TypeError("events must be an object");
                var H = D.reducers, W = A.call(I, b), U;
                W === -1 ? U = new v(I,b,D) : U = I._observers[W];
                for (var K = h(B), te = K.length, he, ne = typeof H == "function", ce = 0; ce < te; ce++)
                    he = K[ce],
                    U.subscribe(he, B[he] || he, ne ? H : H && H[he])
            }
            return i(y) ? F(p(y)) : F(typeof y == "string" ? p(y.split(/\s+/)) : y),
            this
        }
        ,
        E.prototype.stopListeningTo = function(b, y) {
            var D = this._observers;
            if (!D)
                return !1;
            var I = D.length, F, B = !1;
            if (b && typeof b != "object")
                throw TypeError("target should be an object");
            for (; I-- > 0; )
                F = D[I],
                (!b || F._target === b) && (F.unsubscribe(y),
                B = !0);
            return B
        }
        ,
        E.prototype.delimiter = ".",
        E.prototype.setMaxListeners = function(b) {
            b !== t && (this._maxListeners = b,
            this._conf || (this._conf = {}),
            this._conf.maxListeners = b)
        }
        ,
        E.prototype.getMaxListeners = function() {
            return this._maxListeners
        }
        ,
        E.prototype.event = "",
        E.prototype.once = function(b, y, D) {
            return this._once(b, y, !1, D)
        }
        ,
        E.prototype.prependOnceListener = function(b, y, D) {
            return this._once(b, y, !0, D)
        }
        ,
        E.prototype._once = function(b, y, D, I) {
            return this._many(b, 1, y, D, I)
        }
        ,
        E.prototype.many = function(b, y, D, I) {
            return this._many(b, y, D, !1, I)
        }
        ,
        E.prototype.prependMany = function(b, y, D, I) {
            return this._many(b, y, D, !0, I)
        }
        ,
        E.prototype._many = function(b, y, D, I, F) {
            var B = this;
            if (typeof D != "function")
                throw new Error("many only accepts instances of Function");
            function H() {
                return --y === 0 && B.off(b, H),
                D.apply(this, arguments)
            }
            return H._origin = D,
            this._on(b, H, I, F)
        }
        ,
        E.prototype.emit = function() {
            if (!this._events && !this._all)
                return !1;
            this._events || f.call(this);
            var b = arguments[0], y, D = this.wildcard, I, F, B, H, W;
            if (b === "newListener" && !this._newListener && !this._events.newListener)
                return !1;
            if (D && (y = b,
            b !== "newListener" && b !== "removeListener" && typeof b == "object")) {
                if (F = b.length,
                a) {
                    for (B = 0; B < F; B++)
                        if (typeof b[B] == "symbol") {
                            W = !0;
                            break
                        }
                }
                W || (b = b.join(this.delimiter))
            }
            var U = arguments.length, K;
            if (this._all && this._all.length)
                for (K = this._all.slice(),
                B = 0,
                F = K.length; B < F; B++)
                    switch (this.event = b,
                    U) {
                    case 1:
                        K[B].call(this, b);
                        break;
                    case 2:
                        K[B].call(this, b, arguments[1]);
                        break;
                    case 3:
                        K[B].call(this, b, arguments[1], arguments[2]);
                        break;
                    default:
                        K[B].apply(this, arguments)
                    }
            if (D)
                K = [],
                C.call(this, K, y, this.listenerTree, 0, F);
            else if (K = this._events[b],
            typeof K == "function") {
                switch (this.event = b,
                U) {
                case 1:
                    K.call(this);
                    break;
                case 2:
                    K.call(this, arguments[1]);
                    break;
                case 3:
                    K.call(this, arguments[1], arguments[2]);
                    break;
                default:
                    for (I = new Array(U - 1),
                    H = 1; H < U; H++)
                        I[H - 1] = arguments[H];
                    K.apply(this, I)
                }
                return !0
            } else
                K && (K = K.slice());
            if (K && K.length) {
                if (U > 3)
                    for (I = new Array(U - 1),
                    H = 1; H < U; H++)
                        I[H - 1] = arguments[H];
                for (B = 0,
                F = K.length; B < F; B++)
                    switch (this.event = b,
                    U) {
                    case 1:
                        K[B].call(this);
                        break;
                    case 2:
                        K[B].call(this, arguments[1]);
                        break;
                    case 3:
                        K[B].call(this, arguments[1], arguments[2]);
                        break;
                    default:
                        K[B].apply(this, I)
                    }
                return !0
            } else if (!this.ignoreErrors && !this._all && b === "error")
                throw arguments[1]instanceof Error ? arguments[1] : new Error("Uncaught, unspecified 'error' event.");
            return !!this._all
        }
        ,
        E.prototype.emitAsync = function() {
            if (!this._events && !this._all)
                return !1;
            this._events || f.call(this);
            var b = arguments[0], y = this.wildcard, D, I, F, B, H, W;
            if (b === "newListener" && !this._newListener && !this._events.newListener)
                return Promise.resolve([!1]);
            if (y && (D = b,
            b !== "newListener" && b !== "removeListener" && typeof b == "object")) {
                if (B = b.length,
                a) {
                    for (H = 0; H < B; H++)
                        if (typeof b[H] == "symbol") {
                            I = !0;
                            break
                        }
                }
                I || (b = b.join(this.delimiter))
            }
            var U = [], K = arguments.length, te;
            if (this._all)
                for (H = 0,
                B = this._all.length; H < B; H++)
                    switch (this.event = b,
                    K) {
                    case 1:
                        U.push(this._all[H].call(this, b));
                        break;
                    case 2:
                        U.push(this._all[H].call(this, b, arguments[1]));
                        break;
                    case 3:
                        U.push(this._all[H].call(this, b, arguments[1], arguments[2]));
                        break;
                    default:
                        U.push(this._all[H].apply(this, arguments))
                    }
            if (y ? (te = [],
            C.call(this, te, D, this.listenerTree, 0)) : te = this._events[b],
            typeof te == "function")
                switch (this.event = b,
                K) {
                case 1:
                    U.push(te.call(this));
                    break;
                case 2:
                    U.push(te.call(this, arguments[1]));
                    break;
                case 3:
                    U.push(te.call(this, arguments[1], arguments[2]));
                    break;
                default:
                    for (F = new Array(K - 1),
                    W = 1; W < K; W++)
                        F[W - 1] = arguments[W];
                    U.push(te.apply(this, F))
                }
            else if (te && te.length) {
                if (te = te.slice(),
                K > 3)
                    for (F = new Array(K - 1),
                    W = 1; W < K; W++)
                        F[W - 1] = arguments[W];
                for (H = 0,
                B = te.length; H < B; H++)
                    switch (this.event = b,
                    K) {
                    case 1:
                        U.push(te[H].call(this));
                        break;
                    case 2:
                        U.push(te[H].call(this, arguments[1]));
                        break;
                    case 3:
                        U.push(te[H].call(this, arguments[1], arguments[2]));
                        break;
                    default:
                        U.push(te[H].apply(this, F))
                    }
            } else if (!this.ignoreErrors && !this._all && b === "error")
                return arguments[1]instanceof Error ? Promise.reject(arguments[1]) : Promise.reject("Uncaught, unspecified 'error' event.");
            return Promise.all(U)
        }
        ,
        E.prototype.on = function(b, y, D) {
            return this._on(b, y, !1, D)
        }
        ,
        E.prototype.prependListener = function(b, y, D) {
            return this._on(b, y, !0, D)
        }
        ,
        E.prototype.onAny = function(b) {
            return this._onAny(b, !1)
        }
        ,
        E.prototype.prependAny = function(b) {
            return this._onAny(b, !0)
        }
        ,
        E.prototype.addListener = E.prototype.on,
        E.prototype._onAny = function(b, y) {
            if (typeof b != "function")
                throw new Error("onAny only accepts instances of Function");
            return this._all || (this._all = []),
            y ? this._all.unshift(b) : this._all.push(b),
            this
        }
        ,
        E.prototype._on = function(b, y, D, I) {
            if (typeof b == "function")
                return this._onAny(b, y),
                this;
            if (typeof y != "function")
                throw new Error("on only accepts instances of Function");
            this._events || f.call(this);
            var F = this, B;
            return I !== t && (B = w.call(this, b, y, I),
            y = B[0],
            F = B[1]),
            this._newListener && this.emit("newListener", b, y),
            this.wildcard ? (N.call(this, b, y, D),
            F) : (this._events[b] ? (typeof this._events[b] == "function" && (this._events[b] = [this._events[b]]),
            D ? this._events[b].unshift(y) : this._events[b].push(y),
            !this._events[b].warned && this._maxListeners > 0 && this._events[b].length > this._maxListeners && (this._events[b].warned = !0,
            _.call(this, this._events[b].length, b))) : this._events[b] = y,
            F)
        }
        ,
        E.prototype.off = function(b, y) {
            if (typeof y != "function")
                throw new Error("removeListener only takes instances of Function");
            var D, I = [];
            if (this.wildcard) {
                var F = typeof b == "string" ? b.split(this.delimiter) : b.slice();
                if (I = C.call(this, null, F, this.listenerTree, 0),
                !I)
                    return this
            } else {
                if (!this._events[b])
                    return this;
                D = this._events[b],
                I.push({
                    _listeners: D
                })
            }
            for (var B = 0; B < I.length; B++) {
                var H = I[B];
                if (D = H._listeners,
                i(D)) {
                    for (var W = -1, U = 0, K = D.length; U < K; U++)
                        if (D[U] === y || D[U].listener && D[U].listener === y || D[U]._origin && D[U]._origin === y) {
                            W = U;
                            break
                        }
                    if (W < 0)
                        continue;
                    return this.wildcard ? H._listeners.splice(W, 1) : this._events[b].splice(W, 1),
                    D.length === 0 && (this.wildcard ? delete H._listeners : delete this._events[b]),
                    this._removeListener && this.emit("removeListener", b, y),
                    this
                } else
                    (D === y || D.listener && D.listener === y || D._origin && D._origin === y) && (this.wildcard ? delete H._listeners : delete this._events[b],
                    this._removeListener && this.emit("removeListener", b, y))
            }
            return this.listenerTree && q(this.listenerTree),
            this
        }
        ,
        E.prototype.offAny = function(b) {
            var y = 0, D = 0, I;
            if (b && this._all && this._all.length > 0) {
                for (I = this._all,
                y = 0,
                D = I.length; y < D; y++)
                    if (b === I[y])
                        return I.splice(y, 1),
                        this._removeListener && this.emit("removeListenerAny", b),
                        this
            } else {
                if (I = this._all,
                this._removeListener)
                    for (y = 0,
                    D = I.length; y < D; y++)
                        this.emit("removeListenerAny", I[y]);
                this._all = []
            }
            return this
        }
        ,
        E.prototype.removeListener = E.prototype.off,
        E.prototype.removeAllListeners = function(b) {
            if (b === t)
                return !this._events || f.call(this),
                this;
            if (this.wildcard) {
                var y = C.call(this, null, b, this.listenerTree, 0), D, I;
                if (!y)
                    return this;
                for (I = 0; I < y.length; I++)
                    D = y[I],
                    D._listeners = null;
                this.listenerTree && q(this.listenerTree)
            } else
                this._events && (this._events[b] = null);
            return this
        }
        ,
        E.prototype.listeners = function(b) {
            var y = this._events, D, I, F, B, H;
            if (b === t) {
                if (this.wildcard)
                    throw Error("event name required for wildcard emitter");
                if (!y)
                    return [];
                for (D = h(y),
                B = D.length,
                F = []; B-- > 0; )
                    I = y[D[B]],
                    typeof I == "function" ? F.push(I) : F.push.apply(F, I);
                return F
            } else {
                if (this.wildcard) {
                    if (H = this.listenerTree,
                    !H)
                        return [];
                    var W = []
                      , U = typeof b == "string" ? b.split(this.delimiter) : b.slice();
                    return C.call(this, W, U, H, 0),
                    W
                }
                return y ? (I = y[b],
                I ? typeof I == "function" ? [I] : I : []) : []
            }
        }
        ,
        E.prototype.eventNames = function(b) {
            var y = this._events;
            return this.wildcard ? G.call(this, this.listenerTree, [], null, b) : y ? h(y) : []
        }
        ,
        E.prototype.listenerCount = function(b) {
            return this.listeners(b).length
        }
        ,
        E.prototype.hasListeners = function(b) {
            if (this.wildcard) {
                var y = []
                  , D = typeof b == "string" ? b.split(this.delimiter) : b.slice();
                return C.call(this, y, D, this.listenerTree, 0),
                y.length > 0
            }
            var I = this._events
              , F = this._all;
            return !!(F && F.length || I && (b === t ? h(I).length : I[b]))
        }
        ,
        E.prototype.listenersAny = function() {
            return this._all ? this._all : []
        }
        ,
        E.prototype.waitFor = function(b, y) {
            var D = this
              , I = typeof y;
            return I === "number" ? y = {
                timeout: y
            } : I === "function" && (y = {
                filter: y
            }),
            y = x(y, {
                timeout: 0,
                filter: t,
                handleError: !1,
                Promise,
                overload: !1
            }, {
                filter: T,
                Promise: S
            }),
            P(y.Promise, function(F, B, H) {
                function W() {
                    var U = y.filter;
                    if (!(U && !U.apply(D, arguments)))
                        if (D.off(b, W),
                        y.handleError) {
                            var K = arguments[0];
                            K ? B(K) : F(d.apply(null, arguments).slice(1))
                        } else
                            F(d.apply(null, arguments))
                }
                H(function() {
                    D.off(b, W)
                }),
                D._on(b, W, !1)
            }, {
                timeout: y.timeout,
                overload: y.overload
            })
        }
        ;
        function R(b, y, D) {
            D = x(D, {
                Promise,
                timeout: 0,
                overload: !1
            }, {
                Promise: S
            });
            var I = D.Promise;
            return P(I, function(F, B, H) {
                var W;
                if (typeof b.addEventListener == "function") {
                    W = function() {
                        F(d.apply(null, arguments))
                    }
                    ,
                    H(function() {
                        b.removeEventListener(y, W)
                    }),
                    b.addEventListener(y, W, {
                        once: !0
                    });
                    return
                }
                var U = function() {
                    K && b.removeListener("error", K),
                    F(d.apply(null, arguments))
                }, K;
                y !== "error" && (K = function(te) {
                    b.removeListener(y, U),
                    B(te)
                }
                ,
                b.once("error", K)),
                H(function() {
                    K && b.removeListener("error", K),
                    b.removeListener(y, U)
                }),
                b.once(y, U)
            }, {
                timeout: D.timeout,
                overload: D.overload
            })
        }
        var z = E.prototype;
        Object.defineProperties(E, {
            defaultMaxListeners: {
                get: function() {
                    return z._maxListeners
                },
                set: function(b) {
                    if (typeof b != "number" || b < 0 || Number.isNaN(b))
                        throw TypeError("n must be a non-negative number");
                    z._maxListeners = b
                },
                enumerable: !0
            },
            once: {
                value: R,
                writable: !0,
                configurable: !0
            }
        }),
        Object.defineProperties(z, {
            _maxListeners: {
                value: r,
                writable: !0,
                configurable: !0
            },
            _observers: {
                value: null,
                writable: !0,
                configurable: !0
            }
        }),
        typeof t == "function" && t.amd ? t(function() {
            return E
        }) : o.exports = E
    }
    )()
}
)(ag);
const _r = ag.exports;
class vr extends _r {
    constructor(e) {
        super(),
        this.bootstrap = e,
        this._dependencies = new Set,
        this._enabled = !1
    }
    get priority() {
        return 0
    }
    get enabled() {
        return this._enabled
    }
    set enabled(e) {
        this._enabled != e && (this._enabled = e)
    }
    get dependencies() {
        return this._dependencies
    }
    get runnable() {
        return this.enabled && Array.from(this.dependencies).every(e => this.bootstrap.modules.has(e))
    }
    init() {}
    async before() {}
    async run() {}
    async after() {}
}
var Wi = {
    exports: {}
};
(function(o) {
    (function(e, t) {
        o.exports ? o.exports = t() : e.log = t()
    }
    )(hi, function() {
        var e = function() {}
          , t = "undefined"
          , n = typeof window !== t && typeof window.navigator !== t && /Trident\/|MSIE /.test(window.navigator.userAgent)
          , i = ["trace", "debug", "info", "warn", "error"];
        function r(d, p) {
            var v = d[p];
            if (typeof v.bind == "function")
                return v.bind(d);
            try {
                return Function.prototype.bind.call(v, d)
            } catch {
                return function() {
                    return Function.prototype.apply.apply(v, [d, arguments])
                }
            }
        }
        function s() {
            console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])),
            console.trace && console.trace()
        }
        function a(d) {
            return d === "debug" && (d = "log"),
            typeof console === t ? !1 : d === "trace" && n ? s : console[d] !== void 0 ? r(console, d) : console.log !== void 0 ? r(console, "log") : e
        }
        function l(d, p) {
            for (var v = 0; v < i.length; v++) {
                var x = i[v];
                this[x] = v < d ? e : this.methodFactory(x, d, p)
            }
            this.log = this.debug
        }
        function u(d, p, v) {
            return function() {
                typeof console !== t && (l.call(this, p, v),
                this[d].apply(this, arguments))
            }
        }
        function c(d, p, v) {
            return a(d) || u.apply(this, arguments)
        }
        function h(d, p, v) {
            var x = this, S;
            p = p == null ? "WARN" : p;
            var M = "loglevel";
            typeof d == "string" ? M += ":" + d : typeof d == "symbol" && (M = void 0);
            function T(C) {
                var N = (i[C] || "silent").toUpperCase();
                if (!(typeof window === t || !M)) {
                    try {
                        window.localStorage[M] = N;
                        return
                    } catch {}
                    try {
                        window.document.cookie = encodeURIComponent(M) + "=" + N + ";"
                    } catch {}
                }
            }
            function L() {
                var C;
                if (!(typeof window === t || !M)) {
                    try {
                        C = window.localStorage[M]
                    } catch {}
                    if (typeof C === t)
                        try {
                            var N = window.document.cookie
                              , G = N.indexOf(encodeURIComponent(M) + "=");
                            G !== -1 && (C = /^([^;]+)/.exec(N.slice(G))[1])
                        } catch {}
                    return x.levels[C] === void 0 && (C = void 0),
                    C
                }
            }
            function P() {
                if (!(typeof window === t || !M)) {
                    try {
                        window.localStorage.removeItem(M);
                        return
                    } catch {}
                    try {
                        window.document.cookie = encodeURIComponent(M) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC"
                    } catch {}
                }
            }
            x.name = d,
            x.levels = {
                TRACE: 0,
                DEBUG: 1,
                INFO: 2,
                WARN: 3,
                ERROR: 4,
                SILENT: 5
            },
            x.methodFactory = v || c,
            x.getLevel = function() {
                return S
            }
            ,
            x.setLevel = function(C, N) {
                if (typeof C == "string" && x.levels[C.toUpperCase()] !== void 0 && (C = x.levels[C.toUpperCase()]),
                typeof C == "number" && C >= 0 && C <= x.levels.SILENT) {
                    if (S = C,
                    N !== !1 && T(C),
                    l.call(x, C, d),
                    typeof console === t && C < x.levels.SILENT)
                        return "No console available for logging"
                } else
                    throw "log.setLevel() called with invalid level: " + C
            }
            ,
            x.setDefaultLevel = function(C) {
                p = C,
                L() || x.setLevel(C, !1)
            }
            ,
            x.resetLevel = function() {
                x.setLevel(p, !1),
                P()
            }
            ,
            x.enableAll = function(C) {
                x.setLevel(x.levels.TRACE, C)
            }
            ,
            x.disableAll = function(C) {
                x.setLevel(x.levels.SILENT, C)
            }
            ;
            var A = L();
            A == null && (A = p),
            x.setLevel(A, !1)
        }
        var f = new h
          , m = {};
        f.getLogger = function(p) {
            if (typeof p != "symbol" && typeof p != "string" || p === "")
                throw new TypeError("You must supply a name when creating a logger.");
            var v = m[p];
            return v || (v = m[p] = new h(p,f.getLevel(),f.methodFactory)),
            v
        }
        ;
        var _ = typeof window !== t ? window.log : void 0;
        return f.noConflict = function() {
            return typeof window !== t && window.log === f && (window.log = _),
            f
        }
        ,
        f.getLoggers = function() {
            return m
        }
        ,
        f.default = f,
        f
    })
}
)(Wi);
class Nn extends vr {
    constructor(e) {
        super(e),
        this._previous = {},
        this._state = {}
    }
    get previous() {
        return this._previous
    }
    get state() {
        return this._state
    }
    set state(e) {
        Wi.exports.debug("state", e),
        this._previous = this._state,
        this._state = e || {},
        this.emit("change", this._state)
    }
}
var lg = {
    exports: {}
}, pu = {
    exports: {}
}, vf;
function wv() {
    return vf || (vf = 1,
    function(o) {
        /** @license
 * JS Signals <http://millermedeiros.github.com/js-signals/>
 * Released under the MIT license
 * Author: Miller Medeiros
 * Version: 1.0.0 - Build: 268 (2012/11/29 05:48 PM)
 */
        (function(e) {
            function t(s, a, l, u, c) {
                this._listener = a,
                this._isOnce = l,
                this.context = u,
                this._signal = s,
                this._priority = c || 0
            }
            t.prototype = {
                active: !0,
                params: null,
                execute: function(s) {
                    var a, l;
                    return this.active && !!this._listener && (l = this.params ? this.params.concat(s) : s,
                    a = this._listener.apply(this.context, l),
                    this._isOnce && this.detach()),
                    a
                },
                detach: function() {
                    return this.isBound() ? this._signal.remove(this._listener, this.context) : null
                },
                isBound: function() {
                    return !!this._signal && !!this._listener
                },
                isOnce: function() {
                    return this._isOnce
                },
                getListener: function() {
                    return this._listener
                },
                getSignal: function() {
                    return this._signal
                },
                _destroy: function() {
                    delete this._signal,
                    delete this._listener,
                    delete this.context
                },
                toString: function() {
                    return "[SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]"
                }
            };
            function n(s, a) {
                if (typeof s != "function")
                    throw new Error("listener is a required param of {fn}() and should be a Function.".replace("{fn}", a))
            }
            function i() {
                this._bindings = [],
                this._prevParams = null;
                var s = this;
                this.dispatch = function() {
                    i.prototype.dispatch.apply(s, arguments)
                }
            }
            i.prototype = {
                VERSION: "1.0.0",
                memorize: !1,
                _shouldPropagate: !0,
                active: !0,
                _registerListener: function(s, a, l, u) {
                    var c = this._indexOfListener(s, l), h;
                    if (c !== -1) {
                        if (h = this._bindings[c],
                        h.isOnce() !== a)
                            throw new Error("You cannot add" + (a ? "" : "Once") + "() then add" + (a ? "Once" : "") + "() the same listener without removing the relationship first.")
                    } else
                        h = new t(this,s,a,l,u),
                        this._addBinding(h);
                    return this.memorize && this._prevParams && h.execute(this._prevParams),
                    h
                },
                _addBinding: function(s) {
                    var a = this._bindings.length;
                    do
                        --a;
                    while (this._bindings[a] && s._priority <= this._bindings[a]._priority);
                    this._bindings.splice(a + 1, 0, s)
                },
                _indexOfListener: function(s, a) {
                    for (var l = this._bindings.length, u; l--; )
                        if (u = this._bindings[l],
                        u._listener === s && u.context === a)
                            return l;
                    return -1
                },
                has: function(s, a) {
                    return this._indexOfListener(s, a) !== -1
                },
                add: function(s, a, l) {
                    return n(s, "add"),
                    this._registerListener(s, !1, a, l)
                },
                addOnce: function(s, a, l) {
                    return n(s, "addOnce"),
                    this._registerListener(s, !0, a, l)
                },
                remove: function(s, a) {
                    n(s, "remove");
                    var l = this._indexOfListener(s, a);
                    return l !== -1 && (this._bindings[l]._destroy(),
                    this._bindings.splice(l, 1)),
                    s
                },
                removeAll: function() {
                    for (var s = this._bindings.length; s--; )
                        this._bindings[s]._destroy();
                    this._bindings.length = 0
                },
                getNumListeners: function() {
                    return this._bindings.length
                },
                halt: function() {
                    this._shouldPropagate = !1
                },
                dispatch: function(s) {
                    if (!!this.active) {
                        var a = Array.prototype.slice.call(arguments), l = this._bindings.length, u;
                        if (this.memorize && (this._prevParams = a),
                        !!l) {
                            u = this._bindings.slice(),
                            this._shouldPropagate = !0;
                            do
                                l--;
                            while (u[l] && this._shouldPropagate && u[l].execute(a) !== !1)
                        }
                    }
                },
                forget: function() {
                    this._prevParams = null
                },
                dispose: function() {
                    this.removeAll(),
                    delete this._bindings,
                    delete this._prevParams
                },
                toString: function() {
                    return "[Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]"
                }
            };
            var r = i;
            r.Signal = i,
            o.exports ? o.exports = r : e.signals = r
        }
        )(hi)
    }(pu)),
    pu.exports
}
/** @license
 * crossroads <http://millermedeiros.github.com/crossroads.js/>
 * Author: Miller Medeiros | MIT License
 * v0.12.2 (2015/07/31 18:37)
 */
(function(o) {
    (function() {
        var e = function(t) {
            var n, i, r;
            i = /t(.+)?/.exec("t")[1] === "";
            function s(v, x) {
                if (v.indexOf)
                    return v.indexOf(x);
                for (var S = v.length; S--; )
                    if (v[S] === x)
                        return S;
                return -1
            }
            function a(v, x) {
                var S = s(v, x);
                S !== -1 && v.splice(S, 1)
            }
            function l(v, x) {
                return "[object " + x + "]" === Object.prototype.toString.call(v)
            }
            function u(v) {
                return l(v, "RegExp")
            }
            function c(v) {
                return l(v, "Array")
            }
            function h(v) {
                return typeof v == "function"
            }
            function f(v) {
                var x;
                return v === null || v === "null" ? x = null : v === "true" ? x = !0 : v === "false" ? x = !1 : v === r || v === "undefined" ? x = r : v === "" || isNaN(v) ? x = v : x = parseFloat(v),
                x
            }
            function m(v) {
                for (var x = v.length, S = []; x--; )
                    S[x] = f(v[x]);
                return S
            }
            function _(v, x) {
                for (var S = (v || "").replace("?", "").split("&"), M = -1, T = {}, L, P, A, C; P = S[++M]; )
                    L = P.indexOf("="),
                    C = P.substring(0, L),
                    A = decodeURIComponent(P.substring(L + 1)),
                    x !== !1 && (A = f(A)),
                    C in T ? c(T[C]) ? T[C].push(A) : T[C] = [T[C], A] : T[C] = A;
                return T
            }
            function d() {
                this.bypassed = new t.Signal,
                this.routed = new t.Signal,
                this._routes = [],
                this._prevRoutes = [],
                this._piped = [],
                this.resetState()
            }
            d.prototype = {
                greedy: !1,
                greedyEnabled: !0,
                ignoreCase: !0,
                ignoreState: !1,
                shouldTypecast: !1,
                normalizeFn: null,
                resetState: function() {
                    this._prevRoutes.length = 0,
                    this._prevMatchedRequest = null,
                    this._prevBypassedRequest = null
                },
                create: function() {
                    return new d
                },
                addRoute: function(v, x, S) {
                    var M = new p(v,x,S,this);
                    return this._sortedInsert(M),
                    M
                },
                removeRoute: function(v) {
                    a(this._routes, v),
                    v._destroy()
                },
                removeAllRoutes: function() {
                    for (var v = this.getNumRoutes(); v--; )
                        this._routes[v]._destroy();
                    this._routes.length = 0
                },
                parse: function(v, x) {
                    if (v = v || "",
                    x = x || [],
                    !(!this.ignoreState && (v === this._prevMatchedRequest || v === this._prevBypassedRequest))) {
                        var S = this._getMatchedRoutes(v), M = 0, T = S.length, L;
                        if (T)
                            for (this._prevMatchedRequest = v,
                            this._notifyPrevRoutes(S, v),
                            this._prevRoutes = S; M < T; )
                                L = S[M],
                                L.route.matched.dispatch.apply(L.route.matched, x.concat(L.params)),
                                L.isFirst = !M,
                                this.routed.dispatch.apply(this.routed, x.concat([v, L])),
                                M += 1;
                        else
                            this._prevBypassedRequest = v,
                            this.bypassed.dispatch.apply(this.bypassed, x.concat([v]));
                        this._pipeParse(v, x)
                    }
                },
                _notifyPrevRoutes: function(v, x) {
                    for (var S = 0, M; M = this._prevRoutes[S++]; )
                        M.route.switched && this._didSwitch(M.route, v) && M.route.switched.dispatch(x)
                },
                _didSwitch: function(v, x) {
                    for (var S, M = 0; S = x[M++]; )
                        if (S.route === v)
                            return !1;
                    return !0
                },
                _pipeParse: function(v, x) {
                    for (var S = 0, M; M = this._piped[S++]; )
                        M.parse(v, x)
                },
                getNumRoutes: function() {
                    return this._routes.length
                },
                _sortedInsert: function(v) {
                    var x = this._routes
                      , S = x.length;
                    do
                        --S;
                    while (x[S] && v._priority <= x[S]._priority);
                    x.splice(S + 1, 0, v)
                },
                _getMatchedRoutes: function(v) {
                    for (var x = [], S = this._routes, M = S.length, T; (T = S[--M]) && ((!x.length || this.greedy || T.greedy) && T.match(v) && x.push({
                        route: T,
                        params: T._getParamsArray(v)
                    }),
                    !(!this.greedyEnabled && x.length)); )
                        ;
                    return x
                },
                pipe: function(v) {
                    this._piped.push(v)
                },
                unpipe: function(v) {
                    a(this._piped, v)
                },
                toString: function() {
                    return "[crossroads numRoutes:" + this.getNumRoutes() + "]"
                }
            },
            n = new d,
            n.VERSION = "0.12.2",
            n.NORM_AS_ARRAY = function(v, x) {
                return [x.vals_]
            }
            ,
            n.NORM_AS_OBJECT = function(v, x) {
                return [x]
            }
            ;
            function p(v, x, S, M) {
                var T = u(v)
                  , L = M.patternLexer;
                this._router = M,
                this._pattern = v,
                this._paramsIds = T ? null : L.getParamIds(v),
                this._optionalParamsIds = T ? null : L.getOptionalParamsIds(v),
                this._matchRegexp = T ? v : L.compilePattern(v, M.ignoreCase),
                this.matched = new t.Signal,
                this.switched = new t.Signal,
                x && this.matched.add(x),
                this._priority = S || 0
            }
            return p.prototype = {
                greedy: !1,
                rules: void 0,
                match: function(v) {
                    return v = v || "",
                    this._matchRegexp.test(v) && this._validateParams(v)
                },
                _validateParams: function(v) {
                    var x = this.rules, S = this._getParamsObject(v), M;
                    for (M in x)
                        if (M !== "normalize_" && x.hasOwnProperty(M) && !this._isValidParam(v, M, S))
                            return !1;
                    return !0
                },
                _isValidParam: function(v, x, S) {
                    var M = this.rules[x]
                      , T = S[x]
                      , L = !1
                      , P = x.indexOf("?") === 0;
                    return T == null && this._optionalParamsIds && s(this._optionalParamsIds, x) !== -1 ? L = !0 : u(M) ? (P && (T = S[x + "_"]),
                    L = M.test(T)) : c(M) ? (P && (T = S[x + "_"]),
                    L = this._isValidArrayRule(M, T)) : h(M) && (L = M(T, v, S)),
                    L
                },
                _isValidArrayRule: function(v, x) {
                    if (!this._router.ignoreCase)
                        return s(v, x) !== -1;
                    typeof x == "string" && (x = x.toLowerCase());
                    for (var S = v.length, M, T; S--; )
                        if (M = v[S],
                        T = typeof M == "string" ? M.toLowerCase() : M,
                        T === x)
                            return !0;
                    return !1
                },
                _getParamsObject: function(v) {
                    for (var x = this._router.shouldTypecast, S = this._router.patternLexer.getParamPhilosophy(v, this._matchRegexp, x), M = {}, T = S.length, L, P; T--; )
                        P = S[T],
                        this._paramsIds && (L = this._paramsIds[T],
                        L.indexOf("?") === 0 && P && (M[L + "_"] = P,
                        P = _(P, x),
                        S[T] = P),
                        i && P === "" && s(this._optionalParamsIds, L) !== -1 && (P = void 0,
                        S[T] = P),
                        M[L] = P),
                        M[T] = P;
                    return M.request_ = x ? f(v) : v,
                    M.vals_ = S,
                    M
                },
                _getParamsArray: function(v) {
                    var x = this.rules ? this.rules.normalize_ : null, S;
                    return x = x || this._router.normalizeFn,
                    x && h(x) ? S = x(v, this._getParamsObject(v)) : S = this._getParamsObject(v).vals_,
                    S
                },
                interpolate: function(v) {
                    var x = this._router.patternLexer.interpolate(this._pattern, v);
                    if (!this._validateParams(x))
                        throw new Error("Generated string doesn't validate against `Route.rules`.");
                    return x
                },
                dispose: function() {
                    this._router.removeRoute(this)
                },
                _destroy: function() {
                    this.matched.dispose(),
                    this.switched.dispose(),
                    this.matched = this.switched = this._pattern = this._matchRegexp = null
                },
                toString: function() {
                    return '[Route pattern:"' + this._pattern + '", numListeners:' + this.matched.getNumListeners() + "]"
                }
            },
            d.prototype.patternLexer = function() {
                var v = /[\\.+*?\^$\[\](){}\/'#]/g
                  , x = /^\/|\/$/g
                  , S = /\/$/g
                  , M = /(?:\{|:)([^}:]+)(?:\}|:)/g
                  , T = {
                    OS: {
                        rgx: /([:}]|\w(?=\/))\/?(:|(?:\{\?))/g,
                        save: "$1{{id}}$2",
                        res: "\\/?"
                    },
                    RS: {
                        rgx: /([:}])\/?(\{)/g,
                        save: "$1{{id}}$2",
                        res: "\\/"
                    },
                    RQ: {
                        rgx: /\{\?([^}]+)\}/g,
                        res: "\\?([^#]+)"
                    },
                    OQ: {
                        rgx: /:\?([^:]+):/g,
                        res: "(?:\\?([^#]*))?"
                    },
                    OR: {
                        rgx: /:([^:]+)\*:/g,
                        res: "(.*)?"
                    },
                    RR: {
                        rgx: /\{([^}]+)\*\}/g,
                        res: "(.+)"
                    },
                    RP: {
                        rgx: /\{([^}]+)\}/g,
                        res: "([^\\/?]+)"
                    },
                    OP: {
                        rgx: /:([^:]+):/g,
                        res: "([^\\/?]+)?/?"
                    }
                }
                  , L = 1
                  , P = 2
                  , A = 3
                  , C = L;
                function N() {
                    var b, y;
                    for (b in T)
                        T.hasOwnProperty(b) && (y = T[b],
                        y.id = "__CR_" + b + "__",
                        y.save = "save"in y ? y.save.replace("{{id}}", y.id) : y.id,
                        y.rRestore = new RegExp(y.id,"g"))
                }
                N();
                function G(b, y) {
                    var D = [], I;
                    for (b.lastIndex = 0; I = b.exec(y); )
                        D.push(I[1]);
                    return D
                }
                function q(b) {
                    return G(M, b)
                }
                function g(b) {
                    return G(T.OP.rgx, b)
                }
                function w(b, y) {
                    return b = b || "",
                    b && (C === L ? b = b.replace(x, "") : C === A && (b = b.replace(S, "")),
                    b = E(b, "rgx", "save"),
                    b = b.replace(v, "\\$&"),
                    b = E(b, "rRestore", "res"),
                    C === L && (b = "\\/?" + b)),
                    C !== P && (b += "\\/?"),
                    new RegExp("^" + b + "$",y ? "i" : "")
                }
                function E(b, y, D) {
                    var I, F;
                    for (F in T)
                        T.hasOwnProperty(F) && (I = T[F],
                        b = b.replace(I[y], I[D]));
                    return b
                }
                function R(b, y, D) {
                    var I = y.exec(b);
                    return I && (I.shift(),
                    D && (I = m(I))),
                    I
                }
                function z(b, y) {
                    if (y = y || {},
                    typeof b != "string")
                        throw new Error("Route pattern should be a string.");
                    var D = function(I, F) {
                        var B;
                        if (F = F.substr(0, 1) === "?" ? F.substr(1) : F,
                        y[F] != null) {
                            if (typeof y[F] == "object") {
                                var H = [], W;
                                for (var U in y[F])
                                    if (W = y[F][U],
                                    c(W))
                                        for (var K in W)
                                            U.slice(-2) == "[]" ? H.push(encodeURI(U.slice(0, -2)) + "[]=" + encodeURI(W[K])) : H.push(encodeURI(U + "=" + W[K]));
                                    else
                                        H.push(encodeURI(U + "=" + W));
                                B = "?" + H.join("&")
                            } else
                                B = String(y[F]);
                            if (I.indexOf("*") === -1 && B.indexOf("/") !== -1)
                                throw new Error('Invalid value "' + B + '" for segment "' + I + '".')
                        } else {
                            if (I.indexOf("{") !== -1)
                                throw new Error("The segment " + I + " is required.");
                            B = ""
                        }
                        return B
                    };
                    return T.OS.trail || (T.OS.trail = new RegExp("(?:" + T.OS.id + ")+$")),
                    b.replace(T.OS.rgx, T.OS.save).replace(M, D).replace(T.OS.trail, "").replace(T.OS.rRestore, "/")
                }
                return {
                    strict: function() {
                        C = P
                    },
                    loose: function() {
                        C = L
                    },
                    legacy: function() {
                        C = A
                    },
                    getParamIds: q,
                    getOptionalParamsIds: g,
                    getParamPhilosophy: R,
                    compilePattern: w,
                    interpolate: z
                }
            }(),
            n
        };
        o.exports ? o.exports = e(wv()) : window.crossroads = e(window.signals)
    }
    )()
}
)(lg);
const Mv = lg.exports;
var ug = {
    exports: {}
}
  , Ia = {
    exports: {}
};
/*! https://mths.be/punycode v1.4.0 by @mathias */
var xf;
function Sv() {
    return xf || (xf = 1,
    function(o, e) {
        (function(t) {
            var n = e && !e.nodeType && e
              , i = o && !o.nodeType && o
              , r = typeof hi == "object" && hi;
            (r.global === r || r.window === r || r.self === r) && (t = r);
            var s, a = 2147483647, l = 36, u = 1, c = 26, h = 38, f = 700, m = 72, _ = 128, d = "-", p = /^xn--/, v = /[^\x20-\x7E]/, x = /[\x2E\u3002\uFF0E\uFF61]/g, S = {
                overflow: "Overflow: input needs wider integers to process",
                "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                "invalid-input": "Invalid input"
            }, M = l - u, T = Math.floor, L = String.fromCharCode, P;
            function A(D) {
                throw new RangeError(S[D])
            }
            function C(D, I) {
                for (var F = D.length, B = []; F--; )
                    B[F] = I(D[F]);
                return B
            }
            function N(D, I) {
                var F = D.split("@")
                  , B = "";
                F.length > 1 && (B = F[0] + "@",
                D = F[1]),
                D = D.replace(x, ".");
                var H = D.split(".")
                  , W = C(H, I).join(".");
                return B + W
            }
            function G(D) {
                for (var I = [], F = 0, B = D.length, H, W; F < B; )
                    H = D.charCodeAt(F++),
                    H >= 55296 && H <= 56319 && F < B ? (W = D.charCodeAt(F++),
                    (W & 64512) == 56320 ? I.push(((H & 1023) << 10) + (W & 1023) + 65536) : (I.push(H),
                    F--)) : I.push(H);
                return I
            }
            function q(D) {
                return C(D, function(I) {
                    var F = "";
                    return I > 65535 && (I -= 65536,
                    F += L(I >>> 10 & 1023 | 55296),
                    I = 56320 | I & 1023),
                    F += L(I),
                    F
                }).join("")
            }
            function g(D) {
                return D - 48 < 10 ? D - 22 : D - 65 < 26 ? D - 65 : D - 97 < 26 ? D - 97 : l
            }
            function w(D, I) {
                return D + 22 + 75 * (D < 26) - ((I != 0) << 5)
            }
            function E(D, I, F) {
                var B = 0;
                for (D = F ? T(D / f) : D >> 1,
                D += T(D / I); D > M * c >> 1; B += l)
                    D = T(D / M);
                return T(B + (M + 1) * D / (D + h))
            }
            function R(D) {
                var I = [], F = D.length, B, H = 0, W = _, U = m, K, te, he, ne, ce, oe, ue, Oe, qe;
                for (K = D.lastIndexOf(d),
                K < 0 && (K = 0),
                te = 0; te < K; ++te)
                    D.charCodeAt(te) >= 128 && A("not-basic"),
                    I.push(D.charCodeAt(te));
                for (he = K > 0 ? K + 1 : 0; he < F; ) {
                    for (ne = H,
                    ce = 1,
                    oe = l; he >= F && A("invalid-input"),
                    ue = g(D.charCodeAt(he++)),
                    (ue >= l || ue > T((a - H) / ce)) && A("overflow"),
                    H += ue * ce,
                    Oe = oe <= U ? u : oe >= U + c ? c : oe - U,
                    !(ue < Oe); oe += l)
                        qe = l - Oe,
                        ce > T(a / qe) && A("overflow"),
                        ce *= qe;
                    B = I.length + 1,
                    U = E(H - ne, B, ne == 0),
                    T(H / B) > a - W && A("overflow"),
                    W += T(H / B),
                    H %= B,
                    I.splice(H++, 0, W)
                }
                return q(I)
            }
            function z(D) {
                var I, F, B, H, W, U, K, te, he, ne, ce, oe = [], ue, Oe, qe, Ue;
                for (D = G(D),
                ue = D.length,
                I = _,
                F = 0,
                W = m,
                U = 0; U < ue; ++U)
                    ce = D[U],
                    ce < 128 && oe.push(L(ce));
                for (B = H = oe.length,
                H && oe.push(d); B < ue; ) {
                    for (K = a,
                    U = 0; U < ue; ++U)
                        ce = D[U],
                        ce >= I && ce < K && (K = ce);
                    for (Oe = B + 1,
                    K - I > T((a - F) / Oe) && A("overflow"),
                    F += (K - I) * Oe,
                    I = K,
                    U = 0; U < ue; ++U)
                        if (ce = D[U],
                        ce < I && ++F > a && A("overflow"),
                        ce == I) {
                            for (te = F,
                            he = l; ne = he <= W ? u : he >= W + c ? c : he - W,
                            !(te < ne); he += l)
                                Ue = te - ne,
                                qe = l - ne,
                                oe.push(L(w(ne + Ue % qe, 0))),
                                te = T(Ue / qe);
                            oe.push(L(w(te, 0))),
                            W = E(F, Oe, B == H),
                            F = 0,
                            ++B
                        }
                    ++F,
                    ++I
                }
                return oe.join("")
            }
            function b(D) {
                return N(D, function(I) {
                    return p.test(I) ? R(I.slice(4).toLowerCase()) : I
                })
            }
            function y(D) {
                return N(D, function(I) {
                    return v.test(I) ? "xn--" + z(I) : I
                })
            }
            if (s = {
                version: "1.3.2",
                ucs2: {
                    decode: G,
                    encode: q
                },
                decode: R,
                encode: z,
                toASCII: y,
                toUnicode: b
            },
            n && i)
                if (o.exports == n)
                    i.exports = s;
                else
                    for (P in s)
                        s.hasOwnProperty(P) && (n[P] = s[P]);
            else
                t.punycode = s
        }
        )(hi)
    }(Ia, Ia.exports)),
    Ia.exports
}
var mu = {
    exports: {}
};
/*!
 * URI.js - Mutating URLs
 * IPv6 Support
 *
 * Version: 1.19.11
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */
var yf;
function Dv() {
    return yf || (yf = 1,
    function(o) {
        (function(e, t) {
            o.exports ? o.exports = t() : e.IPv6 = t(e)
        }
        )(hi, function(e) {
            var t = e && e.IPv6;
            function n(r) {
                var s = r.toLowerCase()
                  , a = s.split(":")
                  , l = a.length
                  , u = 8;
                a[0] === "" && a[1] === "" && a[2] === "" ? (a.shift(),
                a.shift()) : a[0] === "" && a[1] === "" ? a.shift() : a[l - 1] === "" && a[l - 2] === "" && a.pop(),
                l = a.length,
                a[l - 1].indexOf(".") !== -1 && (u = 7);
                var c;
                for (c = 0; c < l && a[c] !== ""; c++)
                    ;
                if (c < u)
                    for (a.splice(c, 1, "0000"); a.length < u; )
                        a.splice(c, 0, "0000");
                for (var h, f = 0; f < u; f++) {
                    h = a[f].split("");
                    for (var m = 0; m < 3 && (h[0] === "0" && h.length > 1); m++)
                        h.splice(0, 1);
                    a[f] = h.join("")
                }
                var _ = -1
                  , d = 0
                  , p = 0
                  , v = -1
                  , x = !1;
                for (f = 0; f < u; f++)
                    x ? a[f] === "0" ? p += 1 : (x = !1,
                    p > d && (_ = v,
                    d = p)) : a[f] === "0" && (x = !0,
                    v = f,
                    p = 1);
                p > d && (_ = v,
                d = p),
                d > 1 && a.splice(_, d, ""),
                l = a.length;
                var S = "";
                for (a[0] === "" && (S = ":"),
                f = 0; f < l && (S += a[f],
                f !== l - 1); f++)
                    S += ":";
                return a[l - 1] === "" && (S += ":"),
                S
            }
            function i() {
                return e.IPv6 === this && (e.IPv6 = t),
                this
            }
            return {
                best: n,
                noConflict: i
            }
        })
    }(mu)),
    mu.exports
}
var gu = {
    exports: {}
};
/*!
 * URI.js - Mutating URLs
 * Second Level Domain (SLD) Support
 *
 * Version: 1.19.11
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */
var bf;
function Tv() {
    return bf || (bf = 1,
    function(o) {
        (function(e, t) {
            o.exports ? o.exports = t() : e.SecondLevelDomains = t(e)
        }
        )(hi, function(e) {
            var t = e && e.SecondLevelDomains
              , n = {
                list: {
                    ac: " com gov mil net org ",
                    ae: " ac co gov mil name net org pro sch ",
                    af: " com edu gov net org ",
                    al: " com edu gov mil net org ",
                    ao: " co ed gv it og pb ",
                    ar: " com edu gob gov int mil net org tur ",
                    at: " ac co gv or ",
                    au: " asn com csiro edu gov id net org ",
                    ba: " co com edu gov mil net org rs unbi unmo unsa untz unze ",
                    bb: " biz co com edu gov info net org store tv ",
                    bh: " biz cc com edu gov info net org ",
                    bn: " com edu gov net org ",
                    bo: " com edu gob gov int mil net org tv ",
                    br: " adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ",
                    bs: " com edu gov net org ",
                    bz: " du et om ov rg ",
                    ca: " ab bc mb nb nf nl ns nt nu on pe qc sk yk ",
                    ck: " biz co edu gen gov info net org ",
                    cn: " ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ",
                    co: " com edu gov mil net nom org ",
                    cr: " ac c co ed fi go or sa ",
                    cy: " ac biz com ekloges gov ltd name net org parliament press pro tm ",
                    do: " art com edu gob gov mil net org sld web ",
                    dz: " art asso com edu gov net org pol ",
                    ec: " com edu fin gov info med mil net org pro ",
                    eg: " com edu eun gov mil name net org sci ",
                    er: " com edu gov ind mil net org rochest w ",
                    es: " com edu gob nom org ",
                    et: " biz com edu gov info name net org ",
                    fj: " ac biz com info mil name net org pro ",
                    fk: " ac co gov net nom org ",
                    fr: " asso com f gouv nom prd presse tm ",
                    gg: " co net org ",
                    gh: " com edu gov mil org ",
                    gn: " ac com gov net org ",
                    gr: " com edu gov mil net org ",
                    gt: " com edu gob ind mil net org ",
                    gu: " com edu gov net org ",
                    hk: " com edu gov idv net org ",
                    hu: " 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ",
                    id: " ac co go mil net or sch web ",
                    il: " ac co gov idf k12 muni net org ",
                    in: " ac co edu ernet firm gen gov i ind mil net nic org res ",
                    iq: " com edu gov i mil net org ",
                    ir: " ac co dnssec gov i id net org sch ",
                    it: " edu gov ",
                    je: " co net org ",
                    jo: " com edu gov mil name net org sch ",
                    jp: " ac ad co ed go gr lg ne or ",
                    ke: " ac co go info me mobi ne or sc ",
                    kh: " com edu gov mil net org per ",
                    ki: " biz com de edu gov info mob net org tel ",
                    km: " asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ",
                    kn: " edu gov net org ",
                    kr: " ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ",
                    kw: " com edu gov net org ",
                    ky: " com edu gov net org ",
                    kz: " com edu gov mil net org ",
                    lb: " com edu gov net org ",
                    lk: " assn com edu gov grp hotel int ltd net ngo org sch soc web ",
                    lr: " com edu gov net org ",
                    lv: " asn com conf edu gov id mil net org ",
                    ly: " com edu gov id med net org plc sch ",
                    ma: " ac co gov m net org press ",
                    mc: " asso tm ",
                    me: " ac co edu gov its net org priv ",
                    mg: " com edu gov mil nom org prd tm ",
                    mk: " com edu gov inf name net org pro ",
                    ml: " com edu gov net org presse ",
                    mn: " edu gov org ",
                    mo: " com edu gov net org ",
                    mt: " com edu gov net org ",
                    mv: " aero biz com coop edu gov info int mil museum name net org pro ",
                    mw: " ac co com coop edu gov int museum net org ",
                    mx: " com edu gob net org ",
                    my: " com edu gov mil name net org sch ",
                    nf: " arts com firm info net other per rec store web ",
                    ng: " biz com edu gov mil mobi name net org sch ",
                    ni: " ac co com edu gob mil net nom org ",
                    np: " com edu gov mil net org ",
                    nr: " biz com edu gov info net org ",
                    om: " ac biz co com edu gov med mil museum net org pro sch ",
                    pe: " com edu gob mil net nom org sld ",
                    ph: " com edu gov i mil net ngo org ",
                    pk: " biz com edu fam gob gok gon gop gos gov net org web ",
                    pl: " art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ",
                    pr: " ac biz com edu est gov info isla name net org pro prof ",
                    ps: " com edu gov net org plo sec ",
                    pw: " belau co ed go ne or ",
                    ro: " arts com firm info nom nt org rec store tm www ",
                    rs: " ac co edu gov in org ",
                    sb: " com edu gov net org ",
                    sc: " com edu gov net org ",
                    sh: " co com edu gov net nom org ",
                    sl: " com edu gov net org ",
                    st: " co com consulado edu embaixada gov mil net org principe saotome store ",
                    sv: " com edu gob org red ",
                    sz: " ac co org ",
                    tr: " av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ",
                    tt: " aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ",
                    tw: " club com ebiz edu game gov idv mil net org ",
                    mu: " ac co com gov net or org ",
                    mz: " ac co edu gov org ",
                    na: " co com ",
                    nz: " ac co cri geek gen govt health iwi maori mil net org parliament school ",
                    pa: " abo ac com edu gob ing med net nom org sld ",
                    pt: " com edu gov int net nome org publ ",
                    py: " com edu gov mil net org ",
                    qa: " com edu gov mil net org ",
                    re: " asso com nom ",
                    ru: " ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ",
                    rw: " ac co com edu gouv gov int mil net ",
                    sa: " com edu gov med net org pub sch ",
                    sd: " com edu gov info med net org tv ",
                    se: " a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ",
                    sg: " com edu gov idn net org per ",
                    sn: " art com edu gouv org perso univ ",
                    sy: " com edu gov mil net news org ",
                    th: " ac co go in mi net or ",
                    tj: " ac biz co com edu go gov info int mil name net nic org test web ",
                    tn: " agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ",
                    tz: " ac co go ne or ",
                    ua: " biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ",
                    ug: " ac co go ne or org sc ",
                    uk: " ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ",
                    us: " dni fed isa kids nsn ",
                    uy: " com edu gub mil net org ",
                    ve: " co com edu gob info mil net org web ",
                    vi: " co com k12 net org ",
                    vn: " ac biz com edu gov health info int name net org pro ",
                    ye: " co com gov ltd me net org plc ",
                    yu: " ac co edu gov org ",
                    za: " ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ",
                    zm: " ac co com edu gov net org sch ",
                    com: "ar br cn de eu gb gr hu jpn kr no qc ru sa se uk us uy za ",
                    net: "gb jp se uk ",
                    org: "ae",
                    de: "com "
                },
                has: function(i) {
                    var r = i.lastIndexOf(".");
                    if (r <= 0 || r >= i.length - 1)
                        return !1;
                    var s = i.lastIndexOf(".", r - 1);
                    if (s <= 0 || s >= r - 1)
                        return !1;
                    var a = n.list[i.slice(r + 1)];
                    return a ? a.indexOf(" " + i.slice(s + 1, r) + " ") >= 0 : !1
                },
                is: function(i) {
                    var r = i.lastIndexOf(".");
                    if (r <= 0 || r >= i.length - 1)
                        return !1;
                    var s = i.lastIndexOf(".", r - 1);
                    if (s >= 0)
                        return !1;
                    var a = n.list[i.slice(r + 1)];
                    return a ? a.indexOf(" " + i.slice(0, r) + " ") >= 0 : !1
                },
                get: function(i) {
                    var r = i.lastIndexOf(".");
                    if (r <= 0 || r >= i.length - 1)
                        return null;
                    var s = i.lastIndexOf(".", r - 1);
                    if (s <= 0 || s >= r - 1)
                        return null;
                    var a = n.list[i.slice(r + 1)];
                    return !a || a.indexOf(" " + i.slice(s + 1, r) + " ") < 0 ? null : i.slice(s + 1)
                },
                noConflict: function() {
                    return e.SecondLevelDomains === this && (e.SecondLevelDomains = t),
                    this
                }
            };
            return n
        })
    }(gu)),
    gu.exports
}
/*!
 * URI.js - Mutating URLs
 *
 * Version: 1.19.11
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */
(function(o) {
    (function(e, t) {
        o.exports ? o.exports = t(Sv(), Dv(), Tv()) : e.URI = t(e.punycode, e.IPv6, e.SecondLevelDomains, e)
    }
    )(hi, function(e, t, n, i) {
        var r = i && i.URI;
        function s(g, w) {
            var E = arguments.length >= 1
              , R = arguments.length >= 2;
            if (!(this instanceof s))
                return E ? R ? new s(g,w) : new s(g) : new s;
            if (g === void 0) {
                if (E)
                    throw new TypeError("undefined is not a valid argument for URI");
                typeof location < "u" ? g = location.href + "" : g = ""
            }
            if (g === null && E)
                throw new TypeError("null is not a valid argument for URI");
            return this.href(g),
            w !== void 0 ? this.absoluteTo(w) : this
        }
        function a(g) {
            return /^[0-9]+$/.test(g)
        }
        s.version = "1.19.11";
        var l = s.prototype
          , u = Object.prototype.hasOwnProperty;
        function c(g) {
            return g.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1")
        }
        function h(g) {
            return g === void 0 ? "Undefined" : String(Object.prototype.toString.call(g)).slice(8, -1)
        }
        function f(g) {
            return h(g) === "Array"
        }
        function m(g, w) {
            var E = {}, R, z;
            if (h(w) === "RegExp")
                E = null;
            else if (f(w))
                for (R = 0,
                z = w.length; R < z; R++)
                    E[w[R]] = !0;
            else
                E[w] = !0;
            for (R = 0,
            z = g.length; R < z; R++) {
                var b = E && E[g[R]] !== void 0 || !E && w.test(g[R]);
                b && (g.splice(R, 1),
                z--,
                R--)
            }
            return g
        }
        function _(g, w) {
            var E, R;
            if (f(w)) {
                for (E = 0,
                R = w.length; E < R; E++)
                    if (!_(g, w[E]))
                        return !1;
                return !0
            }
            var z = h(w);
            for (E = 0,
            R = g.length; E < R; E++)
                if (z === "RegExp") {
                    if (typeof g[E] == "string" && g[E].match(w))
                        return !0
                } else if (g[E] === w)
                    return !0;
            return !1
        }
        function d(g, w) {
            if (!f(g) || !f(w) || g.length !== w.length)
                return !1;
            g.sort(),
            w.sort();
            for (var E = 0, R = g.length; E < R; E++)
                if (g[E] !== w[E])
                    return !1;
            return !0
        }
        function p(g) {
            var w = /^\/+|\/+$/g;
            return g.replace(w, "")
        }
        s._parts = function() {
            return {
                protocol: null,
                username: null,
                password: null,
                hostname: null,
                urn: null,
                port: null,
                path: null,
                query: null,
                fragment: null,
                preventInvalidHostname: s.preventInvalidHostname,
                duplicateQueryParameters: s.duplicateQueryParameters,
                escapeQuerySpace: s.escapeQuerySpace
            }
        }
        ,
        s.preventInvalidHostname = !1,
        s.duplicateQueryParameters = !1,
        s.escapeQuerySpace = !0,
        s.protocol_expression = /^[a-z][a-z0-9.+-]*$/i,
        s.idn_expression = /[^a-z0-9\._-]/i,
        s.punycode_expression = /(xn--)/i,
        s.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/,
        s.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/,
        s.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/ig,
        s.findUri = {
            start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
            end: /[\s\r\n]|$/,
            trim: /[`!()\[\]{};:'".,<>?«»“”„‘’]+$/,
            parens: /(\([^\)]*\)|\[[^\]]*\]|\{[^}]*\}|<[^>]*>)/g
        },
        s.leading_whitespace_expression = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/,
        s.ascii_tab_whitespace = /[\u0009\u000A\u000D]+/g,
        s.defaultPorts = {
            http: "80",
            https: "443",
            ftp: "21",
            gopher: "70",
            ws: "80",
            wss: "443"
        },
        s.hostProtocols = ["http", "https"],
        s.invalid_hostname_characters = /[^a-zA-Z0-9\.\-:_]/,
        s.domAttributes = {
            a: "href",
            blockquote: "cite",
            link: "href",
            base: "href",
            script: "src",
            form: "action",
            img: "src",
            area: "href",
            iframe: "src",
            embed: "src",
            source: "src",
            track: "src",
            input: "src",
            audio: "src",
            video: "src"
        },
        s.getDomAttribute = function(g) {
            if (!(!g || !g.nodeName)) {
                var w = g.nodeName.toLowerCase();
                if (!(w === "input" && g.type !== "image"))
                    return s.domAttributes[w]
            }
        }
        ;
        function v(g) {
            return escape(g)
        }
        function x(g) {
            return encodeURIComponent(g).replace(/[!'()*]/g, v).replace(/\*/g, "%2A")
        }
        s.encode = x,
        s.decode = decodeURIComponent,
        s.iso8859 = function() {
            s.encode = escape,
            s.decode = unescape
        }
        ,
        s.unicode = function() {
            s.encode = x,
            s.decode = decodeURIComponent
        }
        ,
        s.characters = {
            pathname: {
                encode: {
                    expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
                    map: {
                        "%24": "$",
                        "%26": "&",
                        "%2B": "+",
                        "%2C": ",",
                        "%3B": ";",
                        "%3D": "=",
                        "%3A": ":",
                        "%40": "@"
                    }
                },
                decode: {
                    expression: /[\/\?#]/g,
                    map: {
                        "/": "%2F",
                        "?": "%3F",
                        "#": "%23"
                    }
                }
            },
            reserved: {
                encode: {
                    expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
                    map: {
                        "%3A": ":",
                        "%2F": "/",
                        "%3F": "?",
                        "%23": "#",
                        "%5B": "[",
                        "%5D": "]",
                        "%40": "@",
                        "%21": "!",
                        "%24": "$",
                        "%26": "&",
                        "%27": "'",
                        "%28": "(",
                        "%29": ")",
                        "%2A": "*",
                        "%2B": "+",
                        "%2C": ",",
                        "%3B": ";",
                        "%3D": "="
                    }
                }
            },
            urnpath: {
                encode: {
                    expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,
                    map: {
                        "%21": "!",
                        "%24": "$",
                        "%27": "'",
                        "%28": "(",
                        "%29": ")",
                        "%2A": "*",
                        "%2B": "+",
                        "%2C": ",",
                        "%3B": ";",
                        "%3D": "=",
                        "%40": "@"
                    }
                },
                decode: {
                    expression: /[\/\?#:]/g,
                    map: {
                        "/": "%2F",
                        "?": "%3F",
                        "#": "%23",
                        ":": "%3A"
                    }
                }
            }
        },
        s.encodeQuery = function(g, w) {
            var E = s.encode(g + "");
            return w === void 0 && (w = s.escapeQuerySpace),
            w ? E.replace(/%20/g, "+") : E
        }
        ,
        s.decodeQuery = function(g, w) {
            g += "",
            w === void 0 && (w = s.escapeQuerySpace);
            try {
                return s.decode(w ? g.replace(/\+/g, "%20") : g)
            } catch {
                return g
            }
        }
        ;
        var S = {
            encode: "encode",
            decode: "decode"
        }, M, T = function(g, w) {
            return function(E) {
                try {
                    return s[w](E + "").replace(s.characters[g][w].expression, function(R) {
                        return s.characters[g][w].map[R]
                    })
                } catch {
                    return E
                }
            }
        };
        for (M in S)
            s[M + "PathSegment"] = T("pathname", S[M]),
            s[M + "UrnPathSegment"] = T("urnpath", S[M]);
        var L = function(g, w, E) {
            return function(R) {
                var z;
                E ? z = function(I) {
                    return s[w](s[E](I))
                }
                : z = s[w];
                for (var b = (R + "").split(g), y = 0, D = b.length; y < D; y++)
                    b[y] = z(b[y]);
                return b.join(g)
            }
        };
        s.decodePath = L("/", "decodePathSegment"),
        s.decodeUrnPath = L(":", "decodeUrnPathSegment"),
        s.recodePath = L("/", "encodePathSegment", "decode"),
        s.recodeUrnPath = L(":", "encodeUrnPathSegment", "decode"),
        s.encodeReserved = T("reserved", "encode"),
        s.parse = function(g, w) {
            var E;
            return w || (w = {
                preventInvalidHostname: s.preventInvalidHostname
            }),
            g = g.replace(s.leading_whitespace_expression, ""),
            g = g.replace(s.ascii_tab_whitespace, ""),
            E = g.indexOf("#"),
            E > -1 && (w.fragment = g.substring(E + 1) || null,
            g = g.substring(0, E)),
            E = g.indexOf("?"),
            E > -1 && (w.query = g.substring(E + 1) || null,
            g = g.substring(0, E)),
            g = g.replace(/^(https?|ftp|wss?)?:+[/\\]*/i, "$1://"),
            g = g.replace(/^[/\\]{2,}/i, "//"),
            g.substring(0, 2) === "//" ? (w.protocol = null,
            g = g.substring(2),
            g = s.parseAuthority(g, w)) : (E = g.indexOf(":"),
            E > -1 && (w.protocol = g.substring(0, E) || null,
            w.protocol && !w.protocol.match(s.protocol_expression) ? w.protocol = void 0 : g.substring(E + 1, E + 3).replace(/\\/g, "/") === "//" ? (g = g.substring(E + 3),
            g = s.parseAuthority(g, w)) : (g = g.substring(E + 1),
            w.urn = !0))),
            w.path = g,
            w
        }
        ,
        s.parseHost = function(g, w) {
            g || (g = ""),
            g = g.replace(/\\/g, "/");
            var E = g.indexOf("/"), R, z;
            if (E === -1 && (E = g.length),
            g.charAt(0) === "[")
                R = g.indexOf("]"),
                w.hostname = g.substring(1, R) || null,
                w.port = g.substring(R + 2, E) || null,
                w.port === "/" && (w.port = null);
            else {
                var b = g.indexOf(":")
                  , y = g.indexOf("/")
                  , D = g.indexOf(":", b + 1);
                D !== -1 && (y === -1 || D < y) ? (w.hostname = g.substring(0, E) || null,
                w.port = null) : (z = g.substring(0, E).split(":"),
                w.hostname = z[0] || null,
                w.port = z[1] || null)
            }
            return w.hostname && g.substring(E).charAt(0) !== "/" && (E++,
            g = "/" + g),
            w.preventInvalidHostname && s.ensureValidHostname(w.hostname, w.protocol),
            w.port && s.ensureValidPort(w.port),
            g.substring(E) || "/"
        }
        ,
        s.parseAuthority = function(g, w) {
            return g = s.parseUserinfo(g, w),
            s.parseHost(g, w)
        }
        ,
        s.parseUserinfo = function(g, w) {
            var E = g
              , R = g.indexOf("\\");
            R !== -1 && (g = g.replace(/\\/g, "/"));
            var z = g.indexOf("/"), b = g.lastIndexOf("@", z > -1 ? z : g.length - 1), y;
            return b > -1 && (z === -1 || b < z) ? (y = g.substring(0, b).split(":"),
            w.username = y[0] ? s.decode(y[0]) : null,
            y.shift(),
            w.password = y[0] ? s.decode(y.join(":")) : null,
            g = E.substring(b + 1)) : (w.username = null,
            w.password = null),
            g
        }
        ,
        s.parseQuery = function(g, w) {
            if (!g)
                return {};
            if (g = g.replace(/&+/g, "&").replace(/^\?*&*|&+$/g, ""),
            !g)
                return {};
            for (var E = {}, R = g.split("&"), z = R.length, b, y, D, I = 0; I < z; I++)
                b = R[I].split("="),
                y = s.decodeQuery(b.shift(), w),
                D = b.length ? s.decodeQuery(b.join("="), w) : null,
                y !== "__proto__" && (u.call(E, y) ? ((typeof E[y] == "string" || E[y] === null) && (E[y] = [E[y]]),
                E[y].push(D)) : E[y] = D);
            return E
        }
        ,
        s.build = function(g) {
            var w = ""
              , E = !1;
            return g.protocol && (w += g.protocol + ":"),
            !g.urn && (w || g.hostname) && (w += "//",
            E = !0),
            w += s.buildAuthority(g) || "",
            typeof g.path == "string" && (g.path.charAt(0) !== "/" && E && (w += "/"),
            w += g.path),
            typeof g.query == "string" && g.query && (w += "?" + g.query),
            typeof g.fragment == "string" && g.fragment && (w += "#" + g.fragment),
            w
        }
        ,
        s.buildHost = function(g) {
            var w = "";
            if (g.hostname)
                s.ip6_expression.test(g.hostname) ? w += "[" + g.hostname + "]" : w += g.hostname;
            else
                return "";
            return g.port && (w += ":" + g.port),
            w
        }
        ,
        s.buildAuthority = function(g) {
            return s.buildUserinfo(g) + s.buildHost(g)
        }
        ,
        s.buildUserinfo = function(g) {
            var w = "";
            return g.username && (w += s.encode(g.username)),
            g.password && (w += ":" + s.encode(g.password)),
            w && (w += "@"),
            w
        }
        ,
        s.buildQuery = function(g, w, E) {
            var R = "", z, b, y, D;
            for (b in g)
                if (b !== "__proto__" && u.call(g, b))
                    if (f(g[b]))
                        for (z = {},
                        y = 0,
                        D = g[b].length; y < D; y++)
                            g[b][y] !== void 0 && z[g[b][y] + ""] === void 0 && (R += "&" + s.buildQueryParameter(b, g[b][y], E),
                            w !== !0 && (z[g[b][y] + ""] = !0));
                    else
                        g[b] !== void 0 && (R += "&" + s.buildQueryParameter(b, g[b], E));
            return R.substring(1)
        }
        ,
        s.buildQueryParameter = function(g, w, E) {
            return s.encodeQuery(g, E) + (w !== null ? "=" + s.encodeQuery(w, E) : "")
        }
        ,
        s.addQuery = function(g, w, E) {
            if (typeof w == "object")
                for (var R in w)
                    u.call(w, R) && s.addQuery(g, R, w[R]);
            else if (typeof w == "string") {
                if (g[w] === void 0) {
                    g[w] = E;
                    return
                } else
                    typeof g[w] == "string" && (g[w] = [g[w]]);
                f(E) || (E = [E]),
                g[w] = (g[w] || []).concat(E)
            } else
                throw new TypeError("URI.addQuery() accepts an object, string as the name parameter")
        }
        ,
        s.setQuery = function(g, w, E) {
            if (typeof w == "object")
                for (var R in w)
                    u.call(w, R) && s.setQuery(g, R, w[R]);
            else if (typeof w == "string")
                g[w] = E === void 0 ? null : E;
            else
                throw new TypeError("URI.setQuery() accepts an object, string as the name parameter")
        }
        ,
        s.removeQuery = function(g, w, E) {
            var R, z, b;
            if (f(w))
                for (R = 0,
                z = w.length; R < z; R++)
                    g[w[R]] = void 0;
            else if (h(w) === "RegExp")
                for (b in g)
                    w.test(b) && (g[b] = void 0);
            else if (typeof w == "object")
                for (b in w)
                    u.call(w, b) && s.removeQuery(g, b, w[b]);
            else if (typeof w == "string")
                E !== void 0 ? h(E) === "RegExp" ? !f(g[w]) && E.test(g[w]) ? g[w] = void 0 : g[w] = m(g[w], E) : g[w] === String(E) && (!f(E) || E.length === 1) ? g[w] = void 0 : f(g[w]) && (g[w] = m(g[w], E)) : g[w] = void 0;
            else
                throw new TypeError("URI.removeQuery() accepts an object, string, RegExp as the first parameter")
        }
        ,
        s.hasQuery = function(g, w, E, R) {
            switch (h(w)) {
            case "String":
                break;
            case "RegExp":
                for (var z in g)
                    if (u.call(g, z) && w.test(z) && (E === void 0 || s.hasQuery(g, z, E)))
                        return !0;
                return !1;
            case "Object":
                for (var b in w)
                    if (u.call(w, b) && !s.hasQuery(g, b, w[b]))
                        return !1;
                return !0;
            default:
                throw new TypeError("URI.hasQuery() accepts a string, regular expression or object as the name parameter")
            }
            switch (h(E)) {
            case "Undefined":
                return w in g;
            case "Boolean":
                var y = Boolean(f(g[w]) ? g[w].length : g[w]);
                return E === y;
            case "Function":
                return !!E(g[w], w, g);
            case "Array":
                if (!f(g[w]))
                    return !1;
                var D = R ? _ : d;
                return D(g[w], E);
            case "RegExp":
                return f(g[w]) ? R ? _(g[w], E) : !1 : Boolean(g[w] && g[w].match(E));
            case "Number":
                E = String(E);
            case "String":
                return f(g[w]) ? R ? _(g[w], E) : !1 : g[w] === E;
            default:
                throw new TypeError("URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter")
            }
        }
        ,
        s.joinPaths = function() {
            for (var g = [], w = [], E = 0, R = 0; R < arguments.length; R++) {
                var z = new s(arguments[R]);
                g.push(z);
                for (var b = z.segment(), y = 0; y < b.length; y++)
                    typeof b[y] == "string" && w.push(b[y]),
                    b[y] && E++
            }
            if (!w.length || !E)
                return new s("");
            var D = new s("").segment(w);
            return (g[0].path() === "" || g[0].path().slice(0, 1) === "/") && D.path("/" + D.path()),
            D.normalize()
        }
        ,
        s.commonPath = function(g, w) {
            var E = Math.min(g.length, w.length), R;
            for (R = 0; R < E; R++)
                if (g.charAt(R) !== w.charAt(R)) {
                    R--;
                    break
                }
            return R < 1 ? g.charAt(0) === w.charAt(0) && g.charAt(0) === "/" ? "/" : "" : ((g.charAt(R) !== "/" || w.charAt(R) !== "/") && (R = g.substring(0, R).lastIndexOf("/")),
            g.substring(0, R + 1))
        }
        ,
        s.withinString = function(g, w, E) {
            E || (E = {});
            var R = E.start || s.findUri.start
              , z = E.end || s.findUri.end
              , b = E.trim || s.findUri.trim
              , y = E.parens || s.findUri.parens
              , D = /[a-z0-9-]=["']?$/i;
            for (R.lastIndex = 0; ; ) {
                var I = R.exec(g);
                if (!I)
                    break;
                var F = I.index;
                if (E.ignoreHtml) {
                    var B = g.slice(Math.max(F - 3, 0), F);
                    if (B && D.test(B))
                        continue
                }
                for (var H = F + g.slice(F).search(z), W = g.slice(F, H), U = -1; ; ) {
                    var K = y.exec(W);
                    if (!K)
                        break;
                    var te = K.index + K[0].length;
                    U = Math.max(U, te)
                }
                if (U > -1 ? W = W.slice(0, U) + W.slice(U).replace(b, "") : W = W.replace(b, ""),
                !(W.length <= I[0].length) && !(E.ignore && E.ignore.test(W))) {
                    H = F + W.length;
                    var he = w(W, F, H, g);
                    if (he === void 0) {
                        R.lastIndex = H;
                        continue
                    }
                    he = String(he),
                    g = g.slice(0, F) + he + g.slice(H),
                    R.lastIndex = F + he.length
                }
            }
            return R.lastIndex = 0,
            g
        }
        ,
        s.ensureValidHostname = function(g, w) {
            var E = !!g
              , R = !!w
              , z = !1;
            if (R && (z = _(s.hostProtocols, w)),
            z && !E)
                throw new TypeError("Hostname cannot be empty, if protocol is " + w);
            if (g && g.match(s.invalid_hostname_characters)) {
                if (!e)
                    throw new TypeError('Hostname "' + g + '" contains characters other than [A-Z0-9.-:_] and Punycode.js is not available');
                if (e.toASCII(g).match(s.invalid_hostname_characters))
                    throw new TypeError('Hostname "' + g + '" contains characters other than [A-Z0-9.-:_]')
            }
        }
        ,
        s.ensureValidPort = function(g) {
            if (!!g) {
                var w = Number(g);
                if (!(a(w) && w > 0 && w < 65536))
                    throw new TypeError('Port "' + g + '" is not a valid port')
            }
        }
        ,
        s.noConflict = function(g) {
            if (g) {
                var w = {
                    URI: this.noConflict()
                };
                return i.URITemplate && typeof i.URITemplate.noConflict == "function" && (w.URITemplate = i.URITemplate.noConflict()),
                i.IPv6 && typeof i.IPv6.noConflict == "function" && (w.IPv6 = i.IPv6.noConflict()),
                i.SecondLevelDomains && typeof i.SecondLevelDomains.noConflict == "function" && (w.SecondLevelDomains = i.SecondLevelDomains.noConflict()),
                w
            } else
                i.URI === this && (i.URI = r);
            return this
        }
        ,
        l.build = function(g) {
            return g === !0 ? this._deferred_build = !0 : (g === void 0 || this._deferred_build) && (this._string = s.build(this._parts),
            this._deferred_build = !1),
            this
        }
        ,
        l.clone = function() {
            return new s(this)
        }
        ,
        l.valueOf = l.toString = function() {
            return this.build(!1)._string
        }
        ;
        function P(g) {
            return function(w, E) {
                return w === void 0 ? this._parts[g] || "" : (this._parts[g] = w || null,
                this.build(!E),
                this)
            }
        }
        function A(g, w) {
            return function(E, R) {
                return E === void 0 ? this._parts[g] || "" : (E !== null && (E = E + "",
                E.charAt(0) === w && (E = E.substring(1))),
                this._parts[g] = E,
                this.build(!R),
                this)
            }
        }
        l.protocol = P("protocol"),
        l.username = P("username"),
        l.password = P("password"),
        l.hostname = P("hostname"),
        l.port = P("port"),
        l.query = A("query", "?"),
        l.fragment = A("fragment", "#"),
        l.search = function(g, w) {
            var E = this.query(g, w);
            return typeof E == "string" && E.length ? "?" + E : E
        }
        ,
        l.hash = function(g, w) {
            var E = this.fragment(g, w);
            return typeof E == "string" && E.length ? "#" + E : E
        }
        ,
        l.pathname = function(g, w) {
            if (g === void 0 || g === !0) {
                var E = this._parts.path || (this._parts.hostname ? "/" : "");
                return g ? (this._parts.urn ? s.decodeUrnPath : s.decodePath)(E) : E
            } else
                return this._parts.urn ? this._parts.path = g ? s.recodeUrnPath(g) : "" : this._parts.path = g ? s.recodePath(g) : "/",
                this.build(!w),
                this
        }
        ,
        l.path = l.pathname,
        l.href = function(g, w) {
            var E;
            if (g === void 0)
                return this.toString();
            this._string = "",
            this._parts = s._parts();
            var R = g instanceof s
              , z = typeof g == "object" && (g.hostname || g.path || g.pathname);
            if (g.nodeName) {
                var b = s.getDomAttribute(g);
                g = g[b] || "",
                z = !1
            }
            if (!R && z && g.pathname !== void 0 && (g = g.toString()),
            typeof g == "string" || g instanceof String)
                this._parts = s.parse(String(g), this._parts);
            else if (R || z) {
                var y = R ? g._parts : g;
                for (E in y)
                    E !== "query" && u.call(this._parts, E) && (this._parts[E] = y[E]);
                y.query && this.query(y.query, !1)
            } else
                throw new TypeError("invalid input");
            return this.build(!w),
            this
        }
        ,
        l.is = function(g) {
            var w = !1
              , E = !1
              , R = !1
              , z = !1
              , b = !1
              , y = !1
              , D = !1
              , I = !this._parts.urn;
            switch (this._parts.hostname && (I = !1,
            E = s.ip4_expression.test(this._parts.hostname),
            R = s.ip6_expression.test(this._parts.hostname),
            w = E || R,
            z = !w,
            b = z && n && n.has(this._parts.hostname),
            y = z && s.idn_expression.test(this._parts.hostname),
            D = z && s.punycode_expression.test(this._parts.hostname)),
            g.toLowerCase()) {
            case "relative":
                return I;
            case "absolute":
                return !I;
            case "domain":
            case "name":
                return z;
            case "sld":
                return b;
            case "ip":
                return w;
            case "ip4":
            case "ipv4":
            case "inet4":
                return E;
            case "ip6":
            case "ipv6":
            case "inet6":
                return R;
            case "idn":
                return y;
            case "url":
                return !this._parts.urn;
            case "urn":
                return !!this._parts.urn;
            case "punycode":
                return D
            }
            return null
        }
        ;
        var C = l.protocol
          , N = l.port
          , G = l.hostname;
        l.protocol = function(g, w) {
            if (g && (g = g.replace(/:(\/\/)?$/, ""),
            !g.match(s.protocol_expression)))
                throw new TypeError('Protocol "' + g + `" contains characters other than [A-Z0-9.+-] or doesn't start with [A-Z]`);
            return C.call(this, g, w)
        }
        ,
        l.scheme = l.protocol,
        l.port = function(g, w) {
            return this._parts.urn ? g === void 0 ? "" : this : (g !== void 0 && (g === 0 && (g = null),
            g && (g += "",
            g.charAt(0) === ":" && (g = g.substring(1)),
            s.ensureValidPort(g))),
            N.call(this, g, w))
        }
        ,
        l.hostname = function(g, w) {
            if (this._parts.urn)
                return g === void 0 ? "" : this;
            if (g !== void 0) {
                var E = {
                    preventInvalidHostname: this._parts.preventInvalidHostname
                }
                  , R = s.parseHost(g, E);
                if (R !== "/")
                    throw new TypeError('Hostname "' + g + '" contains characters other than [A-Z0-9.-]');
                g = E.hostname,
                this._parts.preventInvalidHostname && s.ensureValidHostname(g, this._parts.protocol)
            }
            return G.call(this, g, w)
        }
        ,
        l.origin = function(g, w) {
            if (this._parts.urn)
                return g === void 0 ? "" : this;
            if (g === void 0) {
                var E = this.protocol()
                  , R = this.authority();
                return R ? (E ? E + "://" : "") + this.authority() : ""
            } else {
                var z = s(g);
                return this.protocol(z.protocol()).authority(z.authority()).build(!w),
                this
            }
        }
        ,
        l.host = function(g, w) {
            if (this._parts.urn)
                return g === void 0 ? "" : this;
            if (g === void 0)
                return this._parts.hostname ? s.buildHost(this._parts) : "";
            var E = s.parseHost(g, this._parts);
            if (E !== "/")
                throw new TypeError('Hostname "' + g + '" contains characters other than [A-Z0-9.-]');
            return this.build(!w),
            this
        }
        ,
        l.authority = function(g, w) {
            if (this._parts.urn)
                return g === void 0 ? "" : this;
            if (g === void 0)
                return this._parts.hostname ? s.buildAuthority(this._parts) : "";
            var E = s.parseAuthority(g, this._parts);
            if (E !== "/")
                throw new TypeError('Hostname "' + g + '" contains characters other than [A-Z0-9.-]');
            return this.build(!w),
            this
        }
        ,
        l.userinfo = function(g, w) {
            if (this._parts.urn)
                return g === void 0 ? "" : this;
            if (g === void 0) {
                var E = s.buildUserinfo(this._parts);
                return E && E.substring(0, E.length - 1)
            } else
                return g[g.length - 1] !== "@" && (g += "@"),
                s.parseUserinfo(g, this._parts),
                this.build(!w),
                this
        }
        ,
        l.resource = function(g, w) {
            var E;
            return g === void 0 ? this.path() + this.search() + this.hash() : (E = s.parse(g),
            this._parts.path = E.path,
            this._parts.query = E.query,
            this._parts.fragment = E.fragment,
            this.build(!w),
            this)
        }
        ,
        l.subdomain = function(g, w) {
            if (this._parts.urn)
                return g === void 0 ? "" : this;
            if (g === void 0) {
                if (!this._parts.hostname || this.is("IP"))
                    return "";
                var E = this._parts.hostname.length - this.domain().length - 1;
                return this._parts.hostname.substring(0, E) || ""
            } else {
                var R = this._parts.hostname.length - this.domain().length
                  , z = this._parts.hostname.substring(0, R)
                  , b = new RegExp("^" + c(z));
                if (g && g.charAt(g.length - 1) !== "." && (g += "."),
                g.indexOf(":") !== -1)
                    throw new TypeError("Domains cannot contain colons");
                return g && s.ensureValidHostname(g, this._parts.protocol),
                this._parts.hostname = this._parts.hostname.replace(b, g),
                this.build(!w),
                this
            }
        }
        ,
        l.domain = function(g, w) {
            if (this._parts.urn)
                return g === void 0 ? "" : this;
            if (typeof g == "boolean" && (w = g,
            g = void 0),
            g === void 0) {
                if (!this._parts.hostname || this.is("IP"))
                    return "";
                var E = this._parts.hostname.match(/\./g);
                if (E && E.length < 2)
                    return this._parts.hostname;
                var R = this._parts.hostname.length - this.tld(w).length - 1;
                return R = this._parts.hostname.lastIndexOf(".", R - 1) + 1,
                this._parts.hostname.substring(R) || ""
            } else {
                if (!g)
                    throw new TypeError("cannot set domain empty");
                if (g.indexOf(":") !== -1)
                    throw new TypeError("Domains cannot contain colons");
                if (s.ensureValidHostname(g, this._parts.protocol),
                !this._parts.hostname || this.is("IP"))
                    this._parts.hostname = g;
                else {
                    var z = new RegExp(c(this.domain()) + "$");
                    this._parts.hostname = this._parts.hostname.replace(z, g)
                }
                return this.build(!w),
                this
            }
        }
        ,
        l.tld = function(g, w) {
            if (this._parts.urn)
                return g === void 0 ? "" : this;
            if (typeof g == "boolean" && (w = g,
            g = void 0),
            g === void 0) {
                if (!this._parts.hostname || this.is("IP"))
                    return "";
                var E = this._parts.hostname.lastIndexOf(".")
                  , R = this._parts.hostname.substring(E + 1);
                return w !== !0 && n && n.list[R.toLowerCase()] && n.get(this._parts.hostname) || R
            } else {
                var z;
                if (g)
                    if (g.match(/[^a-zA-Z0-9-]/))
                        if (n && n.is(g))
                            z = new RegExp(c(this.tld()) + "$"),
                            this._parts.hostname = this._parts.hostname.replace(z, g);
                        else
                            throw new TypeError('TLD "' + g + '" contains characters other than [A-Z0-9]');
                    else {
                        if (!this._parts.hostname || this.is("IP"))
                            throw new ReferenceError("cannot set TLD on non-domain host");
                        z = new RegExp(c(this.tld()) + "$"),
                        this._parts.hostname = this._parts.hostname.replace(z, g)
                    }
                else
                    throw new TypeError("cannot set TLD empty");
                return this.build(!w),
                this
            }
        }
        ,
        l.directory = function(g, w) {
            if (this._parts.urn)
                return g === void 0 ? "" : this;
            if (g === void 0 || g === !0) {
                if (!this._parts.path && !this._parts.hostname)
                    return "";
                if (this._parts.path === "/")
                    return "/";
                var E = this._parts.path.length - this.filename().length - 1
                  , R = this._parts.path.substring(0, E) || (this._parts.hostname ? "/" : "");
                return g ? s.decodePath(R) : R
            } else {
                var z = this._parts.path.length - this.filename().length
                  , b = this._parts.path.substring(0, z)
                  , y = new RegExp("^" + c(b));
                return this.is("relative") || (g || (g = "/"),
                g.charAt(0) !== "/" && (g = "/" + g)),
                g && g.charAt(g.length - 1) !== "/" && (g += "/"),
                g = s.recodePath(g),
                this._parts.path = this._parts.path.replace(y, g),
                this.build(!w),
                this
            }
        }
        ,
        l.filename = function(g, w) {
            if (this._parts.urn)
                return g === void 0 ? "" : this;
            if (typeof g != "string") {
                if (!this._parts.path || this._parts.path === "/")
                    return "";
                var E = this._parts.path.lastIndexOf("/")
                  , R = this._parts.path.substring(E + 1);
                return g ? s.decodePathSegment(R) : R
            } else {
                var z = !1;
                g.charAt(0) === "/" && (g = g.substring(1)),
                g.match(/\.?\//) && (z = !0);
                var b = new RegExp(c(this.filename()) + "$");
                return g = s.recodePath(g),
                this._parts.path = this._parts.path.replace(b, g),
                z ? this.normalizePath(w) : this.build(!w),
                this
            }
        }
        ,
        l.suffix = function(g, w) {
            if (this._parts.urn)
                return g === void 0 ? "" : this;
            if (g === void 0 || g === !0) {
                if (!this._parts.path || this._parts.path === "/")
                    return "";
                var E = this.filename(), R = E.lastIndexOf("."), z, b;
                return R === -1 ? "" : (z = E.substring(R + 1),
                b = /^[a-z0-9%]+$/i.test(z) ? z : "",
                g ? s.decodePathSegment(b) : b)
            } else {
                g.charAt(0) === "." && (g = g.substring(1));
                var y = this.suffix(), D;
                if (y)
                    g ? D = new RegExp(c(y) + "$") : D = new RegExp(c("." + y) + "$");
                else {
                    if (!g)
                        return this;
                    this._parts.path += "." + s.recodePath(g)
                }
                return D && (g = s.recodePath(g),
                this._parts.path = this._parts.path.replace(D, g)),
                this.build(!w),
                this
            }
        }
        ,
        l.segment = function(g, w, E) {
            var R = this._parts.urn ? ":" : "/"
              , z = this.path()
              , b = z.substring(0, 1) === "/"
              , y = z.split(R);
            if (g !== void 0 && typeof g != "number" && (E = w,
            w = g,
            g = void 0),
            g !== void 0 && typeof g != "number")
                throw new Error('Bad segment "' + g + '", must be 0-based integer');
            if (b && y.shift(),
            g < 0 && (g = Math.max(y.length + g, 0)),
            w === void 0)
                return g === void 0 ? y : y[g];
            if (g === null || y[g] === void 0)
                if (f(w)) {
                    y = [];
                    for (var D = 0, I = w.length; D < I; D++)
                        !w[D].length && (!y.length || !y[y.length - 1].length) || (y.length && !y[y.length - 1].length && y.pop(),
                        y.push(p(w[D])))
                } else
                    (w || typeof w == "string") && (w = p(w),
                    y[y.length - 1] === "" ? y[y.length - 1] = w : y.push(w));
            else
                w ? y[g] = p(w) : y.splice(g, 1);
            return b && y.unshift(""),
            this.path(y.join(R), E)
        }
        ,
        l.segmentCoded = function(g, w, E) {
            var R, z, b;
            if (typeof g != "number" && (E = w,
            w = g,
            g = void 0),
            w === void 0) {
                if (R = this.segment(g, w, E),
                !f(R))
                    R = R !== void 0 ? s.decode(R) : void 0;
                else
                    for (z = 0,
                    b = R.length; z < b; z++)
                        R[z] = s.decode(R[z]);
                return R
            }
            if (!f(w))
                w = typeof w == "string" || w instanceof String ? s.encode(w) : w;
            else
                for (z = 0,
                b = w.length; z < b; z++)
                    w[z] = s.encode(w[z]);
            return this.segment(g, w, E)
        }
        ;
        var q = l.query;
        return l.query = function(g, w) {
            if (g === !0)
                return s.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            if (typeof g == "function") {
                var E = s.parseQuery(this._parts.query, this._parts.escapeQuerySpace)
                  , R = g.call(this, E);
                return this._parts.query = s.buildQuery(R || E, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace),
                this.build(!w),
                this
            } else
                return g !== void 0 && typeof g != "string" ? (this._parts.query = s.buildQuery(g, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace),
                this.build(!w),
                this) : q.call(this, g, w)
        }
        ,
        l.setQuery = function(g, w, E) {
            var R = s.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            if (typeof g == "string" || g instanceof String)
                R[g] = w !== void 0 ? w : null;
            else if (typeof g == "object")
                for (var z in g)
                    u.call(g, z) && (R[z] = g[z]);
            else
                throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
            return this._parts.query = s.buildQuery(R, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace),
            typeof g != "string" && (E = w),
            this.build(!E),
            this
        }
        ,
        l.addQuery = function(g, w, E) {
            var R = s.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            return s.addQuery(R, g, w === void 0 ? null : w),
            this._parts.query = s.buildQuery(R, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace),
            typeof g != "string" && (E = w),
            this.build(!E),
            this
        }
        ,
        l.removeQuery = function(g, w, E) {
            var R = s.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            return s.removeQuery(R, g, w),
            this._parts.query = s.buildQuery(R, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace),
            typeof g != "string" && (E = w),
            this.build(!E),
            this
        }
        ,
        l.hasQuery = function(g, w, E) {
            var R = s.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            return s.hasQuery(R, g, w, E)
        }
        ,
        l.setSearch = l.setQuery,
        l.addSearch = l.addQuery,
        l.removeSearch = l.removeQuery,
        l.hasSearch = l.hasQuery,
        l.normalize = function() {
            return this._parts.urn ? this.normalizeProtocol(!1).normalizePath(!1).normalizeQuery(!1).normalizeFragment(!1).build() : this.normalizeProtocol(!1).normalizeHostname(!1).normalizePort(!1).normalizePath(!1).normalizeQuery(!1).normalizeFragment(!1).build()
        }
        ,
        l.normalizeProtocol = function(g) {
            return typeof this._parts.protocol == "string" && (this._parts.protocol = this._parts.protocol.toLowerCase(),
            this.build(!g)),
            this
        }
        ,
        l.normalizeHostname = function(g) {
            return this._parts.hostname && (this.is("IDN") && e ? this._parts.hostname = e.toASCII(this._parts.hostname) : this.is("IPv6") && t && (this._parts.hostname = t.best(this._parts.hostname)),
            this._parts.hostname = this._parts.hostname.toLowerCase(),
            this.build(!g)),
            this
        }
        ,
        l.normalizePort = function(g) {
            return typeof this._parts.protocol == "string" && this._parts.port === s.defaultPorts[this._parts.protocol] && (this._parts.port = null,
            this.build(!g)),
            this
        }
        ,
        l.normalizePath = function(g) {
            var w = this._parts.path;
            if (!w)
                return this;
            if (this._parts.urn)
                return this._parts.path = s.recodeUrnPath(this._parts.path),
                this.build(!g),
                this;
            if (this._parts.path === "/")
                return this;
            w = s.recodePath(w);
            var E, R = "", z, b;
            for (w.charAt(0) !== "/" && (E = !0,
            w = "/" + w),
            (w.slice(-3) === "/.." || w.slice(-2) === "/.") && (w += "/"),
            w = w.replace(/(\/(\.\/)+)|(\/\.$)/g, "/").replace(/\/{2,}/g, "/"),
            E && (R = w.substring(1).match(/^(\.\.\/)+/) || "",
            R && (R = R[0])); z = w.search(/\/\.\.(\/|$)/),
            z !== -1; ) {
                if (z === 0) {
                    w = w.substring(3);
                    continue
                }
                b = w.substring(0, z).lastIndexOf("/"),
                b === -1 && (b = z),
                w = w.substring(0, b) + w.substring(z + 3)
            }
            return E && this.is("relative") && (w = R + w.substring(1)),
            this._parts.path = w,
            this.build(!g),
            this
        }
        ,
        l.normalizePathname = l.normalizePath,
        l.normalizeQuery = function(g) {
            return typeof this._parts.query == "string" && (this._parts.query.length ? this.query(s.parseQuery(this._parts.query, this._parts.escapeQuerySpace)) : this._parts.query = null,
            this.build(!g)),
            this
        }
        ,
        l.normalizeFragment = function(g) {
            return this._parts.fragment || (this._parts.fragment = null,
            this.build(!g)),
            this
        }
        ,
        l.normalizeSearch = l.normalizeQuery,
        l.normalizeHash = l.normalizeFragment,
        l.iso8859 = function() {
            var g = s.encode
              , w = s.decode;
            s.encode = escape,
            s.decode = decodeURIComponent;
            try {
                this.normalize()
            } finally {
                s.encode = g,
                s.decode = w
            }
            return this
        }
        ,
        l.unicode = function() {
            var g = s.encode
              , w = s.decode;
            s.encode = x,
            s.decode = unescape;
            try {
                this.normalize()
            } finally {
                s.encode = g,
                s.decode = w
            }
            return this
        }
        ,
        l.readable = function() {
            var g = this.clone();
            g.username("").password("").normalize();
            var w = "";
            if (g._parts.protocol && (w += g._parts.protocol + "://"),
            g._parts.hostname && (g.is("punycode") && e ? (w += e.toUnicode(g._parts.hostname),
            g._parts.port && (w += ":" + g._parts.port)) : w += g.host()),
            g._parts.hostname && g._parts.path && g._parts.path.charAt(0) !== "/" && (w += "/"),
            w += g.path(!0),
            g._parts.query) {
                for (var E = "", R = 0, z = g._parts.query.split("&"), b = z.length; R < b; R++) {
                    var y = (z[R] || "").split("=");
                    E += "&" + s.decodeQuery(y[0], this._parts.escapeQuerySpace).replace(/&/g, "%26"),
                    y[1] !== void 0 && (E += "=" + s.decodeQuery(y[1], this._parts.escapeQuerySpace).replace(/&/g, "%26"))
                }
                w += "?" + E.substring(1)
            }
            return w += s.decodeQuery(g.hash(), !0),
            w
        }
        ,
        l.absoluteTo = function(g) {
            var w = this.clone(), E = ["protocol", "username", "password", "hostname", "port"], R, z, b;
            if (this._parts.urn)
                throw new Error("URNs do not have any generally defined hierarchical components");
            if (g instanceof s || (g = new s(g)),
            w._parts.protocol || (w._parts.protocol = g._parts.protocol,
            this._parts.hostname))
                return w;
            for (z = 0; b = E[z]; z++)
                w._parts[b] = g._parts[b];
            return w._parts.path ? (w._parts.path.substring(-2) === ".." && (w._parts.path += "/"),
            w.path().charAt(0) !== "/" && (R = g.directory(),
            R = R || (g.path().indexOf("/") === 0 ? "/" : ""),
            w._parts.path = (R ? R + "/" : "") + w._parts.path,
            w.normalizePath())) : (w._parts.path = g._parts.path,
            w._parts.query || (w._parts.query = g._parts.query)),
            w.build(),
            w
        }
        ,
        l.relativeTo = function(g) {
            var w = this.clone().normalize(), E, R, z, b, y;
            if (w._parts.urn)
                throw new Error("URNs do not have any generally defined hierarchical components");
            if (g = new s(g).normalize(),
            E = w._parts,
            R = g._parts,
            b = w.path(),
            y = g.path(),
            b.charAt(0) !== "/")
                throw new Error("URI is already relative");
            if (y.charAt(0) !== "/")
                throw new Error("Cannot calculate a URI relative to another relative URI");
            if (E.protocol === R.protocol && (E.protocol = null),
            E.username !== R.username || E.password !== R.password || E.protocol !== null || E.username !== null || E.password !== null)
                return w.build();
            if (E.hostname === R.hostname && E.port === R.port)
                E.hostname = null,
                E.port = null;
            else
                return w.build();
            if (b === y)
                return E.path = "",
                w.build();
            if (z = s.commonPath(b, y),
            !z)
                return w.build();
            var D = R.path.substring(z.length).replace(/[^\/]*$/, "").replace(/.*?\//g, "../");
            return E.path = D + E.path.substring(z.length) || "./",
            w.build()
        }
        ,
        l.equals = function(g) {
            var w = this.clone(), E = new s(g), R = {}, z = {}, b = {}, y, D, I;
            if (w.normalize(),
            E.normalize(),
            w.toString() === E.toString())
                return !0;
            if (y = w.query(),
            D = E.query(),
            w.query(""),
            E.query(""),
            w.toString() !== E.toString() || y.length !== D.length)
                return !1;
            R = s.parseQuery(y, this._parts.escapeQuerySpace),
            z = s.parseQuery(D, this._parts.escapeQuerySpace);
            for (I in R)
                if (u.call(R, I)) {
                    if (f(R[I])) {
                        if (!d(R[I], z[I]))
                            return !1
                    } else if (R[I] !== z[I])
                        return !1;
                    b[I] = !0
                }
            for (I in z)
                if (u.call(z, I) && !b[I])
                    return !1;
            return !0
        }
        ,
        l.preventInvalidHostname = function(g) {
            return this._parts.preventInvalidHostname = !!g,
            this
        }
        ,
        l.duplicateQueryParameters = function(g) {
            return this._parts.duplicateQueryParameters = !!g,
            this
        }
        ,
        l.escapeQuerySpace = function(g) {
            return this._parts.escapeQuerySpace = !!g,
            this
        }
        ,
        s
    })
}
)(ug);
const wf = ug.exports;
function Ev(o) {
    return o.substring(0, o.lastIndexOf("/") + 1).trim()
}
let wr;
function cg() {
    if (wr)
        return wr;
    let o = Ev(document.location.href)
      , e = document.querySelector("base");
    return wr = e ? e.getAttribute("href") : o,
    wr = wr || o,
    wr
}
class ra {
    constructor(e) {
        this._uri = wf(e),
        this._base = wf(cg()),
        this._uri.normalize(),
        this._base.normalize()
    }
    get base() {
        return this._base
    }
    get relative() {
        return this._uri.toString().replace(this._base.toString(), "")
    }
    get external() {
        return this.hostname != this._base.hostname()
    }
    get scheme() {
        return this._uri.scheme() || this._base.scheme()
    }
    set scheme(e) {
        this._uri.scheme(e)
    }
    get hostname() {
        return this._uri.hostname() || this._base.hostname()
    }
    set hostname(e) {
        this._uri.hostname(e)
    }
    get port() {
        return this._uri.port()
    }
    set port(e) {
        this._uri.port(e)
    }
    get username() {
        return this._uri.username()
    }
    set username(e) {
        this._uri.username(e)
    }
    get password() {
        return this._uri.password()
    }
    set password(e) {
        this._uri.password(e)
    }
    get path() {
        return this._uri.path()
    }
    set path(e) {
        this._uri.path(e)
    }
    get tld() {
        return this._uri.tld()
    }
    set tld(e) {
        this._uri.tld(e)
    }
    get hash() {
        return this._uri.hash()
    }
    set hash(e) {
        this._uri.hash(e)
    }
    get segment() {
        return this._uri.segment()
    }
    set segment(e) {
        this._uri.segment(e)
    }
    get query() {
        return this._uri.query(!0)
    }
    set query(e) {
        this._uri.query(e)
    }
    equals(e=void 0) {
        return e instanceof ra ? this._uri.equals(e._uri) : this._uri.equals(e.toString())
    }
    toString() {
        return this._uri.toString()
    }
}
class Av extends _r {
    constructor() {
        super(),
        this._crossroads = Mv.create(),
        this._crossroads.ignoreState = !0,
        this._crossroads.shouldTypecast = !0,
        this._previous = void 0,
        this._current = new ra(window.location.href),
        this.routedHandler = null,
        this.exitHandlers = new WeakMap,
        document.querySelector("base") || console.warn(`No <base> tag defined, Router may not work properly [computed base: ${cg()}].`)
    }
    get previous() {
        return this._previous
    }
    get current() {
        return this._current
    }
    add(e, t) {
        const n = this._crossroads.addRoute(e);
        return typeof t == "function" && (this.routedHandler && n.matched.add(this.routedHandler, null, 10),
        n.matched.add(t, null, 0)),
        n
    }
    remove(e) {
        this._crossroads.removeRoute(e),
        e.dispose()
    }
    catchAll(e) {
        this._crossroads.bypassed.add(e)
    }
    removeCatchAll(e) {
        this._crossroads.bypassed.remove(e)
    }
    routed(e, t=10) {
        this.routedHandler = e,
        this._crossroads._routes.forEach(n => n.matched.add(this.routedHandler, null, 10))
    }
    removeRouted(e) {
        this._crossroads._routes.forEach(t => t.matched.remove(this.routedHandler, null, 10)),
        this.routedHandler = null
    }
    set(e) {
        e = new ra(typeof e == "string" ? e : ""),
        !this.current.equals(e) && (this._previous = this._current,
        this._current = e,
        this._crossroads.parse(this._current.relative),
        this.emit("change", this._current.toString()))
    }
}
class sa extends vr {
    constructor(e) {
        super(e),
        this.router = new Av,
        this.catchAll = this.catchAll.bind(this),
        this.stateChanged = this.stateChanged.bind(this),
        this.routed = this.routed.bind(this),
        this.dependencies.add(Nn)
    }
    get enabled() {
        return this._enabled
    }
    set enabled(e) {
        this._enabled != e && (this._enabled = e,
        e ? (this.router.routed(this.routed),
        this.router.catchAll(this.catchAll),
        this.bootstrap.get(Nn).on("change", this.stateChanged)) : (this.router.removeRouted(this.routed),
        this.router.removeCatchAll(this.catchAll),
        this.bootstrap.get(Nn).off("change", this.stateChanged)))
    }
    get current() {
        return this.router.current
    }
    get previous() {
        return this.router.previous
    }
    add(e, t) {
        return this.router.add(e, t)
    }
    remove(e) {
        this.router.remove(e)
    }
    set(e) {
        this.router.set(e)
    }
    async before() {
        let e = this.bootstrap.get(Nn);
        (!e.state || !e.state.url) && (e.state.url = this.router.current.toString())
    }
    routed(e) {
        if (!this.router.previous.equals(this.router.current)) {
            Wi.exports.debug("routeChanged", e);
            let t = this.bootstrap.get(Nn)
              , n = t.state;
            return n.url = this.router.current.toString(),
            t.state = n,
            !0
        }
        return !1
    }
    catchAll(e) {
        this.routed(e) && this.bootstrap.run()
    }
    stateChanged(e) {
        Wi.exports.debug("stateChanged", e),
        this.router.set(e && e.url ? e.url : "")
    }
}
class Wo extends vr {
    constructor(e) {
        super(e),
        this.dependencies.add(sa),
        this.wrapper = "#root",
        this.selector = "> *:first-child",
        this._previous = null,
        this.autoRemove = !0
    }
    get priority() {
        return 1
    }
    get previous() {
        return this._previous
    }
    get current() {
        return this._current
    }
    set current(e) {
        this._current != e && (this._previous = this._current,
        this._current = e,
        this.emit("page", e))
    }
    async init() {
        this.root = document.querySelector(this.wrapper)
    }
    async run() {
        this._current = document.querySelector(this.wrapper + " " + this.selector)
    }
    async after() {
        this.autoRemove && this.removePrevious()
    }
    removePrevious() {
        this.previous && this.removeElement(this.previous)
    }
    removeElement(e) {
        e && e.parentElement && e.parentElement.removeChild(e)
    }
}
class BT extends vr {
    constructor(e) {
        super(e),
        this.historyChanged = this.historyChanged.bind(this),
        this.pageChanged = this.pageChanged.bind(this),
        this.dependencies.add(Nn),
        this.dependencies.add(Wo),
        this._first = !0,
        window.history.state || window.history.replaceState({
            url: window.location.href
        }, null)
    }
    get priority() {
        return 5
    }
    get enabled() {
        return this._enabled
    }
    set enabled(e) {
        this._enabled != e && (this._enabled = e,
        e ? (window.addEventListener("popstate", this.historyChanged),
        this.bootstrap.get(Wo).on("page", this.pageChanged)) : (window.removeEventListener("popstate", this.historyChanged),
        this.bootstrap.get(Wo).off("page", this.pageChanged)))
    }
    historyChanged(e) {
        Wi.exports.debug("historyChanged", window.history.state),
        this.bootstrap.get(Nn),
        this.bootstrap.get(Nn).state = window.history.state
    }
    pageChanged(e) {
        const t = this.bootstrap.get(Nn).state;
        window.history.pushState(t, t.title, t.url)
    }
}
function wc(o) {
    var e = [];
    return hg(o, e),
    e
}
function hg(o, e) {
    for (var t = 0; t < o.length; t++) {
        var n = o[t];
        Array.isArray(n) ? hg(n, e) : e.push(n)
    }
}
class Cv extends _r {
    constructor() {
        super(),
        this.parallel = !0,
        this.exceptions = !1,
        this.waiting = new Set,
        this.pending = new Set,
        this.progresses = new Map,
        this.loaded = new Map,
        this.pendingCheckInterval = 500
    }
    get progress() {
        if (this.progresses.size != 0) {
            let e = 0;
            return this.progresses.forEach(t => e += t),
            e / this.progresses.size
        }
        return 1
    }
    get complete() {
        return this.progress == 1
    }
    get size() {
        return this.waiting.size + this.pending.size + this.loaded.size
    }
    get(e) {
        return this.loaded.get(e)
    }
    has(e) {
        return this.waiting.has(e) || this.pending.has(e) || this.loaded.has(e)
    }
    add(...e) {
        return e = wc(e),
        e.forEach(t => {
            this.accepts(t) && !this.waiting.has(t) && !this.pending.has(t) && !this.loaded.has(t) && (this.waiting.add(t),
            this.progresses.set(t, 0))
        }
        ),
        this
    }
    delete(...e) {
        return e = wc(e),
        e.forEach(t => {
            this.waiting.delete(t),
            this.pending.delete(t),
            this.loaded.delete(t),
            this.progresses.delete(t)
        }
        ),
        this
    }
    reset() {
        this.lastProgress = null,
        this.waiting = new Set,
        this.pending = new Set,
        this.progresses = new Map,
        this.loaded = new Map
    }
    isWaiting(e) {
        return this.waiting.has(e)
    }
    isPending(e) {
        return this.pending.has(e)
    }
    isLoaded(e) {
        return this.loaded.has(e)
    }
    accepts(e) {
        return !0
    }
    async loadItem(e) {
        return e
    }
    async allSettled(e) {
        return new Promise( (t, n) => {
            let i = e.length
              , r = 0;
            if (i == 0)
                return t();
            e.forEach(s => {
                s.then( () => {
                    r++
                }
                ).catch(a => {
                    throw r++,
                    a
                }
                ).finally( () => {
                    r == i && t()
                }
                )
            }
            )
        }
        )
    }
    async sequentialLoad() {
        for (this.waiting.size == 0 && this.triggerProgress(); this.waiting.size > 0; ) {
            let e = this.waiting.values().next().value;
            this.waiting.delete(e),
            this.pending.add(e);
            try {
                let t = await this.loadItem(e);
                this.loaded.set(e, t),
                this.progresses.set(e, 1),
                this.pending.delete(e),
                this.triggerProgress()
            } catch (t) {
                if (this.loaded.set(e, null),
                this.progresses.set(e, 1),
                this.pending.delete(e),
                this.triggerProgress(),
                this.exceptions)
                    throw t
            }
        }
    }
    async parallelLoad() {
        for (this.waiting.size == 0 && this.triggerProgress(); this.waiting.size > 0; ) {
            let e = this.waiting.values().next().value;
            this.waiting.delete(e),
            this.pending.add(e),
            this.loadItem(e).then(t => {
                this.loaded.set(e, t),
                this.progresses.set(e, 1),
                this.pending.delete(e),
                this.triggerProgress()
            }
            ).catch(t => {
                if (this.loaded.set(e, null),
                this.progresses.set(e, 1),
                this.pending.delete(e),
                this.triggerProgress(),
                this.exceptions)
                    throw t
            }
            )
        }
        return this.awaitPending()
    }
    async awaitPending() {
        for (; this.pending.size > 0; )
            await this.sleep(this.pendingCheckInterval)
    }
    async sleep(e) {
        return new Promise( (t, n) => {
            setTimeout(t, e)
        }
        )
    }
    async load(...e) {
        return this.add(...e),
        this.parallel ? await this.parallelLoad() : await this.sequentialLoad(),
        this.emit("complete", this.loaded),
        this.loaded.forEach( (t, n) => this.progresses.delete(n)),
        this.loaded
    }
    triggerProgress() {
        let e = this.progress;
        this.lastProgress != e && (this.lastProgress = e,
        this.emit("progress", e))
    }
}
class Lv extends Cv {
    constructor({method: e="GET", params: t={}, headers: n={}, body: i=null, cache: r="no-cache", redirect: s="follow", callback: a=async () => {}
    }={}) {
        super(),
        this.options = {
            method: e,
            params: t,
            headers: n,
            body: i,
            cache: r,
            redirect: s
        },
        this.responses = new Map,
        this.callback = a
    }
    accepts(e) {
        return typeof e == "string"
    }
    getResponse(e) {
        this.response.get(e)
    }
    async loadItem(e) {
        Wi.exports.debug("loadItem", e);
        let t = Object.entries(this.options.params).map(n => n.join("=")).join("&");
        return t != "" && (t = (e.indexOf("?") >= 0 ? "&" : "?") + t),
        window.fetch(e + t, this.options).then(async n => (await this.callback(n),
        this.responses.set(e, n),
        this._value = await n.text(),
        this._value))
    }
}
var fg = {
    exports: {}
};
const Rv = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "label", "legend", "li", "link", "main", "map", "mark", "math", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rb", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "slot", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr"];
(function(o) {
    o.exports = Rv
}
)(fg);
const Pv = fg.exports
  , Iv = /\s?<!doctype html>|(<html\b[^>]*>|<body\b[^>]*>|<x-[^>]+>)+/i
  , Fv = new RegExp(Pv.map(o => `<${o}\\b[^>]*>`).join("|"),"i");
var Ov = o => Iv.test(o) || Fv.test(o);
function dg(o) {
    return Ov(o) ? Nv(o) : zv(o) ? o : Uv(o) ? kv(o) : null
}
function Nv(o) {
    var e = document.createElement("div");
    return e.innerHTML = o.trim(),
    e.childNodes && e.childNodes.length > 1 ? e.childNodes : e.firstChild
}
function kv(o) {
    return document.querySelector(o)
}
function zv(o) {
    return o instanceof window.Node
}
const Uv = (o => e => {
    try {
        o(e)
    } catch {
        return !1
    }
    return !0
}
)(o => document.createDocumentFragment().querySelector(o));
class Bv extends Lv {
    constructor(e={}) {
        e.headers = e.headers ? e.headers : {
            "X-Requested-With": "XMLHttpRequest"
        },
        super(e)
    }
    accepts(e) {
        return typeof e == "string"
    }
    async loadItem(e) {
        return dg(await super.loadItem(e))
    }
}
function Mf(o, e) {
    return e = e || "\\s",
    o.replace(new RegExp("[" + e + "]+$","g"), "")
}
class VT extends vr {
    constructor(e) {
        super(e),
        this.dependencies.add(Wo),
        this.dependencies.add(sa),
        this.dependencies.add(Nn),
        this.loader = new Bv,
        this.prepend = !0,
        this._current = null,
        this.transform = async t => t
    }
    get priority() {
        return 1
    }
    get pageModule() {
        return this.bootstrap.get(Wo)
    }
    async run() {
        let e = this.pageModule.current
          , t = this.bootstrap.get(sa).router
          , n = t.current.toString();
        if (t.previous || (this._current = n),
        e && t.previous && Mf(this._current, "/") != Mf(n, "/")) {
            await this.loader.load(n);
            let i = this.loader.get(n);
            if (i) {
                i = await this.transform(i),
                this.loader.delete(n),
                this.insertElement(i),
                this.pageModule.current = i;
                const r = this.loader.responses.get(n);
                if (r.redirected) {
                    const s = this.bootstrap.get(Nn).state;
                    s.url = r.url,
                    window.history.replaceState(s, s.title, s.url)
                }
                this._current = r.redirected ? r.url : n
            }
        }
    }
    insertElement(e) {
        e && (this.prepend ? e instanceof NodeList ? e.forEach(t => this.pageModule.root.insertBefore(t, this.pageModule.root.firstChild)) : this.pageModule.root.insertBefore(e, this.pageModule.root.firstChild) : e instanceof NodeList ? e.forEach(t => this.pageModule.root.appendChild(t)) : this.pageModule.root.appendChild(e))
    }
}
var Vv = {
    exports: {}
};
(function(o) {
    (function(e, t) {
        o.exports ? o.exports = t() : e.parseSrcset = t()
    }
    )(hi, function() {
        return function(e) {
            function t(M) {
                return M === " " || M === "	" || M === `
` || M === "\f" || M === "\r"
            }
            function n(M) {
                var T, L = M.exec(e.substring(p));
                if (L)
                    return T = L[0],
                    p += T.length,
                    T
            }
            for (var i = e.length, r = /^[ \t\n\r\u000c]+/, s = /^[, \t\n\r\u000c]+/, a = /^[^ \t\n\r\u000c]+/, l = /[,]+$/, u = /^\d+$/, c = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, h, f, m, _, d, p = 0, v = []; ; ) {
                if (n(s),
                p >= i)
                    return v;
                h = n(a),
                f = [],
                h.slice(-1) === "," ? (h = h.replace(l, ""),
                S()) : x()
            }
            function x() {
                for (n(r),
                m = "",
                _ = "in descriptor"; ; ) {
                    if (d = e.charAt(p),
                    _ === "in descriptor")
                        if (t(d))
                            m && (f.push(m),
                            m = "",
                            _ = "after descriptor");
                        else if (d === ",") {
                            p += 1,
                            m && f.push(m),
                            S();
                            return
                        } else if (d === "(")
                            m = m + d,
                            _ = "in parens";
                        else if (d === "") {
                            m && f.push(m),
                            S();
                            return
                        } else
                            m = m + d;
                    else if (_ === "in parens")
                        if (d === ")")
                            m = m + d,
                            _ = "in descriptor";
                        else if (d === "") {
                            f.push(m),
                            S();
                            return
                        } else
                            m = m + d;
                    else if (_ === "after descriptor" && !t(d))
                        if (d === "") {
                            S();
                            return
                        } else
                            _ = "in descriptor",
                            p -= 1;
                    p += 1
                }
            }
            function S() {
                var M = !1, T, L, P, A, C = {}, N, G, q, g, w;
                for (A = 0; A < f.length; A++)
                    N = f[A],
                    G = N[N.length - 1],
                    q = N.substring(0, N.length - 1),
                    g = parseInt(q, 10),
                    w = parseFloat(q),
                    u.test(q) && G === "w" ? ((T || L) && (M = !0),
                    g === 0 ? M = !0 : T = g) : c.test(q) && G === "x" ? ((T || L || P) && (M = !0),
                    w < 0 ? M = !0 : L = w) : u.test(q) && G === "h" ? ((P || L) && (M = !0),
                    g === 0 ? M = !0 : P = g) : M = !0;
                M ? console && console.log && console.log("Invalid srcset descriptor found in '" + e + "' at '" + N + "'.") : (C.url = h,
                T && (C.w = T),
                L && (C.d = L),
                P && (C.h = P),
                v.push(C))
            }
        }
    })
}
)(Vv);
class pg extends _r {
    constructor(e) {
        super(),
        this.element = e
    }
    async init() {}
    async attach() {}
    async detach() {}
    async destroy() {}
}
const Sf = function(...o) {
    return console && console.error && console.error.apply(console, o),
    null
};
class Gv {
    constructor({selector: e="html"}={}) {
        this.selector = e,
        this.element = dg(this.selector),
        this.registry = new Map,
        this.elements = new Map,
        this.initFns = ["init", "attach"],
        this.destroyFns = ["detach", "destroy"],
        this.creator = (t, n) => new t(n)
    }
    register(e) {
        this.registry = new Map([...this.registry].concat(Object.entries(e)))
    }
    needSetup(e) {
        return "component"in e.dataset && this.registry.has(e.dataset.component) && !this.elements.has(e)
    }
    get(e) {
        return this.elements.has(e) ? this.elements.get(e) : null
    }
    async setup() {
        await this.clean();
        let e = [this.element].concat(...this.element.querySelectorAll("[data-component]")).filter(t => this.needSetup(t)).map(t => this.create(t));
        return await this.call(e, this.initFns),
        e
    }
    create(e) {
        let t = e.dataset.component;
        if (!this.registry.has(t))
            return Sf("Component not found: ", t);
        let n = this.registry.get(t)
          , i = this.creator(n, e);
        return i ? (this.elements.set(e, i),
        i) : Sf("Component not created", t)
    }
    async call(e, t) {
        for (let n of t)
            for (let i of e)
                i instanceof pg && typeof i[n] == "function" && await i[n]()
    }
    async clean() {
        for await(let[e,t] of this.elements.entries())
            e.compareDocumentPosition(document.body) & Node.DOCUMENT_POSITION_CONTAINS || (await this.call([t], this.destroyFns),
            this.elements.delete(e))
    }
}
class mg extends pg {
    constructor(e, t) {
        super(e),
        this.__bootstrap = t
    }
    get bootstrap() {
        return this.__bootstrap
    }
}
class GT extends vr {
    constructor(e) {
        super(e),
        this.selector = "html"
    }
    get priority() {
        return -2
    }
    build() {
        this._components = new Gv(this.selector),
        this._components.creator = (e, t) => e.prototype instanceof mg ? new e(t,this.bootstrap) : new e(t)
    }
    get selector() {
        return this._selector
    }
    set selector(e) {
        this._selector != e && (this._selector = e,
        this.build())
    }
    get components() {
        return this._components || this.build(),
        this._components
    }
    get(e) {
        return this.components.get(e)
    }
    register(e) {
        Wi.exports.debug("register", e),
        this.components.register(e)
    }
    async run() {
        await this.components.setup()
    }
}
class HT extends vr {
    constructor(e) {
        super(e),
        this.dependencies.add(Nn),
        this.dependencies.add(sa),
        this.selector = 'a:not(.no-history):not([target="_blank"])',
        this.linkClicked = this.linkClicked.bind(this),
        this.enabled = !0
    }
    get priority() {
        return 10
    }
    get enabled() {
        return this._enabled
    }
    set enabled(e) {
        this._enabled != e && (this._enabled = e,
        e && this.links && this.links.forEach(t => t.removeEventListener("click", this.linkClicked)))
    }
    linkClicked(e) {
        let t = e.currentTarget.getAttribute("href").split("#")[0];
        new ra(t).external || (e.preventDefault(),
        this.bootstrap.get(sa).set(t))
    }
    after() {
        this.links && this.links.forEach(e => e.removeEventListener("click", this.linkClicked)),
        this._enabled && (this.links = document.querySelectorAll(this.selector),
        this.links && this.links.forEach(e => e.addEventListener("click", this.linkClicked)))
    }
}
class gg extends _r {
    constructor({sizer: e=null, selector: t="html"}={}) {
        super(),
        this.width = 1,
        this.height = 1,
        this.minWidth = 0,
        this.minHeight = 0,
        this.viewportWidth = 0,
        this.viewportHeight = 0,
        this.widthOnly = !1,
        this.orientation = null,
        this._medias = new Map,
        this.medias = {},
        this.onResize = this.onResize.bind(this),
        this.mediaDisabled = this.mediaDisabled.bind(this),
        this.mediaEnabled = this.mediaEnabled.bind(this),
        !(typeof window > "u") && (this.sizer = e || window,
        this.element = document.querySelector(t),
        this.attach(),
        this.resize())
    }
    attach() {
        typeof window > "u" || (window.addEventListener("resize", this.onResize),
        window.addEventListener("orientationchange", this.onResize))
    }
    detach() {
        typeof window > "u" || (window.removeEventListener("resize", this.onResize),
        window.removeEventListener("orientationchange", this.onResize))
    }
    onResize(e) {
        this.computeResize()
    }
    async resize() {
        await this.computeResize(!0)
    }
    async computeResize(e=!1) {
        if (typeof window > "u")
            return;
        let t = this.width
          , n = this.height;
        this.sizer == window ? (this.innerWidth = document.documentElement.clientWidth,
        this.outerWidth = window.innerWidth,
        this.innerHeight = document.documentElement.clientHeight,
        this.outerHeight = window.innerHeight) : (this.innerWidth = this.outerWidth = this.sizer.offsetWidth,
        this.innerHeight = this.outerHeight = this.sizer.offsetHeight),
        this.viewportWidth = Math.min(this.innerWidth, this.outerWidth),
        this.viewportHeight = Math.min(this.innerHeight, this.outerHeight),
        this.width = this.viewportWidth < this.minWidth ? this.minWidth : this.viewportWidth,
        this.height = this.viewportHeight < this.minHeight ? this.minHeight : this.viewportHeight,
        this.orientation = this.width < this.height ? "portrait" : "landscape";
        var i = Array.from(this._medias.values()).filter(r => r.update());
        (!this.widthOnly && (t != this.width || n != this.height) || this.widthOnly && t != this.width || e) && (this.computeResize(),
        await this.emitAsync("pre-resize"),
        await this.emitAsync("resize"),
        await this.emitAsync("post-resize"),
        this.computeResize()),
        i.length && this.emit("media", i.map(r => r.name), i)
    }
    add(e) {
        e.viewport = this;
        let t = new Hv(e);
        return t.on("disable", this.mediaDisabled),
        t.on("enable", this.mediaEnabled),
        this._medias.set(t.name, t),
        this.medias[t.name] = !1,
        t.update(),
        t
    }
    remove(e) {
        delete this.medias[e.name],
        this._medias.delete(e.name),
        e.off("disable", this.mediaDisabled),
        e.off("enable", this.mediaEnabled)
    }
    get(e) {
        return this._medias.get(e)
    }
    mediaDisabled(e) {
        this.medias[e.name] = !1,
        e.addClass && this.element.classList.remove(e.classPrefix + e.name)
    }
    mediaEnabled(e) {
        this.medias[e.name] = !0,
        e.addClass && this.element.classList.add(e.classPrefix + e.name)
    }
}
class Hv extends _r {
    constructor({viewport: e=new gg, name: t="", minWidth: n=-1 / 0, minHeight: i=-1 / 0, maxWidth: r=1 / 0, maxHeight: s=1 / 0, addClass: a=!0, classPrefix: l="", condition: u=null, meta: c=null, media: h=null}={}) {
        super(),
        this.viewport = e,
        this.name = t,
        this.minWidth = n,
        this.minHeight = i,
        this.maxWidth = r,
        this.maxHeight = s,
        this.addClass = a,
        this.classPrefix = l,
        this.condition = u,
        this.meta = c,
        this.media = h,
        this.active = !1
    }
    update() {
        if (typeof window > "u")
            return !1;
        var e = this.viewport.width >= this.minWidth && this.viewport.width < this.maxWidth && this.viewport.height >= this.minHeight && this.viewport.height < this.maxHeight && (this.media ? window.matchMedia(this.media).matches : !0);
        return typeof this.condition == "function" && (e = this.condition(e)),
        this.active && !e ? (this.active = !1,
        this.emit("disable", this),
        !0) : !this.active && e ? (this.active = !0,
        this.emit("enable", this),
        !0) : !1
    }
}
class WT extends vr {
    constructor(e) {
        super(e),
        this.viewport = new gg
    }
    async after() {
        await this.viewport.resize()
    }
}
var _g = {
    exports: {}
}, Vs = typeof Reflect == "object" ? Reflect : null, Df = Vs && typeof Vs.apply == "function" ? Vs.apply : function(e, t, n) {
    return Function.prototype.apply.call(e, t, n)
}
, xl;
Vs && typeof Vs.ownKeys == "function" ? xl = Vs.ownKeys : Object.getOwnPropertySymbols ? xl = function(e) {
    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
}
: xl = function(e) {
    return Object.getOwnPropertyNames(e)
}
;
function Wv(o) {
    console && console.warn && console.warn(o)
}
var vg = Number.isNaN || function(e) {
    return e !== e
}
;
function ot() {
    ot.init.call(this)
}
_g.exports = ot;
_g.exports.once = Yv;
ot.EventEmitter = ot;
ot.prototype._events = void 0;
ot.prototype._eventsCount = 0;
ot.prototype._maxListeners = void 0;
var Tf = 10;
function Hl(o) {
    if (typeof o != "function")
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof o)
}
Object.defineProperty(ot, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
        return Tf
    },
    set: function(o) {
        if (typeof o != "number" || o < 0 || vg(o))
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + o + ".");
        Tf = o
    }
});
ot.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null),
    this._eventsCount = 0),
    this._maxListeners = this._maxListeners || void 0
}
;
ot.prototype.setMaxListeners = function(e) {
    if (typeof e != "number" || e < 0 || vg(e))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
    return this._maxListeners = e,
    this
}
;
function xg(o) {
    return o._maxListeners === void 0 ? ot.defaultMaxListeners : o._maxListeners
}
ot.prototype.getMaxListeners = function() {
    return xg(this)
}
;
ot.prototype.emit = function(e) {
    for (var t = [], n = 1; n < arguments.length; n++)
        t.push(arguments[n]);
    var i = e === "error"
      , r = this._events;
    if (r !== void 0)
        i = i && r.error === void 0;
    else if (!i)
        return !1;
    if (i) {
        var s;
        if (t.length > 0 && (s = t[0]),
        s instanceof Error)
            throw s;
        var a = new Error("Unhandled error." + (s ? " (" + s.message + ")" : ""));
        throw a.context = s,
        a
    }
    var l = r[e];
    if (l === void 0)
        return !1;
    if (typeof l == "function")
        Df(l, this, t);
    else
        for (var u = l.length, c = Sg(l, u), n = 0; n < u; ++n)
            Df(c[n], this, t);
    return !0
}
;
function yg(o, e, t, n) {
    var i, r, s;
    if (Hl(t),
    r = o._events,
    r === void 0 ? (r = o._events = Object.create(null),
    o._eventsCount = 0) : (r.newListener !== void 0 && (o.emit("newListener", e, t.listener ? t.listener : t),
    r = o._events),
    s = r[e]),
    s === void 0)
        s = r[e] = t,
        ++o._eventsCount;
    else if (typeof s == "function" ? s = r[e] = n ? [t, s] : [s, t] : n ? s.unshift(t) : s.push(t),
    i = xg(o),
    i > 0 && s.length > i && !s.warned) {
        s.warned = !0;
        var a = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        a.name = "MaxListenersExceededWarning",
        a.emitter = o,
        a.type = e,
        a.count = s.length,
        Wv(a)
    }
    return o
}
ot.prototype.addListener = function(e, t) {
    return yg(this, e, t, !1)
}
;
ot.prototype.on = ot.prototype.addListener;
ot.prototype.prependListener = function(e, t) {
    return yg(this, e, t, !0)
}
;
function jv() {
    if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn),
        this.fired = !0,
        arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
}
function bg(o, e, t) {
    var n = {
        fired: !1,
        wrapFn: void 0,
        target: o,
        type: e,
        listener: t
    }
      , i = jv.bind(n);
    return i.listener = t,
    n.wrapFn = i,
    i
}
ot.prototype.once = function(e, t) {
    return Hl(t),
    this.on(e, bg(this, e, t)),
    this
}
;
ot.prototype.prependOnceListener = function(e, t) {
    return Hl(t),
    this.prependListener(e, bg(this, e, t)),
    this
}
;
ot.prototype.removeListener = function(e, t) {
    var n, i, r, s, a;
    if (Hl(t),
    i = this._events,
    i === void 0)
        return this;
    if (n = i[e],
    n === void 0)
        return this;
    if (n === t || n.listener === t)
        --this._eventsCount === 0 ? this._events = Object.create(null) : (delete i[e],
        i.removeListener && this.emit("removeListener", e, n.listener || t));
    else if (typeof n != "function") {
        for (r = -1,
        s = n.length - 1; s >= 0; s--)
            if (n[s] === t || n[s].listener === t) {
                a = n[s].listener,
                r = s;
                break
            }
        if (r < 0)
            return this;
        r === 0 ? n.shift() : qv(n, r),
        n.length === 1 && (i[e] = n[0]),
        i.removeListener !== void 0 && this.emit("removeListener", e, a || t)
    }
    return this
}
;
ot.prototype.off = ot.prototype.removeListener;
ot.prototype.removeAllListeners = function(e) {
    var t, n, i;
    if (n = this._events,
    n === void 0)
        return this;
    if (n.removeListener === void 0)
        return arguments.length === 0 ? (this._events = Object.create(null),
        this._eventsCount = 0) : n[e] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete n[e]),
        this;
    if (arguments.length === 0) {
        var r = Object.keys(n), s;
        for (i = 0; i < r.length; ++i)
            s = r[i],
            s !== "removeListener" && this.removeAllListeners(s);
        return this.removeAllListeners("removeListener"),
        this._events = Object.create(null),
        this._eventsCount = 0,
        this
    }
    if (t = n[e],
    typeof t == "function")
        this.removeListener(e, t);
    else if (t !== void 0)
        for (i = t.length - 1; i >= 0; i--)
            this.removeListener(e, t[i]);
    return this
}
;
function wg(o, e, t) {
    var n = o._events;
    if (n === void 0)
        return [];
    var i = n[e];
    return i === void 0 ? [] : typeof i == "function" ? t ? [i.listener || i] : [i] : t ? Xv(i) : Sg(i, i.length)
}
ot.prototype.listeners = function(e) {
    return wg(this, e, !0)
}
;
ot.prototype.rawListeners = function(e) {
    return wg(this, e, !1)
}
;
ot.listenerCount = function(o, e) {
    return typeof o.listenerCount == "function" ? o.listenerCount(e) : Mg.call(o, e)
}
;
ot.prototype.listenerCount = Mg;
function Mg(o) {
    var e = this._events;
    if (e !== void 0) {
        var t = e[o];
        if (typeof t == "function")
            return 1;
        if (t !== void 0)
            return t.length
    }
    return 0
}
ot.prototype.eventNames = function() {
    return this._eventsCount > 0 ? xl(this._events) : []
}
;
function Sg(o, e) {
    for (var t = new Array(e), n = 0; n < e; ++n)
        t[n] = o[n];
    return t
}
function qv(o, e) {
    for (; e + 1 < o.length; e++)
        o[e] = o[e + 1];
    o.pop()
}
function Xv(o) {
    for (var e = new Array(o.length), t = 0; t < e.length; ++t)
        e[t] = o[t].listener || o[t];
    return e
}
function Yv(o, e) {
    return new Promise(function(t, n) {
        function i(s) {
            o.removeListener(e, r),
            n(s)
        }
        function r() {
            typeof o.removeListener == "function" && o.removeListener("error", i),
            t([].slice.call(arguments))
        }
        Dg(o, e, r, {
            once: !0
        }),
        e !== "error" && Kv(o, i, {
            once: !0
        })
    }
    )
}
function Kv(o, e, t) {
    typeof o.on == "function" && Dg(o, "error", e, t)
}
function Dg(o, e, t, n) {
    if (typeof o.on == "function")
        n.once ? o.once(e, t) : o.on(e, t);
    else if (typeof o.addEventListener == "function")
        o.addEventListener(e, function i(r) {
            n.once && o.removeEventListener(e, i),
            t(r)
        });
    else
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof o)
}
var $v = {
    exports: {}
};
(function(o) {
    (function e(t, n, i) {
        var r = function(l) {
            return Object.prototype.toString.call(l) === "[object Array]"
        };
        function s(l, u) {
            if (!(this instanceof s))
                return new s(l,u);
            r(l) ? (u = l[1],
            l = l[0]) : typeof l == "object" && l && (u = l.y,
            l = l.x),
            this.x = s.clean(l || 0),
            this.y = s.clean(u || 0)
        }
        s.prototype = {
            change: function(l) {
                if (typeof l == "function")
                    this.observers ? this.observers.push(l) : this.observers = [l];
                else if (this.observers && this.observers.length)
                    for (var u = this.observers.length - 1; u >= 0; u--)
                        this.observers[u](this, l);
                return this
            },
            ignore: function(l) {
                if (this.observers)
                    if (!l)
                        this.observers = [];
                    else
                        for (var u = this.observers, c = u.length; c--; )
                            u[c] === l && u.splice(c, 1);
                return this
            },
            set: function(l, u, c) {
                if (typeof l != "number" && (c = u,
                u = l.y,
                l = l.x),
                this.x === l && this.y === u)
                    return this;
                var h = null;
                if (c !== !1 && this.observers && this.observers.length && (h = this.clone()),
                this.x = s.clean(l),
                this.y = s.clean(u),
                c !== !1)
                    return this.change(h)
            },
            zero: function() {
                return this.set(0, 0)
            },
            clone: function() {
                return new this.constructor(this.x,this.y)
            },
            negate: function(l) {
                return l ? new this.constructor(-this.x,-this.y) : this.set(-this.x, -this.y)
            },
            add: function(l, u, c) {
                return typeof l != "number" && (c = u,
                r(l) ? (u = l[1],
                l = l[0]) : (u = l.y,
                l = l.x)),
                l += this.x,
                u += this.y,
                c ? new this.constructor(l,u) : this.set(l, u)
            },
            subtract: function(l, u, c) {
                return typeof l != "number" && (c = u,
                r(l) ? (u = l[1],
                l = l[0]) : (u = l.y,
                l = l.x)),
                l = this.x - l,
                u = this.y - u,
                c ? new this.constructor(l,u) : this.set(l, u)
            },
            multiply: function(l, u, c) {
                return typeof l != "number" ? (c = u,
                r(l) ? (u = l[1],
                l = l[0]) : (u = l.y,
                l = l.x)) : typeof u != "number" && (c = u,
                u = l),
                l *= this.x,
                u *= this.y,
                c ? new this.constructor(l,u) : this.set(l, u)
            },
            rotate: function(l, u, c) {
                var h = this.x, f = this.y, m = Math.cos(l), _ = Math.sin(l), d, p;
                return u = u ? -1 : 1,
                d = m * h - u * _ * f,
                p = u * _ * h + m * f,
                c ? new this.constructor(d,p) : this.set(d, p)
            },
            length: function() {
                var l = this.x
                  , u = this.y;
                return Math.sqrt(l * l + u * u)
            },
            lengthSquared: function() {
                var l = this.x
                  , u = this.y;
                return l * l + u * u
            },
            distance: function(l) {
                var u = this.x - l.x
                  , c = this.y - l.y;
                return Math.sqrt(u * u + c * c)
            },
            nearest: function(l) {
                for (var u = Number.MAX_VALUE, c = null, h, f = l.length - 1; f >= 0; f--)
                    h = this.distance(l[f]),
                    h <= u && (u = h,
                    c = l[f]);
                return c
            },
            normalize: function(l) {
                var u = this.length()
                  , c = u < Number.MIN_VALUE ? 0 : 1 / u;
                return l ? new this.constructor(this.x * c,this.y * c) : this.set(this.x * c, this.y * c)
            },
            equal: function(l, u) {
                return typeof l != "number" && (r(l) ? (u = l[1],
                l = l[0]) : (u = l.y,
                l = l.x)),
                s.clean(l) === this.x && s.clean(u) === this.y
            },
            abs: function(l) {
                var u = Math.abs(this.x)
                  , c = Math.abs(this.y);
                return l ? new this.constructor(u,c) : this.set(u, c)
            },
            min: function(l, u) {
                var c = this.x
                  , h = this.y
                  , f = l.x
                  , m = l.y
                  , _ = c < f ? c : f
                  , d = h < m ? h : m;
                return u ? new this.constructor(_,d) : this.set(_, d)
            },
            max: function(l, u) {
                var c = this.x
                  , h = this.y
                  , f = l.x
                  , m = l.y
                  , _ = c > f ? c : f
                  , d = h > m ? h : m;
                return u ? new this.constructor(_,d) : this.set(_, d)
            },
            clamp: function(l, u, c) {
                var h = this.min(u, !0).max(l);
                return c ? h : this.set(h.x, h.y)
            },
            lerp: function(l, u, c) {
                return this.add(l.subtract(this, !0).multiply(u), c)
            },
            skew: function(l) {
                return l ? new this.constructor(-this.y,this.x) : this.set(-this.y, this.x)
            },
            dot: function(l) {
                return s.clean(this.x * l.x + l.y * this.y)
            },
            perpDot: function(l) {
                return s.clean(this.x * l.y - this.y * l.x)
            },
            angleTo: function(l) {
                return Math.atan2(this.perpDot(l), this.dot(l))
            },
            divide: function(l, u, c) {
                if (typeof l != "number" ? (c = u,
                r(l) ? (u = l[1],
                l = l[0]) : (u = l.y,
                l = l.x)) : typeof u != "number" && (c = u,
                u = l),
                l === 0 || u === 0)
                    throw new Error("division by zero");
                if (isNaN(l) || isNaN(u))
                    throw new Error("NaN detected");
                return c ? new this.constructor(this.x / l,this.y / u) : this.set(this.x / l, this.y / u)
            },
            isPointOnLine: function(l, u) {
                return (l.y - this.y) * (l.x - u.x) === (l.y - u.y) * (l.x - this.x)
            },
            toArray: function() {
                return [this.x, this.y]
            },
            fromArray: function(l) {
                return this.set(l[0], l[1])
            },
            toJSON: function() {
                return {
                    x: this.x,
                    y: this.y
                }
            },
            toString: function() {
                return "(" + this.x + ", " + this.y + ")"
            },
            constructor: s
        },
        s.fromArray = function(l, u) {
            return new (u || s)(l[0],l[1])
        }
        ,
        s.precision = n || 8;
        var a = Math.pow(10, s.precision);
        return s.clean = t || function(l) {
            if (isNaN(l))
                throw new Error("NaN detected");
            if (!isFinite(l))
                throw new Error("Infinity detected");
            return Math.round(l) === l ? l : Math.round(l * a) / a
        }
        ,
        s.inject = e,
        t || (s.fast = e(function(l) {
            return l
        }),
        o.exports = s),
        s
    }
    )()
}
)($v);
class Zv {
    constructor() {
        typeof window < "u" && (this.ua = navigator.userAgent.toLowerCase(),
        this.html = document.querySelector("html"),
        this.checkNavigator(),
        this.checkPlatform(),
        this.checkDevice(),
        this.checkVersion(),
        this.checkEvents(),
        this.checkCss(),
        this.addConsole())
    }
    checkDevice() {
        this.device = {},
        this.device.iphone = this.ua.match(/iPhone/i) != null || this.ua.match(/iPod/i) != null,
        this.device.mobile = this.ua.match(/mobile/i) != null,
        this.device.ipad = this.platform.ios && !this.device.iphone,
        this.device.tablet = this.device.ipad && !this.device.iphone || this.ua.match(/android/i) != null && !this.device.mobile,
        this.device.tablet && (this.device.mobile = !1),
        this.device.desktop = !this.device.tablet && !this.device.mobile,
        this.device.touch = !!(typeof window.ontouchstart == "function" || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 || this.device.mobile || this.device.ipad || this.device.iphone || this.device.tablet || this.platform.android || this.platform.windowsphone),
        this.device.retina = window.devicePixelRatio > 1
    }
    checkNavigator() {
        this.browser = {},
        this.browser.ioswebview = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(this.ua),
        this.browser.firefox = this.ua.indexOf("firefox") > -1,
        this.browser.samsung = this.ua.indexOf("samsungbrowser") > -1,
        this.browser.ie = (this.ua.indexOf("msie") > -1 || window.ActiveXObject || "ActiveXObject"in window) && !this.browser.firefox,
        this.browser.edge = /Edge./i.test(this.ua),
        this.browser.chrome = this.ua.indexOf("chrome") > -1 && !this.browser.samsung,
        this.browser.safari = !!(this.ua.indexOf("safari") > -1 && !this.browser.chrome && !this.browser.samsung || this.ua.match(/fbios/i) || this.ua.match(/micromessenger/i)),
        this.browser.opera = this.ua.indexOf("presto") > -1,
        this.browser.facebook = this.ua.indexOf("fban") > -1 || this.ua.indexOf("fbav") > -1
    }
    checkPlatform() {
        this.platform = {},
        this.platform.ios = /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1,
        this.platform.win = /win/i.test(navigator.platform.toLowerCase()),
        this.platform.mac = navigator.platform.toLowerCase().indexOf("mac") >= 0,
        this.platform.android = this.ua.indexOf("android") > -1,
        this.platform.linux = this.ua.indexOf("linux") > -1,
        this.platform.windowsphone = this.ua.indexOf("windows phone") > -1 || this.ua.match(/mobile/i) != null && this.browser.ie
    }
    checkVersion() {
        this.version = {},
        this.version.full = this.getBrowserVersion(),
        this.version.main = parseInt(this.version.full),
        this.version.ie6 = this.html.classList.contains("ie6"),
        this.version.ie7 = this.html.classList.contains("ie7"),
        this.version.ie8 = this.html.classList.contains("ie8"),
        this.version.ie9 = this.html.classList.contains("ie9"),
        this.version.ie10 = navigator.appVersion.indexOf("MSIE 10") !== -1,
        this.version.ie11 = this.ua.match(/Trident\/7\./i) != null,
        this.version.edge = /Edge./i.test(this.ua),
        this.version.ios7 = this.ua.match(/Version\/7/i) != null,
        this.version.ios9 = this.ua.match(/Version\/9/i) != null
    }
    checkEvents() {
        this.event = {},
        this.device.touch ? (this.event.click = "touchstart",
        this.event.down = "touchstart",
        this.event.up = "touchend",
        this.event.move = "touchmove",
        window.navigator.msPointerEnabled && (this.event.click = "MSPointerDown",
        this.event.down = "MSPointerDown",
        this.event.up = "MSPointerUp",
        this.event.move = "MSPointerMove")) : (this.event.click = "click",
        this.event.down = "mousedown",
        this.event.up = "mouseup",
        this.event.move = "mousemove")
    }
    checkCss() {
        this.css = {},
        this.css.transform3d = this.checkCssProperty("transform", "translate3d(1px,1px,1px)", !0)
    }
    checkCssProperty(e, t, n) {
        var i = document.createElement("div");
        this.html.appendChild(i);
        var r = (n ? this.browser.cssVendorPrefix : "") + e
          , s = (n ? this.browser.jsVendorPrefix : "") + this.uppercaseFirstLetter(e)
          , a = void 0;
        return i.style[s] !== void 0 && (i.style[s] = t,
        a = window.getComputedStyle(i).getPropertyValue(r)),
        this.html.removeChild(i),
        a !== void 0 && a.length > 0 && a !== "none"
    }
    getBrowserVersion() {
        var e = navigator.appName, t = this.ua, n, i = t.match(/(opera|chrome|safari|firefox|msie)\/?\s*(\.?\d+(\.\d+)*)/i);
        return i && (n = t.match(/version\/([\.\d]+)/i)) != null && (i[2] = n[1]),
        i = i ? [i[1], i[2]] : [e, navigator.appVersion, "-?"],
        i[1]
    }
    checkVendorPrefix() {
        var e = {
            ioswebview: ["-webkit-", "webkit"],
            facebook: ["-webkit-", "webkit"],
            samsung: ["-webkit-", "webkit"],
            chrome: ["-webkit-", "webkit"],
            safari: ["-webkit-", "webkit"],
            firefox: ["-moz-", "Moz"],
            opera: ["-o-", "O"],
            ie: ["-ms-", "ms"]
        };
        for (var t in this.browser)
            if (this.browser[t]) {
                this.browser.cssVendorPrefix = e[t][0],
                this.browser.jsVendorPrefix = e[t][1];
                return
            }
        this.browser.cssVendorPrefix = "",
        this.browser.jsVendorPrefix = ""
    }
    checkVideoSupport() {
        var e = {
            ioswebview: ["mp4", "video/mp4"],
            facebook: ["mp4", "video/mp4"],
            samsung: ["mp4", "video/mp4"],
            chrome: ["mp4", "video/mp4"],
            safari: ["mp4", "video/mp4"],
            firefox: ["mp4", "video/mp4"],
            opera: ["webm", "video/webm"],
            ie: ["mp4", "video/mp4"]
        };
        for (var t in this.browser)
            if (this.browser[t]) {
                this.browser.videoExtension = e[t][0],
                this.browser.videoType = e[t][1];
                return
            }
        this.browser.videoExtension = "mp4",
        this.browser.videoType = "video/mp4"
    }
    checkWebGL() {
        var e, t, n;
        try {
            e = document.createElement("canvas"),
            t = e.getContext("webgl") || e.getContext("experimental-webgl"),
            n = t.getSupportedExtensions()
        } catch {}
        if (t !== void 0 && (self.webgl = new Boolean(!0)),
        t)
            for (var i = -1, r = n.length; ++i < r; )
                self.webgl[n[i]] = !0;
        e = void 0
    }
    uppercaseFirstLetter(e) {
        return e.charAt(0).toUpperCase() + e.slice(1)
    }
    addConsole() {}
}
const jT = new Zv;
var Tg = {
    exports: {}
};
Tg.exports = function(o) {
    return Eg(Qv(o), o)
}
;
Tg.exports.array = Eg;
function Eg(o, e) {
    var t = o.length
      , n = new Array(t)
      , i = {}
      , r = t
      , s = Jv(e)
      , a = ex(o);
    for (e.forEach(function(u) {
        if (!a.has(u[0]) || !a.has(u[1]))
            throw new Error("Unknown node. There is an unknown node in the supplied edges.")
    }); r--; )
        i[r] || l(o[r], r, new Set);
    return n;
    function l(u, c, h) {
        if (h.has(u)) {
            var f;
            try {
                f = ", node was:" + JSON.stringify(u)
            } catch {
                f = ""
            }
            throw new Error("Cyclic dependency" + f)
        }
        if (!a.has(u))
            throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(u));
        if (!i[c]) {
            i[c] = !0;
            var m = s.get(u) || new Set;
            if (m = Array.from(m),
            c = m.length) {
                h.add(u);
                do {
                    var _ = m[--c];
                    l(_, a.get(_), h)
                } while (c);
                h.delete(u)
            }
            n[--t] = u
        }
    }
}
function Qv(o) {
    for (var e = new Set, t = 0, n = o.length; t < n; t++) {
        var i = o[t];
        e.add(i[0]),
        e.add(i[1])
    }
    return Array.from(e)
}
function Jv(o) {
    for (var e = new Map, t = 0, n = o.length; t < n; t++) {
        var i = o[t];
        e.has(i[0]) || e.set(i[0], new Set),
        e.has(i[1]) || e.set(i[1], new Set),
        e.get(i[0]).add(i[1])
    }
    return e
}
function ex(o) {
    for (var e = new Map, t = 0, n = o.length; t < n; t++)
        e.set(o[t], t);
    return e
}
_r.defaultMaxListeners = 100;
class qT extends _r {
    constructor(...e) {
        super(),
        this.modules = new Map,
        this.run = this.run.bind(this),
        this._running = !1,
        this._ready = !1,
        document.body ? this._ready = !0 : document.addEventListener("DOMContentLoaded", () => {
            this._ready = !0,
            this._runRequested && this.run()
        }
        ),
        this.add(...e)
    }
    sort() {
        this.modules.forEach(e => {
            e.dependencies.forEach(t => {
                this.modules.has(t) || this.modules.set(t, new t(this))
            }
            )
        }
        ),
        this.modules = new Map(this.toposort(Array.from(this.modules.values())).map(e => [e.constructor, e])),
        this.modules.forEach(e => e.enabled = !0)
    }
    toposort(e) {
        let t = new Map;
        e.forEach(a => t.set(a, Array.from(a.dependencies.keys()).map(l => this.modules.get(l))));
        const n = Array.from(t.keys()).reduce( (a, l) => a.set(l, Array.from(t.keys()).filter(u => t.get(u).includes(l))), new Map)
          , i = Array.from(t.keys()).filter(a => t.get(a).length == 0).sort( (a, l) => a.priority - l.priority)
          , r = [];
        for (; i.length; ) {
            const a = i.pop();
            r.push(a);
            var s = [];
            n.get(a).forEach(l => {
                t.set(l, t.get(l).filter(u => u !== a)),
                t.get(l).length == 0 && s.push(l)
            }
            ),
            s.sort( (l, u) => l.priority - u.priority).forEach(l => i.push(l))
        }
        return r
    }
    add(...e) {
        e = wc(e),
        e.forEach(t => this.modules.set(t, new t(this))),
        this.sort()
    }
    override(e, t) {
        if (this.modules.has(overridenModule)) {
            this.modules.delete(overridenModule);
            let n = new t(this);
            this.modules.set(overridenModule, n),
            this.modules.set(t, n),
            this.sort()
        }
    }
    get(e) {
        return this.modules.get(e)
    }
    async run() {
        if (!this._running) {
            if (!this._ready) {
                this._runRequested = !0;
                return
            }
            Wi.exports.debug("Bootstrap", "run"),
            this._running = !0;
            for (let e of ["init", "before", "run", "after"])
                for (let[t,n] of Array.from(this.modules))
                    Wi.exports.debug("Bootstrap", "module", n.constructor.name, e),
                    n.runnable && await n[e]();
            this._running = !1
        }
    }
}
class XT extends mg {
    get components() {
        return this.bootstrap.components
    }
    get viewport() {
        return this.bootstrap.viewport
    }
    get animator() {
        return this.bootstrap.animator
    }
}
var uh = {
    exports: {}
};
uh.exports = Ag;
uh.exports.addWheelListener = Ag;
uh.exports.removeWheelListener = tx;
function Ag(o, e, t) {
    o.addEventListener("wheel", e, t)
}
function tx(o, e, t) {
    o.removeEventListener("wheel", e, t)
}
var nx = {};
(function(o) {
    Object.defineProperty(o, "__esModule", {
        value: !0
    }),
    o.findClosestIndex = function(e, t, n) {
        for (var i = {
            index: -1,
            distance: Number.POSITIVE_INFINITY,
            value: 0
        }, r = 0; r < e.length; r++) {
            var s = e[r]
              , a = s;
            if (n) {
                var l = n(s, r, e);
                switch (l) {
                case !1:
                    continue;
                case !0:
                    break;
                default:
                    a = l
                }
            }
            if (typeof a != "number")
                throw new TypeError("Expected a number value. Received " + a + ".");
            var u = Math.abs(a - t);
            if (u === 0)
                return r;
            u < i.distance && (i = {
                index: r,
                distance: u,
                value: a
            })
        }
        return i.index
    }
    ,
    o.findClosest = function(e, t, n) {
        return e[o.findClosestIndex(e, t, n)]
    }
    ,
    o.default = o.findClosest
}
)(nx);
function ix(o, e, t) {
    return Math.max(e, Math.min(o, t))
}
const ft = {
    toVector(o, e) {
        return o === void 0 && (o = e),
        Array.isArray(o) ? o : [o, o]
    },
    add(o, e) {
        return [o[0] + e[0], o[1] + e[1]]
    },
    sub(o, e) {
        return [o[0] - e[0], o[1] - e[1]]
    },
    addTo(o, e) {
        o[0] += e[0],
        o[1] += e[1]
    },
    subTo(o, e) {
        o[0] -= e[0],
        o[1] -= e[1]
    }
};
function Ef(o, e, t) {
    return e === 0 || Math.abs(e) === 1 / 0 ? Math.pow(o, t * 5) : o * e * t / (e + t * o)
}
function Af(o, e, t, n=.15) {
    return n === 0 ? ix(o, e, t) : o < e ? -Ef(e - o, t - e, n) + e : o > t ? +Ef(o - t, t - e, n) + t : o
}
function rx(o, [e,t], [n,i]) {
    const [[r,s],[a,l]] = o;
    return [Af(e, r, s, n), Af(t, a, l, i)]
}
function Tt(o, e, t) {
    return e in o ? Object.defineProperty(o, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : o[e] = t,
    o
}
function Cf(o, e) {
    var t = Object.keys(o);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(o);
        e && (n = n.filter(function(i) {
            return Object.getOwnPropertyDescriptor(o, i).enumerable
        })),
        t.push.apply(t, n)
    }
    return t
}
function pt(o) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? Cf(Object(t), !0).forEach(function(n) {
            Tt(o, n, t[n])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(t)) : Cf(Object(t)).forEach(function(n) {
            Object.defineProperty(o, n, Object.getOwnPropertyDescriptor(t, n))
        })
    }
    return o
}
const Cg = {
    pointer: {
        start: "down",
        change: "move",
        end: "up"
    },
    mouse: {
        start: "down",
        change: "move",
        end: "up"
    },
    touch: {
        start: "start",
        change: "move",
        end: "end"
    },
    gesture: {
        start: "start",
        change: "change",
        end: "end"
    }
};
function Lf(o) {
    return o ? o[0].toUpperCase() + o.slice(1) : ""
}
const sx = ["enter", "leave"];
function ox(o=!1, e) {
    return o && !sx.includes(e)
}
function ax(o, e="", t=!1) {
    const n = Cg[o]
      , i = n && n[e] || e;
    return "on" + Lf(o) + Lf(i) + (ox(t, i) ? "Capture" : "")
}
const lx = ["gotpointercapture", "lostpointercapture"];
function ux(o) {
    let e = o.substring(2).toLowerCase();
    const t = !!~e.indexOf("passive");
    t && (e = e.replace("passive", ""));
    const n = lx.includes(e) ? "capturecapture" : "capture"
      , i = !!~e.indexOf(n);
    return i && (e = e.replace("capture", "")),
    {
        device: e,
        capture: i,
        passive: t
    }
}
function cx(o, e="") {
    const t = Cg[o]
      , n = t && t[e] || e;
    return o + n
}
function Wl(o) {
    return "touches"in o
}
function Lg(o) {
    return Wl(o) ? "touch" : "pointerType"in o ? o.pointerType : "mouse"
}
function hx(o) {
    return Array.from(o.touches).filter(e => {
        var t, n;
        return e.target === o.currentTarget || ((t = o.currentTarget) === null || t === void 0 || (n = t.contains) === null || n === void 0 ? void 0 : n.call(t, e.target))
    }
    )
}
function fx(o) {
    return o.type === "touchend" || o.type === "touchcancel" ? o.changedTouches : o.targetTouches
}
function Rg(o) {
    return Wl(o) ? fx(o)[0] : o
}
function Mc(o, e) {
    const t = e.clientX - o.clientX
      , n = e.clientY - o.clientY
      , i = (e.clientX + o.clientX) / 2
      , r = (e.clientY + o.clientY) / 2
      , s = Math.hypot(t, n);
    return {
        angle: -(Math.atan2(t, n) * 180) / Math.PI,
        distance: s,
        origin: [i, r]
    }
}
function dx(o) {
    return hx(o).map(e => e.identifier)
}
function Rf(o, e) {
    const [t,n] = Array.from(o.touches).filter(i => e.includes(i.identifier));
    return Mc(t, n)
}
function _u(o) {
    const e = Rg(o);
    return Wl(o) ? e.identifier : e.pointerId
}
function Qs(o) {
    const e = Rg(o);
    return [e.clientX, e.clientY]
}
const Pf = 40
  , If = 800;
function Pg(o) {
    let {deltaX: e, deltaY: t, deltaMode: n} = o;
    return n === 1 ? (e *= Pf,
    t *= Pf) : n === 2 && (e *= If,
    t *= If),
    [e, t]
}
function px(o) {
    var e, t;
    const {scrollX: n, scrollY: i, scrollLeft: r, scrollTop: s} = o.currentTarget;
    return [(e = n != null ? n : r) !== null && e !== void 0 ? e : 0, (t = i != null ? i : s) !== null && t !== void 0 ? t : 0]
}
function mx(o) {
    const e = {};
    if ("buttons"in o && (e.buttons = o.buttons),
    "shiftKey"in o) {
        const {shiftKey: t, altKey: n, metaKey: i, ctrlKey: r} = o;
        Object.assign(e, {
            shiftKey: t,
            altKey: n,
            metaKey: i,
            ctrlKey: r
        })
    }
    return e
}
function Ol(o, ...e) {
    return typeof o == "function" ? o(...e) : o
}
function gx() {}
function _x(...o) {
    return o.length === 0 ? gx : o.length === 1 ? o[0] : function() {
        let e;
        for (const t of o)
            e = t.apply(this, arguments) || e;
        return e
    }
}
function Ff(o, e) {
    return Object.assign({}, e, o || {})
}
const vx = 32;
class Ig {
    constructor(e, t, n) {
        this.ctrl = e,
        this.args = t,
        this.key = n,
        this.state || (this.state = {},
        this.computePhilosophy([0, 0]),
        this.computeInitial(),
        this.init && this.init(),
        this.reset())
    }
    get state() {
        return this.ctrl.state[this.key]
    }
    set state(e) {
        this.ctrl.state[this.key] = e
    }
    get shared() {
        return this.ctrl.state.shared
    }
    get eventStore() {
        return this.ctrl.gestureEventStores[this.key]
    }
    get timeoutStore() {
        return this.ctrl.gestureTimeoutStores[this.key]
    }
    get config() {
        return this.ctrl.config[this.key]
    }
    get sharedConfig() {
        return this.ctrl.config.shared
    }
    get handler() {
        return this.ctrl.handlers[this.key]
    }
    reset() {
        const {state: e, shared: t, ingKey: n, args: i} = this;
        t[n] = e._active = e.active = e._blocked = e._force = !1,
        e._step = [!1, !1],
        e.intentional = !1,
        e._movement = [0, 0],
        e._distance = [0, 0],
        e._direction = [0, 0],
        e._delta = [0, 0],
        e._bounds = [[-1 / 0, 1 / 0], [-1 / 0, 1 / 0]],
        e.args = i,
        e.axis = void 0,
        e.memo = void 0,
        e.elapsedTime = 0,
        e.direction = [0, 0],
        e.distance = [0, 0],
        e.overflow = [0, 0],
        e._movementBound = [!1, !1],
        e.velocity = [0, 0],
        e.movement = [0, 0],
        e.delta = [0, 0],
        e.timeStamp = 0
    }
    start(e) {
        const t = this.state
          , n = this.config;
        t._active || (this.reset(),
        this.computeInitial(),
        t._active = !0,
        t.target = e.target,
        t.currentTarget = e.currentTarget,
        t.lastOffset = n.from ? Ol(n.from, t) : t.offset,
        t.offset = t.lastOffset),
        t.startTime = t.timeStamp = e.timeStamp
    }
    computePhilosophy(e) {
        const t = this.state;
        t._values = e,
        t.values = this.config.transform(e)
    }
    computeInitial() {
        const e = this.state;
        e._initial = e._values,
        e.initial = e.values
    }
    compute(e) {
        const {state: t, config: n, shared: i} = this;
        t.args = this.args;
        let r = 0;
        if (e && (t.event = e,
        n.preventDefault && e.cancelable && t.event.preventDefault(),
        t.type = e.type,
        i.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size,
        i.locked = !!document.pointerLockElement,
        Object.assign(i, mx(e)),
        i.down = i.pressed = i.buttons % 2 === 1 || i.touches > 0,
        r = e.timeStamp - t.timeStamp,
        t.timeStamp = e.timeStamp,
        t.elapsedTime = t.timeStamp - t.startTime),
        t._active) {
            const L = t._delta.map(Math.abs);
            ft.addTo(t._distance, L)
        }
        this.axisIntent && this.axisIntent(e);
        const [s,a] = t._movement
          , [l,u] = n.threshold
          , {_step: c, values: h} = t;
        if (n.hasCustomTransform ? (c[0] === !1 && (c[0] = Math.abs(s) >= l && h[0]),
        c[1] === !1 && (c[1] = Math.abs(a) >= u && h[1])) : (c[0] === !1 && (c[0] = Math.abs(s) >= l && Math.sign(s) * l),
        c[1] === !1 && (c[1] = Math.abs(a) >= u && Math.sign(a) * u)),
        t.intentional = c[0] !== !1 || c[1] !== !1,
        !t.intentional)
            return;
        const f = [0, 0];
        if (n.hasCustomTransform) {
            const [L,P] = h;
            f[0] = c[0] !== !1 ? L - c[0] : 0,
            f[1] = c[1] !== !1 ? P - c[1] : 0
        } else
            f[0] = c[0] !== !1 ? s - c[0] : 0,
            f[1] = c[1] !== !1 ? a - c[1] : 0;
        this.restrictToAxis && !t._blocked && this.restrictToAxis(f);
        const m = t.offset
          , _ = t._active && !t._blocked || t.active;
        _ && (t.first = t._active && !t.active,
        t.last = !t._active && t.active,
        t.active = i[this.ingKey] = t._active,
        e && (t.first && ("bounds"in n && (t._bounds = Ol(n.bounds, t)),
        this.setup && this.setup()),
        t.movement = f,
        this.computeOffset()));
        const [d,p] = t.offset
          , [[v,x],[S,M]] = t._bounds;
        t.overflow = [d < v ? -1 : d > x ? 1 : 0, p < S ? -1 : p > M ? 1 : 0],
        t._movementBound[0] = t.overflow[0] ? t._movementBound[0] === !1 ? t._movement[0] : t._movementBound[0] : !1,
        t._movementBound[1] = t.overflow[1] ? t._movementBound[1] === !1 ? t._movement[1] : t._movementBound[1] : !1;
        const T = t._active ? n.rubberband || [0, 0] : [0, 0];
        if (t.offset = rx(t._bounds, t.offset, T),
        t.delta = ft.sub(t.offset, m),
        this.computeMovement(),
        _ && (!t.last || r > vx)) {
            t.delta = ft.sub(t.offset, m);
            const L = t.delta.map(Math.abs);
            ft.addTo(t.distance, L),
            t.direction = t.delta.map(Math.sign),
            t._direction = t._delta.map(Math.sign),
            !t.first && r > 0 && (t.velocity = [L[0] / r, L[1] / r])
        }
    }
    emit() {
        const e = this.state
          , t = this.shared
          , n = this.config;
        if (e._active || this.clean(),
        (e._blocked || !e.intentional) && !e._force && !n.triggerAllEvents)
            return;
        const i = this.handler(pt(pt(pt({}, t), e), {}, {
            [this.aliasKey]: e.values
        }));
        i !== void 0 && (e.memo = i)
    }
    clean() {
        this.eventStore.clean(),
        this.timeoutStore.clean()
    }
}
function xx([o,e], t) {
    const n = Math.abs(o)
      , i = Math.abs(e);
    if (n > i && n > t)
        return "x";
    if (i > n && i > t)
        return "y"
}
class da extends Ig {
    constructor(...e) {
        super(...e),
        Tt(this, "aliasKey", "xy")
    }
    reset() {
        super.reset(),
        this.state.axis = void 0
    }
    init() {
        this.state.offset = [0, 0],
        this.state.lastOffset = [0, 0]
    }
    computeOffset() {
        this.state.offset = ft.add(this.state.lastOffset, this.state.movement)
    }
    computeMovement() {
        this.state.movement = ft.sub(this.state.offset, this.state.lastOffset)
    }
    axisIntent(e) {
        const t = this.state
          , n = this.config;
        if (!t.axis && e) {
            const i = typeof n.axisThreshold == "object" ? n.axisThreshold[Lg(e)] : n.axisThreshold;
            t.axis = xx(t._movement, i)
        }
        t._blocked = (n.lockDirection || !!n.axis) && !t.axis || !!n.axis && n.axis !== t.axis
    }
    restrictToAxis(e) {
        if (this.config.axis || this.config.lockDirection)
            switch (this.state.axis) {
            case "x":
                e[1] = 0;
                break;
            case "y":
                e[0] = 0;
                break
            }
    }
}
const yx = o => o
  , Of = .15
  , Fg = {
    enabled(o=!0) {
        return o
    },
    eventOptions(o, e, t) {
        return pt(pt({}, t.shared.eventOptions), o)
    },
    preventDefault(o=!1) {
        return o
    },
    triggerAllEvents(o=!1) {
        return o
    },
    rubberband(o=0) {
        switch (o) {
        case !0:
            return [Of, Of];
        case !1:
            return [0, 0];
        default:
            return ft.toVector(o)
        }
    },
    from(o) {
        if (typeof o == "function")
            return o;
        if (o != null)
            return ft.toVector(o)
    },
    transform(o, e, t) {
        const n = o || t.shared.transform;
        return this.hasCustomTransform = !!n,
        n || yx
    },
    threshold(o) {
        return ft.toVector(o, 0)
    }
}
  , bx = 0
  , rs = pt(pt({}, Fg), {}, {
    axis(o, e, {axis: t}) {
        if (this.lockDirection = t === "lock",
        !this.lockDirection)
            return t
    },
    axisThreshold(o=bx) {
        return o
    },
    bounds(o={}) {
        if (typeof o == "function")
            return r => rs.bounds(o(r));
        if ("current"in o)
            return () => o.current;
        if (typeof HTMLElement == "function" && o instanceof HTMLElement)
            return o;
        const {left: e=-1 / 0, right: t=1 / 0, top: n=-1 / 0, bottom: i=1 / 0} = o;
        return [[e, t], [n, i]]
    }
})
  , Fa = 10
  , Nf = {
    ArrowRight: (o=1) => [Fa * o, 0],
    ArrowLeft: (o=1) => [-Fa * o, 0],
    ArrowUp: (o=1) => [0, -Fa * o],
    ArrowDown: (o=1) => [0, Fa * o]
};
class wx extends da {
    constructor(...e) {
        super(...e),
        Tt(this, "ingKey", "dragging")
    }
    reset() {
        super.reset();
        const e = this.state;
        e._pointerId = void 0,
        e._pointerActive = !1,
        e._keyboardActive = !1,
        e._preventScroll = !1,
        e._delayed = !1,
        e.swipe = [0, 0],
        e.tap = !1,
        e.canceled = !1,
        e.cancel = this.cancel.bind(this)
    }
    setup() {
        const e = this.state;
        if (e._bounds instanceof HTMLElement) {
            const t = e._bounds.getBoundingClientRect()
              , n = e.currentTarget.getBoundingClientRect()
              , i = {
                left: t.left - n.left + e.offset[0],
                right: t.right - n.right + e.offset[0],
                top: t.top - n.top + e.offset[1],
                bottom: t.bottom - n.bottom + e.offset[1]
            };
            e._bounds = rs.bounds(i)
        }
    }
    cancel() {
        const e = this.state;
        e.canceled || (e.canceled = !0,
        e._active = !1,
        setTimeout( () => {
            this.compute(),
            this.emit()
        }
        , 0))
    }
    setActive() {
        this.state._active = this.state._pointerActive || this.state._keyboardActive
    }
    clean() {
        this.pointerClean(),
        this.state._pointerActive = !1,
        this.state._keyboardActive = !1,
        super.clean()
    }
    pointerDown(e) {
        const t = this.config
          , n = this.state;
        if (e.buttons != null && (Array.isArray(t.pointerButtons) ? !t.pointerButtons.includes(e.buttons) : t.pointerButtons !== -1 && t.pointerButtons !== e.buttons))
            return;
        const i = this.ctrl.setEventIds(e);
        t.pointerCapture && e.target.setPointerCapture(e.pointerId),
        !(i && i.size > 1 && n._pointerActive) && (this.start(e),
        this.setupPointer(e),
        n._pointerId = _u(e),
        n._pointerActive = !0,
        this.computePhilosophy(Qs(e)),
        this.computeInitial(),
        t.preventScrollAxis && Lg(e) !== "mouse" ? (n._active = !1,
        this.setupScrollPrevention(e)) : t.delay > 0 ? (this.setupDelayTrigger(e),
        t.triggerAllEvents && (this.compute(e),
        this.emit())) : this.startPointerDrag(e))
    }
    startPointerDrag(e) {
        const t = this.state;
        t._active = !0,
        t._preventScroll = !0,
        t._delayed = !1,
        this.compute(e),
        this.emit()
    }
    pointerMove(e) {
        const t = this.state
          , n = this.config;
        if (!t._pointerActive || t.type === e.type && e.timeStamp === t.timeStamp)
            return;
        const i = _u(e);
        if (t._pointerId !== void 0 && i !== t._pointerId)
            return;
        const r = Qs(e);
        if (document.pointerLockElement === e.target ? t._delta = [e.movementX, e.movementY] : (t._delta = ft.sub(r, t._values),
        this.computePhilosophy(r)),
        ft.addTo(t._movement, t._delta),
        this.compute(e),
        t._delayed && t.intentional) {
            this.timeoutStore.remove("dragDelay"),
            t.active = !1,
            this.startPointerDrag(e);
            return
        }
        if (n.preventScrollAxis && !t._preventScroll)
            if (t.axis)
                if (t.axis === n.preventScrollAxis || n.preventScrollAxis === "xy") {
                    t._active = !1,
                    this.clean();
                    return
                } else {
                    this.timeoutStore.remove("startPointerDrag"),
                    this.startPointerDrag(e);
                    return
                }
            else
                return;
        this.emit()
    }
    pointerUp(e) {
        this.ctrl.setEventIds(e);
        try {
            this.config.pointerCapture && e.target.hasPointerCapture(e.pointerId) && e.target.releasePointerCapture(e.pointerId)
        } catch {}
        const t = this.state
          , n = this.config;
        if (!t._active || !t._pointerActive)
            return;
        const i = _u(e);
        if (t._pointerId !== void 0 && i !== t._pointerId)
            return;
        this.state._pointerActive = !1,
        this.setActive(),
        this.compute(e);
        const [r,s] = t._distance;
        if (t.tap = r <= n.tapsThreshold && s <= n.tapsThreshold,
        t.tap && n.filterTaps)
            t._force = !0;
        else {
            const [a,l] = t.direction
              , [u,c] = t.velocity
              , [h,f] = t.movement
              , [m,_] = n.swipe.velocity
              , [d,p] = n.swipe.distance
              , v = n.swipe.duration;
            t.elapsedTime < v && (Math.abs(u) > m && Math.abs(h) > d && (t.swipe[0] = a),
            Math.abs(c) > _ && Math.abs(f) > p && (t.swipe[1] = l))
        }
        this.emit()
    }
    pointerClick(e) {
        !this.state.tap && e.detail > 0 && (e.preventDefault(),
        e.stopPropagation())
    }
    setupPointer(e) {
        const t = this.config
          , n = t.device;
        t.pointerLock && e.currentTarget.requestPointerLock(),
        t.pointerCapture || (this.eventStore.add(this.sharedConfig.window, n, "change", this.pointerMove.bind(this)),
        this.eventStore.add(this.sharedConfig.window, n, "end", this.pointerUp.bind(this)),
        this.eventStore.add(this.sharedConfig.window, n, "cancel", this.pointerUp.bind(this)))
    }
    pointerClean() {
        this.config.pointerLock && document.pointerLockElement === this.state.currentTarget && document.exitPointerLock()
    }
    preventScroll(e) {
        this.state._preventScroll && e.cancelable && e.preventDefault()
    }
    setupScrollPrevention(e) {
        this.state._preventScroll = !1,
        Mx(e);
        const t = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
            passive: !1
        });
        this.eventStore.add(this.sharedConfig.window, "touch", "end", t),
        this.eventStore.add(this.sharedConfig.window, "touch", "cancel", t),
        this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, e)
    }
    setupDelayTrigger(e) {
        this.state._delayed = !0,
        this.timeoutStore.add("dragDelay", () => {
            this.state._step = [0, 0],
            this.startPointerDrag(e)
        }
        , this.config.delay)
    }
    keyDown(e) {
        const t = Nf[e.key];
        if (t) {
            const n = this.state
              , i = e.shiftKey ? 10 : e.altKey ? .1 : 1;
            this.start(e),
            n._delta = t(i),
            n._keyboardActive = !0,
            ft.addTo(n._movement, n._delta),
            this.compute(e),
            this.emit()
        }
    }
    keyUp(e) {
        e.key in Nf && (this.state._keyboardActive = !1,
        this.setActive(),
        this.compute(e),
        this.emit())
    }
    bind(e) {
        const t = this.config.device;
        e(t, "start", this.pointerDown.bind(this)),
        this.config.pointerCapture && (e(t, "change", this.pointerMove.bind(this)),
        e(t, "end", this.pointerUp.bind(this)),
        e(t, "cancel", this.pointerUp.bind(this)),
        e("lostPointerCapture", "", this.pointerUp.bind(this))),
        this.config.keys && (e("key", "down", this.keyDown.bind(this)),
        e("key", "up", this.keyUp.bind(this))),
        this.config.filterTaps && e("click", "", this.pointerClick.bind(this), {
            capture: !0,
            passive: !1
        })
    }
}
function Mx(o) {
    "persist"in o && typeof o.persist == "function" && o.persist()
}
const pa = typeof window < "u" && window.document && window.document.createElement;
function Sx() {
    return pa && "ontouchstart"in window
}
function kf() {
    return Sx() || pa && window.navigator.maxTouchPoints > 1
}
function Dx() {
    return pa && "onpointerdown"in window
}
function Tx() {
    return pa && "exitPointerLock"in window.document
}
function Ex() {
    try {
        return "constructor"in GestureEvent
    } catch {
        return !1
    }
}
const On = {
    isBrowser: pa,
    gesture: Ex(),
    touch: kf(),
    touchscreen: kf(),
    pointer: Dx(),
    pointerLock: Tx()
}
  , Ax = 250
  , Cx = 180
  , Lx = .5
  , Rx = 50
  , Px = 250
  , zf = {
    mouse: 0,
    touch: 0,
    pen: 8
}
  , Ix = pt(pt({}, rs), {}, {
    device(o, e, {pointer: {touch: t=!1, lock: n=!1, mouse: i=!1}={}}) {
        return this.pointerLock = n && On.pointerLock,
        On.touch && t ? "touch" : this.pointerLock ? "mouse" : On.pointer && !i ? "pointer" : On.touch ? "touch" : "mouse"
    },
    preventScrollAxis(o, e, {preventScroll: t}) {
        if (this.preventScrollDelay = typeof t == "number" ? t : t || t === void 0 && o ? Ax : void 0,
        !(!On.touchscreen || t === !1))
            return o || (t !== void 0 ? "y" : void 0)
    },
    pointerCapture(o, e, {pointer: {capture: t=!0, buttons: n=1}={}}) {
        return this.pointerButtons = n,
        !this.pointerLock && this.device === "pointer" && t
    },
    keys(o=!0) {
        return o
    },
    threshold(o, e, {filterTaps: t=!1, tapsThreshold: n=3, axis: i=void 0}) {
        const r = ft.toVector(o, t ? n : i ? 1 : 0);
        return this.filterTaps = t,
        this.tapsThreshold = n,
        r
    },
    swipe({velocity: o=Lx, distance: e=Rx, duration: t=Px}={}) {
        return {
            velocity: this.transform(ft.toVector(o)),
            distance: this.transform(ft.toVector(e)),
            duration: t
        }
    },
    delay(o=0) {
        switch (o) {
        case !0:
            return Cx;
        case !1:
            return 0;
        default:
            return o
        }
    },
    axisThreshold(o) {
        return o ? pt(pt({}, zf), o) : zf
    }
})
  , Fx = 30
  , Ox = 100;
class Nx extends Ig {
    constructor(...e) {
        super(...e),
        Tt(this, "ingKey", "pinching"),
        Tt(this, "aliasKey", "da")
    }
    init() {
        this.state.offset = [1, 0],
        this.state.lastOffset = [1, 0],
        this.state._pointerEvents = new Map
    }
    reset() {
        super.reset();
        const e = this.state;
        e._touchIds = [],
        e.canceled = !1,
        e.cancel = this.cancel.bind(this),
        e.turns = 0
    }
    computeOffset() {
        const {type: e, movement: t, lastOffset: n} = this.state;
        e === "wheel" ? this.state.offset = ft.add(t, n) : this.state.offset = [(1 + t[0]) * n[0], t[1] + n[1]]
    }
    computeMovement() {
        const {offset: e, lastOffset: t} = this.state;
        this.state.movement = [e[0] / t[0], e[1] - t[1]]
    }
    axisIntent() {
        const e = this.state
          , [t,n] = e._movement;
        if (!e.axis) {
            const i = Math.abs(t) * Fx - Math.abs(n);
            i < 0 ? e.axis = "angle" : i > 0 && (e.axis = "scale")
        }
    }
    restrictToAxis(e) {
        this.config.lockDirection && (this.state.axis === "scale" ? e[1] = 0 : this.state.axis === "angle" && (e[0] = 0))
    }
    cancel() {
        const e = this.state;
        e.canceled || setTimeout( () => {
            e.canceled = !0,
            e._active = !1,
            this.compute(),
            this.emit()
        }
        , 0)
    }
    touchStart(e) {
        this.ctrl.setEventIds(e);
        const t = this.state
          , n = this.ctrl.touchIds;
        if (t._active && t._touchIds.every(r => n.has(r)) || n.size < 2)
            return;
        this.start(e),
        t._touchIds = Array.from(n).slice(0, 2);
        const i = Rf(e, t._touchIds);
        this.pinchStart(e, i)
    }
    pointerStart(e) {
        if (e.buttons != null && e.buttons % 2 !== 1)
            return;
        this.ctrl.setEventIds(e),
        e.target.setPointerCapture(e.pointerId);
        const t = this.state
          , n = t._pointerEvents
          , i = this.ctrl.pointerIds;
        if (t._active && Array.from(n.keys()).every(s => i.has(s)) || (n.size < 2 && n.set(e.pointerId, e),
        t._pointerEvents.size < 2))
            return;
        this.start(e);
        const r = Mc(...Array.from(n.values()));
        this.pinchStart(e, r)
    }
    pinchStart(e, t) {
        const n = this.state;
        n.origin = t.origin,
        this.computePhilosophy([t.distance, t.angle]),
        this.computeInitial(),
        this.compute(e),
        this.emit()
    }
    touchMove(e) {
        if (!this.state._active)
            return;
        const t = Rf(e, this.state._touchIds);
        this.pinchMove(e, t)
    }
    pointerMove(e) {
        const t = this.state._pointerEvents;
        if (t.has(e.pointerId) && t.set(e.pointerId, e),
        !this.state._active)
            return;
        const n = Mc(...Array.from(t.values()));
        this.pinchMove(e, n)
    }
    pinchMove(e, t) {
        const n = this.state
          , i = n._values[1]
          , r = t.angle - i;
        let s = 0;
        Math.abs(r) > 270 && (s += Math.sign(r)),
        this.computePhilosophy([t.distance, t.angle - 360 * s]),
        n.origin = t.origin,
        n.turns = s,
        n._movement = [n._values[0] / n._initial[0] - 1, n._values[1] - n._initial[1]],
        this.compute(e),
        this.emit()
    }
    touchEnd(e) {
        this.ctrl.setEventIds(e),
        !!this.state._active && this.state._touchIds.some(t => !this.ctrl.touchIds.has(t)) && (this.state._active = !1,
        this.compute(e),
        this.emit())
    }
    pointerEnd(e) {
        const t = this.state;
        this.ctrl.setEventIds(e);
        try {
            e.target.releasePointerCapture(e.pointerId)
        } catch {}
        t._pointerEvents.has(e.pointerId) && t._pointerEvents.delete(e.pointerId),
        !!t._active && t._pointerEvents.size < 2 && (t._active = !1,
        this.compute(e),
        this.emit())
    }
    gestureStart(e) {
        e.cancelable && e.preventDefault();
        const t = this.state;
        t._active || (this.start(e),
        this.computePhilosophy([e.scale, e.rotation]),
        t.origin = [e.clientX, e.clientY],
        this.compute(e),
        this.emit())
    }
    gestureMove(e) {
        if (e.cancelable && e.preventDefault(),
        !this.state._active)
            return;
        const t = this.state;
        this.computePhilosophy([e.scale, e.rotation]),
        t.origin = [e.clientX, e.clientY];
        const n = t._movement;
        t._movement = [e.scale - 1, e.rotation],
        t._delta = ft.sub(t._movement, n),
        this.compute(e),
        this.emit()
    }
    gestureEnd(e) {
        !this.state._active || (this.state._active = !1,
        this.compute(e),
        this.emit())
    }
    wheel(e) {
        const t = this.config.modifierKey;
        t && !e[t] || (this.state._active ? this.wheelChange(e) : this.wheelStart(e),
        this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this)))
    }
    wheelStart(e) {
        this.start(e),
        this.wheelChange(e)
    }
    wheelChange(e) {
        "uv"in e || e.cancelable && e.preventDefault();
        const n = this.state;
        n._delta = [-Pg(e)[1] / Ox * n.offset[0], 0],
        ft.addTo(n._movement, n._delta),
        this.state.origin = [e.clientX, e.clientY],
        this.compute(e),
        this.emit()
    }
    wheelEnd() {
        !this.state._active || (this.state._active = !1,
        this.compute(),
        this.emit())
    }
    bind(e) {
        const t = this.config.device;
        t && (e(t, "start", this[t + "Start"].bind(this)),
        e(t, "change", this[t + "Move"].bind(this)),
        e(t, "end", this[t + "End"].bind(this)),
        e(t, "cancel", this[t + "End"].bind(this))),
        e("wheel", "", this.wheel.bind(this), {
            passive: !1
        })
    }
}
const kx = pt(pt({}, Fg), {}, {
    device(o, e, {shared: t, pointer: {touch: n=!1}={}}) {
        if (t.target && !On.touch && On.gesture)
            return "gesture";
        if (On.touch && n)
            return "touch";
        if (On.touchscreen) {
            if (On.pointer)
                return "pointer";
            if (On.touch)
                return "touch"
        }
    },
    bounds(o, e, {scaleBounds: t={}, angleBounds: n={}}) {
        const i = s => {
            const a = Ff(Ol(t, s), {
                min: -1 / 0,
                max: 1 / 0
            });
            return [a.min, a.max]
        }
          , r = s => {
            const a = Ff(Ol(n, s), {
                min: -1 / 0,
                max: 1 / 0
            });
            return [a.min, a.max]
        }
        ;
        return typeof t != "function" && typeof n != "function" ? [i(), r()] : s => [i(s), r(s)]
    },
    threshold(o, e, t) {
        return this.lockDirection = t.axis === "lock",
        ft.toVector(o, this.lockDirection ? [.1, 3] : 0)
    },
    modifierKey(o) {
        return o === void 0 ? "ctrlKey" : o
    }
});
class zx extends da {
    constructor(...e) {
        super(...e),
        Tt(this, "ingKey", "moving")
    }
    move(e) {
        this.config.mouseOnly && e.pointerType !== "mouse" || (this.state._active ? this.moveChange(e) : this.moveStart(e),
        this.timeoutStore.add("moveEnd", this.moveEnd.bind(this)))
    }
    moveStart(e) {
        this.start(e),
        this.computePhilosophy(Qs(e)),
        this.compute(e),
        this.computeInitial(),
        this.emit()
    }
    moveChange(e) {
        if (!this.state._active)
            return;
        const t = Qs(e)
          , n = this.state;
        n._delta = ft.sub(t, n._values),
        ft.addTo(n._movement, n._delta),
        this.computePhilosophy(t),
        this.compute(e),
        this.emit()
    }
    moveEnd(e) {
        !this.state._active || (this.state._active = !1,
        this.compute(e),
        this.emit())
    }
    bind(e) {
        e("pointer", "change", this.move.bind(this)),
        e("pointer", "leave", this.moveEnd.bind(this))
    }
}
const Ux = pt(pt({}, rs), {}, {
    mouseOnly: (o=!0) => o
});
class Bx extends da {
    constructor(...e) {
        super(...e),
        Tt(this, "ingKey", "scrolling")
    }
    scroll(e) {
        this.state._active || this.start(e),
        this.scrollChange(e),
        this.timeoutStore.add("scrollEnd", this.scrollEnd.bind(this))
    }
    scrollChange(e) {
        e.cancelable && e.preventDefault();
        const t = this.state
          , n = px(e);
        t._delta = ft.sub(n, t._values),
        ft.addTo(t._movement, t._delta),
        this.computePhilosophy(n),
        this.compute(e),
        this.emit()
    }
    scrollEnd() {
        !this.state._active || (this.state._active = !1,
        this.compute(),
        this.emit())
    }
    bind(e) {
        e("scroll", "", this.scroll.bind(this))
    }
}
const Vx = rs;
class Gx extends da {
    constructor(...e) {
        super(...e),
        Tt(this, "ingKey", "wheeling")
    }
    wheel(e) {
        this.state._active || this.start(e),
        this.wheelChange(e),
        this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this))
    }
    wheelChange(e) {
        const t = this.state;
        t._delta = Pg(e),
        ft.addTo(t._movement, t._delta);
        const [n,i] = t.overflow
          , [r,s] = t._delta
          , [a,l] = t._direction;
        (n < 0 && r > 0 && a < 0 || n > 0 && r < 0 && a > 0) && (t._movement[0] = t._movementBound[0]),
        (i < 0 && s > 0 && l < 0 || i > 0 && s < 0 && l > 0) && (t._movement[1] = t._movementBound[1]),
        this.compute(e),
        this.emit()
    }
    wheelEnd() {
        !this.state._active || (this.state._active = !1,
        this.compute(),
        this.emit())
    }
    bind(e) {
        e("wheel", "", this.wheel.bind(this))
    }
}
const Hx = rs;
class Wx extends da {
    constructor(...e) {
        super(...e),
        Tt(this, "ingKey", "hovering")
    }
    enter(e) {
        this.config.mouseOnly && e.pointerType !== "mouse" || (this.start(e),
        this.computePhilosophy(Qs(e)),
        this.compute(e),
        this.emit())
    }
    leave(e) {
        if (this.config.mouseOnly && e.pointerType !== "mouse")
            return;
        const t = this.state;
        if (!t._active)
            return;
        t._active = !1;
        const n = Qs(e);
        t._movement = t._delta = ft.sub(n, t._values),
        this.computePhilosophy(n),
        this.compute(e),
        t.delta = t.movement,
        this.emit()
    }
    bind(e) {
        e("pointer", "enter", this.enter.bind(this)),
        e("pointer", "leave", this.leave.bind(this))
    }
}
const jx = pt(pt({}, rs), {}, {
    mouseOnly: (o=!0) => o
})
  , ch = new Map
  , Sc = new Map;
function qx(o) {
    ch.set(o.key, o.engine),
    Sc.set(o.key, o.resolver)
}
const Xx = {
    key: "drag",
    engine: wx,
    resolver: Ix
}
  , Yx = {
    key: "hover",
    engine: Wx,
    resolver: jx
}
  , Kx = {
    key: "move",
    engine: zx,
    resolver: Ux
}
  , $x = {
    key: "pinch",
    engine: Nx,
    resolver: kx
}
  , Zx = {
    key: "scroll",
    engine: Bx,
    resolver: Vx
}
  , Qx = {
    key: "wheel",
    engine: Gx,
    resolver: Hx
};
function Jx(o, e) {
    if (o == null)
        return {};
    var t = {}, n = Object.keys(o), i, r;
    for (r = 0; r < n.length; r++)
        i = n[r],
        !(e.indexOf(i) >= 0) && (t[i] = o[i]);
    return t
}
function ey(o, e) {
    if (o == null)
        return {};
    var t = Jx(o, e), n, i;
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(o);
        for (i = 0; i < r.length; i++)
            n = r[i],
            !(e.indexOf(n) >= 0) && (!Object.prototype.propertyIsEnumerable.call(o, n) || (t[n] = o[n]))
    }
    return t
}
const ty = {
    target(o) {
        if (o)
            return () => "current"in o ? o.current : o
    },
    enabled(o=!0) {
        return o
    },
    window(o=On.isBrowser ? window : void 0) {
        return o
    },
    eventOptions({passive: o=!0, capture: e=!1}={}) {
        return {
            passive: o,
            capture: e
        }
    },
    transform(o) {
        return o
    }
}
  , ny = ["target", "eventOptions", "window", "enabled", "transform"];
function yl(o={}, e) {
    const t = {};
    for (const [n,i] of Object.entries(e))
        switch (typeof i) {
        case "function":
            t[n] = i.call(t, o[n], n, o);
            break;
        case "object":
            t[n] = yl(o[n], i);
            break;
        case "boolean":
            i && (t[n] = o[n]);
            break
        }
    return t
}
function iy(o, e, t={}) {
    const n = o
      , {target: i, eventOptions: r, window: s, enabled: a, transform: l} = n
      , u = ey(n, ny);
    if (t.shared = yl({
        target: i,
        eventOptions: r,
        window: s,
        enabled: a,
        transform: l
    }, ty),
    e) {
        const c = Sc.get(e);
        t[e] = yl(pt({
            shared: t.shared
        }, u), c)
    } else
        for (const c in u) {
            const h = Sc.get(c);
            h && (t[c] = yl(pt({
                shared: t.shared
            }, u[c]), h))
        }
    return t
}
class Og {
    constructor(e, t) {
        Tt(this, "_listeners", new Set),
        this._ctrl = e,
        this._gestureKey = t
    }
    add(e, t, n, i, r) {
        const s = this._listeners
          , a = cx(t, n)
          , l = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {}
          , u = pt(pt({}, l), r);
        e.addEventListener(a, i, u);
        const c = () => {
            e.removeEventListener(a, i, u),
            s.delete(c)
        }
        ;
        return s.add(c),
        c
    }
    clean() {
        this._listeners.forEach(e => e()),
        this._listeners.clear()
    }
}
class ry {
    constructor() {
        Tt(this, "_timeouts", new Map)
    }
    add(e, t, n=140, ...i) {
        this.remove(e),
        this._timeouts.set(e, window.setTimeout(t, n, ...i))
    }
    remove(e) {
        const t = this._timeouts.get(e);
        t && window.clearTimeout(t)
    }
    clean() {
        this._timeouts.forEach(e => void window.clearTimeout(e)),
        this._timeouts.clear()
    }
}
class sy {
    constructor(e) {
        Tt(this, "gestures", new Set),
        Tt(this, "_targetEventStore", new Og(this)),
        Tt(this, "gestureEventStores", {}),
        Tt(this, "gestureTimeoutStores", {}),
        Tt(this, "handlers", {}),
        Tt(this, "config", {}),
        Tt(this, "pointerIds", new Set),
        Tt(this, "touchIds", new Set),
        Tt(this, "state", {
            shared: {
                shiftKey: !1,
                metaKey: !1,
                ctrlKey: !1,
                altKey: !1
            }
        }),
        oy(this, e)
    }
    setEventIds(e) {
        if (Wl(e))
            return this.touchIds = new Set(dx(e)),
            this.touchIds;
        if ("pointerId"in e)
            return e.type === "pointerup" || e.type === "pointercancel" ? this.pointerIds.delete(e.pointerId) : e.type === "pointerdown" && this.pointerIds.add(e.pointerId),
            this.pointerIds
    }
    applyHandlers(e, t) {
        this.handlers = e,
        this.nativeHandlers = t
    }
    applyConfig(e, t) {
        this.config = iy(e, t, this.config)
    }
    clean() {
        this._targetEventStore.clean();
        for (const e of this.gestures)
            this.gestureEventStores[e].clean(),
            this.gestureTimeoutStores[e].clean()
    }
    effect() {
        return this.config.shared.target && this.bind(),
        () => this._targetEventStore.clean()
    }
    bind(...e) {
        const t = this.config.shared
          , n = {};
        let i;
        if (!(t.target && (i = t.target(),
        !i))) {
            if (t.enabled) {
                for (const s of this.gestures) {
                    const a = this.config[s]
                      , l = Uf(n, a.eventOptions, !!i);
                    if (a.enabled) {
                        const u = ch.get(s);
                        new u(this,e,s).bind(l)
                    }
                }
                const r = Uf(n, t.eventOptions, !!i);
                for (const s in this.nativeHandlers)
                    r(s, "", a => this.nativeHandlers[s](pt(pt({}, this.state.shared), {}, {
                        event: a,
                        args: e
                    })), void 0, !0)
            }
            for (const r in n)
                n[r] = _x(...n[r]);
            if (!i)
                return n;
            for (const r in n) {
                const {device: s, capture: a, passive: l} = ux(r);
                this._targetEventStore.add(i, s, "", n[r], {
                    capture: a,
                    passive: l
                })
            }
        }
    }
}
function fs(o, e) {
    o.gestures.add(e),
    o.gestureEventStores[e] = new Og(o,e),
    o.gestureTimeoutStores[e] = new ry
}
function oy(o, e) {
    e.drag && fs(o, "drag"),
    e.wheel && fs(o, "wheel"),
    e.scroll && fs(o, "scroll"),
    e.move && fs(o, "move"),
    e.pinch && fs(o, "pinch"),
    e.hover && fs(o, "hover")
}
const Uf = (o, e, t) => (n, i, r, s={}, a=!1) => {
    var l, u;
    const c = (l = s.capture) !== null && l !== void 0 ? l : e.capture
      , h = (u = s.passive) !== null && u !== void 0 ? u : e.passive;
    let f = a ? n : ax(n, i, c);
    t && h && (f += "Passive"),
    o[f] = o[f] || [],
    o[f].push(r)
}
  , ay = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
function ly(o) {
    const e = {}
      , t = {}
      , n = new Set;
    for (let i in o)
        ay.test(i) ? (n.add(RegExp.lastMatch),
        t[i] = o[i]) : e[i] = o[i];
    return [t, e, n]
}
function ds(o, e, t, n, i, r) {
    if (!o.has(t) || !ch.has(n))
        return;
    const s = t + "Start"
      , a = t + "End"
      , l = u => {
        let c;
        return u.first && s in e && e[s](u),
        t in e && (c = e[t](u)),
        u.last && a in e && e[a](u),
        c
    }
    ;
    i[n] = l,
    r[n] = r[n] || {}
}
function uy(o, e) {
    const [t,n,i] = ly(o)
      , r = {};
    return ds(i, t, "onDrag", "drag", r, e),
    ds(i, t, "onWheel", "wheel", r, e),
    ds(i, t, "onScroll", "scroll", r, e),
    ds(i, t, "onPinch", "pinch", r, e),
    ds(i, t, "onMove", "move", r, e),
    ds(i, t, "onHover", "hover", r, e),
    {
        handlers: r,
        config: e,
        nativeHandlers: n
    }
}
function cy(o, e, t) {
    return e in o ? Object.defineProperty(o, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : o[e] = t,
    o
}
function Bf(o, e) {
    var t = Object.keys(o);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(o);
        e && (n = n.filter(function(i) {
            return Object.getOwnPropertyDescriptor(o, i).enumerable
        })),
        t.push.apply(t, n)
    }
    return t
}
function Oa(o) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? Bf(Object(t), !0).forEach(function(n) {
            cy(o, n, t[n])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(t)) : Bf(Object(t)).forEach(function(n) {
            Object.defineProperty(o, n, Object.getOwnPropertyDescriptor(t, n))
        })
    }
    return o
}
class hy {
    constructor(e, t, n, i, r) {
        this._target = e,
        this._gestureKey = i,
        this._ctrl = new sy(t),
        this._ctrl.applyHandlers(t, r),
        this._ctrl.applyConfig(Oa(Oa({}, n), {}, {
            target: e
        }), i),
        this._ctrl.effect()
    }
    destroy() {
        this._ctrl.clean()
    }
    setConfig(e) {
        this._ctrl.clean(),
        this._ctrl.applyConfig(Oa(Oa({}, e), {}, {
            target: this._target
        }), this._gestureKey),
        this._ctrl.effect()
    }
}
function fy(o) {
    return o.forEach(qx),
    function(e, t, n) {
        const {handlers: i, nativeHandlers: r, config: s} = uy(t, n || {});
        return new hy(e,i,s,void 0,r)
    }
}
const YT = function(e, t, n) {
    return fy([Xx, $x, Zx, Qx, Kx, Yx])(e, t, n || {})
};
/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const hh = "144"
  , dy = 0
  , Vf = 1
  , py = 2
  , Ng = 1
  , my = 2
  , Ro = 3
  , Jr = 0
  , Wn = 1
  , Oi = 2
  , hr = 0
  , Gs = 1
  , Gf = 2
  , Hf = 3
  , Wf = 4
  , gy = 5
  , Ls = 100
  , _y = 101
  , vy = 102
  , jf = 103
  , qf = 104
  , xy = 200
  , yy = 201
  , by = 202
  , wy = 203
  , kg = 204
  , zg = 205
  , My = 206
  , Sy = 207
  , Dy = 208
  , Ty = 209
  , Ey = 210
  , Ay = 0
  , Cy = 1
  , Ly = 2
  , Dc = 3
  , Ry = 4
  , Py = 5
  , Iy = 6
  , Fy = 7
  , Ug = 0
  , Oy = 1
  , Ny = 2
  , Ui = 0
  , ky = 1
  , zy = 2
  , Uy = 3
  , By = 4
  , Vy = 5
  , Bg = 300
  , Js = 301
  , eo = 302
  , Tc = 303
  , Ec = 304
  , jl = 306
  , to = 1e3
  , fn = 1001
  , Nl = 1002
  , Vt = 1003
  , Ac = 1004
  , Cc = 1005
  , It = 1006
  , Vg = 1007
  , ss = 1008
  , es = 1009
  , Gy = 1010
  , Hy = 1011
  , Gg = 1012
  , Wy = 1013
  , kr = 1014
  , Qn = 1015
  , Ni = 1016
  , jy = 1017
  , qy = 1018
  , Hs = 1020
  , Xy = 1021
  , Yy = 1022
  , Jn = 1023
  , Ky = 1024
  , $y = 1025
  , qr = 1026
  , no = 1027
  , Zy = 1028
  , Qy = 1029
  , Jy = 1030
  , eb = 1031
  , tb = 1033
  , vu = 33776
  , xu = 33777
  , yu = 33778
  , bu = 33779
  , Xf = 35840
  , Yf = 35841
  , Kf = 35842
  , $f = 35843
  , nb = 36196
  , Zf = 37492
  , Qf = 37496
  , Jf = 37808
  , ed = 37809
  , td = 37810
  , nd = 37811
  , id = 37812
  , rd = 37813
  , sd = 37814
  , od = 37815
  , ad = 37816
  , ld = 37817
  , ud = 37818
  , cd = 37819
  , hd = 37820
  , fd = 37821
  , dd = 36492
  , oa = 2300
  , io = 2301
  , wu = 2302
  , pd = 2400
  , md = 2401
  , gd = 2402
  , ib = 2500
  , rb = 1
  , Hg = 2
  , pr = 3e3
  , it = 3001
  , sb = 3200
  , ob = 3201
  , fh = 0
  , ab = 1
  , Di = "srgb"
  , zr = "srgb-linear"
  , Mu = 7680
  , lb = 519
  , Lc = 35044
  , _d = "300 es"
  , Rc = 1035;
class oo {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        const n = this._listeners;
        n[e] === void 0 && (n[e] = []),
        n[e].indexOf(t) === -1 && n[e].push(t)
    }
    hasEventListener(e, t) {
        if (this._listeners === void 0)
            return !1;
        const n = this._listeners;
        return n[e] !== void 0 && n[e].indexOf(t) !== -1
    }
    removeEventListener(e, t) {
        if (this._listeners === void 0)
            return;
        const i = this._listeners[e];
        if (i !== void 0) {
            const r = i.indexOf(t);
            r !== -1 && i.splice(r, 1)
        }
    }
    dispatchEvent(e) {
        if (this._listeners === void 0)
            return;
        const n = this._listeners[e.type];
        if (n !== void 0) {
            e.target = this;
            const i = n.slice(0);
            for (let r = 0, s = i.length; r < s; r++)
                i[r].call(this, e);
            e.target = null
        }
    }
}
const Gt = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let vd = 1234567;
const jo = Math.PI / 180
  , aa = 180 / Math.PI;
function ti() {
    const o = Math.random() * 4294967295 | 0
      , e = Math.random() * 4294967295 | 0
      , t = Math.random() * 4294967295 | 0
      , n = Math.random() * 4294967295 | 0;
    return (Gt[o & 255] + Gt[o >> 8 & 255] + Gt[o >> 16 & 255] + Gt[o >> 24 & 255] + "-" + Gt[e & 255] + Gt[e >> 8 & 255] + "-" + Gt[e >> 16 & 15 | 64] + Gt[e >> 24 & 255] + "-" + Gt[t & 63 | 128] + Gt[t >> 8 & 255] + "-" + Gt[t >> 16 & 255] + Gt[t >> 24 & 255] + Gt[n & 255] + Gt[n >> 8 & 255] + Gt[n >> 16 & 255] + Gt[n >> 24 & 255]).toLowerCase()
}
function Wt(o, e, t) {
    return Math.max(e, Math.min(t, o))
}
function dh(o, e) {
    return (o % e + e) % e
}
function ub(o, e, t, n, i) {
    return n + (o - e) * (i - n) / (t - e)
}
function cb(o, e, t) {
    return o !== e ? (t - o) / (e - o) : 0
}
function qo(o, e, t) {
    return (1 - t) * o + t * e
}
function hb(o, e, t, n) {
    return qo(o, e, 1 - Math.exp(-t * n))
}
function fb(o, e=1) {
    return e - Math.abs(dh(o, e * 2) - e)
}
function db(o, e, t) {
    return o <= e ? 0 : o >= t ? 1 : (o = (o - e) / (t - e),
    o * o * (3 - 2 * o))
}
function pb(o, e, t) {
    return o <= e ? 0 : o >= t ? 1 : (o = (o - e) / (t - e),
    o * o * o * (o * (o * 6 - 15) + 10))
}
function mb(o, e) {
    return o + Math.floor(Math.random() * (e - o + 1))
}
function gb(o, e) {
    return o + Math.random() * (e - o)
}
function _b(o) {
    return o * (.5 - Math.random())
}
function vb(o) {
    o !== void 0 && (vd = o);
    let e = vd += 1831565813;
    return e = Math.imul(e ^ e >>> 15, e | 1),
    e ^= e + Math.imul(e ^ e >>> 7, e | 61),
    ((e ^ e >>> 14) >>> 0) / 4294967296
}
function xb(o) {
    return o * jo
}
function yb(o) {
    return o * aa
}
function Pc(o) {
    return (o & o - 1) === 0 && o !== 0
}
function Wg(o) {
    return Math.pow(2, Math.ceil(Math.log(o) / Math.LN2))
}
function kl(o) {
    return Math.pow(2, Math.floor(Math.log(o) / Math.LN2))
}
function bb(o, e, t, n, i) {
    const r = Math.cos
      , s = Math.sin
      , a = r(t / 2)
      , l = s(t / 2)
      , u = r((e + n) / 2)
      , c = s((e + n) / 2)
      , h = r((e - n) / 2)
      , f = s((e - n) / 2)
      , m = r((n - e) / 2)
      , _ = s((n - e) / 2);
    switch (i) {
    case "XYX":
        o.set(a * c, l * h, l * f, a * u);
        break;
    case "YZY":
        o.set(l * f, a * c, l * h, a * u);
        break;
    case "ZXZ":
        o.set(l * h, l * f, a * c, a * u);
        break;
    case "XZX":
        o.set(a * c, l * _, l * m, a * u);
        break;
    case "YXY":
        o.set(l * m, a * c, l * _, a * u);
        break;
    case "ZYZ":
        o.set(l * _, l * m, a * c, a * u);
        break;
    default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
    }
}
function ki(o, e) {
    switch (e.constructor) {
    case Float32Array:
        return o;
    case Uint16Array:
        return o / 65535;
    case Uint8Array:
        return o / 255;
    case Int16Array:
        return Math.max(o / 32767, -1);
    case Int8Array:
        return Math.max(o / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function lt(o, e) {
    switch (e.constructor) {
    case Float32Array:
        return o;
    case Uint16Array:
        return Math.round(o * 65535);
    case Uint8Array:
        return Math.round(o * 255);
    case Int16Array:
        return Math.round(o * 32767);
    case Int8Array:
        return Math.round(o * 127);
    default:
        throw new Error("Invalid component type.")
    }
}
var wb = Object.freeze({
    __proto__: null,
    DEG2RAD: jo,
    RAD2DEG: aa,
    generateUUID: ti,
    clamp: Wt,
    euclideanModulo: dh,
    mapLinear: ub,
    inverseLerp: cb,
    lerp: qo,
    damp: hb,
    pingpong: fb,
    smoothstep: db,
    smootherstep: pb,
    randInt: mb,
    randFloat: gb,
    randFloatSpread: _b,
    seededRandom: vb,
    degToRad: xb,
    radToDeg: yb,
    isPowerOfTwo: Pc,
    ceilPowerOfTwo: Wg,
    floorPowerOfTwo: kl,
    setQuaternionFromProperEuler: bb,
    normalize: lt,
    denormalize: ki
});
class Ze {
    constructor(e=0, t=0) {
        Ze.prototype.isVector2 = !0,
        this.x = e,
        this.y = t
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, t) {
        return this.x = e,
        this.y = t,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const t = this.x
          , n = this.y
          , i = e.elements;
        return this.x = i[0] * t + i[3] * n + i[6],
        this.y = i[1] * t + i[4] * n + i[7],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , n = this.y - e.y;
        return t * t + n * n
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this
    }
    lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n,
        this.y = e.y + (t.y - e.y) * n,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this
    }
    rotateAround(e, t) {
        const n = Math.cos(t)
          , i = Math.sin(t)
          , r = this.x - e.x
          , s = this.y - e.y;
        return this.x = r * n - s * i + e.x,
        this.y = r * i + s * n + e.y,
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y
    }
}
class Bn {
    constructor() {
        Bn.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]
    }
    set(e, t, n, i, r, s, a, l, u) {
        const c = this.elements;
        return c[0] = e,
        c[1] = i,
        c[2] = a,
        c[3] = t,
        c[4] = r,
        c[5] = l,
        c[6] = n,
        c[7] = s,
        c[8] = u,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    }
    copy(e) {
        const t = this.elements
          , n = e.elements;
        return t[0] = n[0],
        t[1] = n[1],
        t[2] = n[2],
        t[3] = n[3],
        t[4] = n[4],
        t[5] = n[5],
        t[6] = n[6],
        t[7] = n[7],
        t[8] = n[8],
        this
    }
    extractBasis(e, t, n) {
        return e.setFromMatrix3Column(this, 0),
        t.setFromMatrix3Column(this, 1),
        n.setFromMatrix3Column(this, 2),
        this
    }
    setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const n = e.elements
          , i = t.elements
          , r = this.elements
          , s = n[0]
          , a = n[3]
          , l = n[6]
          , u = n[1]
          , c = n[4]
          , h = n[7]
          , f = n[2]
          , m = n[5]
          , _ = n[8]
          , d = i[0]
          , p = i[3]
          , v = i[6]
          , x = i[1]
          , S = i[4]
          , M = i[7]
          , T = i[2]
          , L = i[5]
          , P = i[8];
        return r[0] = s * d + a * x + l * T,
        r[3] = s * p + a * S + l * L,
        r[6] = s * v + a * M + l * P,
        r[1] = u * d + c * x + h * T,
        r[4] = u * p + c * S + h * L,
        r[7] = u * v + c * M + h * P,
        r[2] = f * d + m * x + _ * T,
        r[5] = f * p + m * S + _ * L,
        r[8] = f * v + m * M + _ * P,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[3] *= e,
        t[6] *= e,
        t[1] *= e,
        t[4] *= e,
        t[7] *= e,
        t[2] *= e,
        t[5] *= e,
        t[8] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , n = e[1]
          , i = e[2]
          , r = e[3]
          , s = e[4]
          , a = e[5]
          , l = e[6]
          , u = e[7]
          , c = e[8];
        return t * s * c - t * a * u - n * r * c + n * a * l + i * r * u - i * s * l
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , n = e[1]
          , i = e[2]
          , r = e[3]
          , s = e[4]
          , a = e[5]
          , l = e[6]
          , u = e[7]
          , c = e[8]
          , h = c * s - a * u
          , f = a * l - c * r
          , m = u * r - s * l
          , _ = t * h + n * f + i * m;
        if (_ === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const d = 1 / _;
        return e[0] = h * d,
        e[1] = (i * u - c * n) * d,
        e[2] = (a * n - i * s) * d,
        e[3] = f * d,
        e[4] = (c * t - i * l) * d,
        e[5] = (i * r - a * t) * d,
        e[6] = m * d,
        e[7] = (n * l - u * t) * d,
        e[8] = (s * t - n * r) * d,
        this
    }
    transpose() {
        let e;
        const t = this.elements;
        return e = t[1],
        t[1] = t[3],
        t[3] = e,
        e = t[2],
        t[2] = t[6],
        t[6] = e,
        e = t[5],
        t[5] = t[7],
        t[7] = e,
        this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const t = this.elements;
        return e[0] = t[0],
        e[1] = t[3],
        e[2] = t[6],
        e[3] = t[1],
        e[4] = t[4],
        e[5] = t[7],
        e[6] = t[2],
        e[7] = t[5],
        e[8] = t[8],
        this
    }
    setUvTransform(e, t, n, i, r, s, a) {
        const l = Math.cos(r)
          , u = Math.sin(r);
        return this.set(n * l, n * u, -n * (l * s + u * a) + s + e, -i * u, i * l, -i * (-u * s + l * a) + a + t, 0, 0, 1),
        this
    }
    scale(e, t) {
        const n = this.elements;
        return n[0] *= e,
        n[3] *= e,
        n[6] *= e,
        n[1] *= t,
        n[4] *= t,
        n[7] *= t,
        this
    }
    rotate(e) {
        const t = Math.cos(e)
          , n = Math.sin(e)
          , i = this.elements
          , r = i[0]
          , s = i[3]
          , a = i[6]
          , l = i[1]
          , u = i[4]
          , c = i[7];
        return i[0] = t * r + n * l,
        i[3] = t * s + n * u,
        i[6] = t * a + n * c,
        i[1] = -n * r + t * l,
        i[4] = -n * s + t * u,
        i[7] = -n * a + t * c,
        this
    }
    translate(e, t) {
        const n = this.elements;
        return n[0] += e * n[2],
        n[3] += e * n[5],
        n[6] += e * n[8],
        n[1] += t * n[2],
        n[4] += t * n[5],
        n[7] += t * n[8],
        this
    }
    equals(e) {
        const t = this.elements
          , n = e.elements;
        for (let i = 0; i < 9; i++)
            if (t[i] !== n[i])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let n = 0; n < 9; n++)
            this.elements[n] = e[n + t];
        return this
    }
    toArray(e=[], t=0) {
        const n = this.elements;
        return e[t] = n[0],
        e[t + 1] = n[1],
        e[t + 2] = n[2],
        e[t + 3] = n[3],
        e[t + 4] = n[4],
        e[t + 5] = n[5],
        e[t + 6] = n[6],
        e[t + 7] = n[7],
        e[t + 8] = n[8],
        e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
function jg(o) {
    for (let e = o.length - 1; e >= 0; --e)
        if (o[e] >= 65535)
            return !0;
    return !1
}
function la(o) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", o)
}
function Xr(o) {
    return o < .04045 ? o * .0773993808 : Math.pow(o * .9478672986 + .0521327014, 2.4)
}
function bl(o) {
    return o < .0031308 ? o * 12.92 : 1.055 * Math.pow(o, .41666) - .055
}
const Su = {
    [Di]: {
        [zr]: Xr
    },
    [zr]: {
        [Di]: bl
    }
}
  , Xn = {
    legacyMode: !0,
    get workingColorSpace() {
        return zr
    },
    set workingColorSpace(o) {
        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
    },
    convert: function(o, e, t) {
        if (this.legacyMode || e === t || !e || !t)
            return o;
        if (Su[e] && Su[e][t] !== void 0) {
            const n = Su[e][t];
            return o.r = n(o.r),
            o.g = n(o.g),
            o.b = n(o.b),
            o
        }
        throw new Error("Unsupported color space conversion.")
    },
    fromWorkingColorSpace: function(o, e) {
        return this.convert(o, this.workingColorSpace, e)
    },
    toWorkingColorSpace: function(o, e) {
        return this.convert(o, e, this.workingColorSpace)
    }
}
  , qg = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}
  , Lt = {
    r: 0,
    g: 0,
    b: 0
}
  , Yn = {
    h: 0,
    s: 0,
    l: 0
}
  , Na = {
    h: 0,
    s: 0,
    l: 0
};
function Du(o, e, t) {
    return t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? o + (e - o) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? o + (e - o) * 6 * (2 / 3 - t) : o
}
function ka(o, e) {
    return e.r = o.r,
    e.g = o.g,
    e.b = o.b,
    e
}
class ze {
    constructor(e, t, n) {
        return this.isColor = !0,
        this.r = 1,
        this.g = 1,
        this.b = 1,
        t === void 0 && n === void 0 ? this.set(e) : this.setRGB(e, t, n)
    }
    set(e) {
        return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e),
        this
    }
    setScalar(e) {
        return this.r = e,
        this.g = e,
        this.b = e,
        this
    }
    setHex(e, t=Di) {
        return e = Math.floor(e),
        this.r = (e >> 16 & 255) / 255,
        this.g = (e >> 8 & 255) / 255,
        this.b = (e & 255) / 255,
        Xn.toWorkingColorSpace(this, t),
        this
    }
    setRGB(e, t, n, i=zr) {
        return this.r = e,
        this.g = t,
        this.b = n,
        Xn.toWorkingColorSpace(this, i),
        this
    }
    setHSL(e, t, n, i=zr) {
        if (e = dh(e, 1),
        t = Wt(t, 0, 1),
        n = Wt(n, 0, 1),
        t === 0)
            this.r = this.g = this.b = n;
        else {
            const r = n <= .5 ? n * (1 + t) : n + t - n * t
              , s = 2 * n - r;
            this.r = Du(s, r, e + 1 / 3),
            this.g = Du(s, r, e),
            this.b = Du(s, r, e - 1 / 3)
        }
        return Xn.toWorkingColorSpace(this, i),
        this
    }
    setStyle(e, t=Di) {
        function n(r) {
            r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let i;
        if (i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
            let r;
            const s = i[1]
              , a = i[2];
            switch (s) {
            case "rgb":
            case "rgba":
                if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return this.r = Math.min(255, parseInt(r[1], 10)) / 255,
                    this.g = Math.min(255, parseInt(r[2], 10)) / 255,
                    this.b = Math.min(255, parseInt(r[3], 10)) / 255,
                    Xn.toWorkingColorSpace(this, t),
                    n(r[4]),
                    this;
                if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return this.r = Math.min(100, parseInt(r[1], 10)) / 100,
                    this.g = Math.min(100, parseInt(r[2], 10)) / 100,
                    this.b = Math.min(100, parseInt(r[3], 10)) / 100,
                    Xn.toWorkingColorSpace(this, t),
                    n(r[4]),
                    this;
                break;
            case "hsl":
            case "hsla":
                if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) {
                    const l = parseFloat(r[1]) / 360
                      , u = parseFloat(r[2]) / 100
                      , c = parseFloat(r[3]) / 100;
                    return n(r[4]),
                    this.setHSL(l, u, c, t)
                }
                break
            }
        } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const r = i[1]
              , s = r.length;
            if (s === 3)
                return this.r = parseInt(r.charAt(0) + r.charAt(0), 16) / 255,
                this.g = parseInt(r.charAt(1) + r.charAt(1), 16) / 255,
                this.b = parseInt(r.charAt(2) + r.charAt(2), 16) / 255,
                Xn.toWorkingColorSpace(this, t),
                this;
            if (s === 6)
                return this.r = parseInt(r.charAt(0) + r.charAt(1), 16) / 255,
                this.g = parseInt(r.charAt(2) + r.charAt(3), 16) / 255,
                this.b = parseInt(r.charAt(4) + r.charAt(5), 16) / 255,
                Xn.toWorkingColorSpace(this, t),
                this
        }
        return e && e.length > 0 ? this.setColorName(e, t) : this
    }
    setColorName(e, t=Di) {
        const n = qg[e.toLowerCase()];
        return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e),
        this
    }
    clone() {
        return new this.constructor(this.r,this.g,this.b)
    }
    copy(e) {
        return this.r = e.r,
        this.g = e.g,
        this.b = e.b,
        this
    }
    copySRGBToLinear(e) {
        return this.r = Xr(e.r),
        this.g = Xr(e.g),
        this.b = Xr(e.b),
        this
    }
    copyLinearToSRGB(e) {
        return this.r = bl(e.r),
        this.g = bl(e.g),
        this.b = bl(e.b),
        this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this),
        this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this),
        this
    }
    getHex(e=Di) {
        return Xn.fromWorkingColorSpace(ka(this, Lt), e),
        Wt(Lt.r * 255, 0, 255) << 16 ^ Wt(Lt.g * 255, 0, 255) << 8 ^ Wt(Lt.b * 255, 0, 255) << 0
    }
    getHexString(e=Di) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, t=zr) {
        Xn.fromWorkingColorSpace(ka(this, Lt), t);
        const n = Lt.r
          , i = Lt.g
          , r = Lt.b
          , s = Math.max(n, i, r)
          , a = Math.min(n, i, r);
        let l, u;
        const c = (a + s) / 2;
        if (a === s)
            l = 0,
            u = 0;
        else {
            const h = s - a;
            switch (u = c <= .5 ? h / (s + a) : h / (2 - s - a),
            s) {
            case n:
                l = (i - r) / h + (i < r ? 6 : 0);
                break;
            case i:
                l = (r - n) / h + 2;
                break;
            case r:
                l = (n - i) / h + 4;
                break
            }
            l /= 6
        }
        return e.h = l,
        e.s = u,
        e.l = c,
        e
    }
    getRGB(e, t=zr) {
        return Xn.fromWorkingColorSpace(ka(this, Lt), t),
        e.r = Lt.r,
        e.g = Lt.g,
        e.b = Lt.b,
        e
    }
    getStyle(e=Di) {
        return Xn.fromWorkingColorSpace(ka(this, Lt), e),
        e !== Di ? `color(${e} ${Lt.r} ${Lt.g} ${Lt.b})` : `rgb(${Lt.r * 255 | 0},${Lt.g * 255 | 0},${Lt.b * 255 | 0})`
    }
    offsetHSL(e, t, n) {
        return this.getHSL(Yn),
        Yn.h += e,
        Yn.s += t,
        Yn.l += n,
        this.setHSL(Yn.h, Yn.s, Yn.l),
        this
    }
    add(e) {
        return this.r += e.r,
        this.g += e.g,
        this.b += e.b,
        this
    }
    addColors(e, t) {
        return this.r = e.r + t.r,
        this.g = e.g + t.g,
        this.b = e.b + t.b,
        this
    }
    addScalar(e) {
        return this.r += e,
        this.g += e,
        this.b += e,
        this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r),
        this.g = Math.max(0, this.g - e.g),
        this.b = Math.max(0, this.b - e.b),
        this
    }
    multiply(e) {
        return this.r *= e.r,
        this.g *= e.g,
        this.b *= e.b,
        this
    }
    multiplyScalar(e) {
        return this.r *= e,
        this.g *= e,
        this.b *= e,
        this
    }
    lerp(e, t) {
        return this.r += (e.r - this.r) * t,
        this.g += (e.g - this.g) * t,
        this.b += (e.b - this.b) * t,
        this
    }
    lerpColors(e, t, n) {
        return this.r = e.r + (t.r - e.r) * n,
        this.g = e.g + (t.g - e.g) * n,
        this.b = e.b + (t.b - e.b) * n,
        this
    }
    lerpHSL(e, t) {
        this.getHSL(Yn),
        e.getHSL(Na);
        const n = qo(Yn.h, Na.h, t)
          , i = qo(Yn.s, Na.s, t)
          , r = qo(Yn.l, Na.l, t);
        return this.setHSL(n, i, r),
        this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, t=0) {
        return this.r = e[t],
        this.g = e[t + 1],
        this.b = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.r,
        e[t + 1] = this.g,
        e[t + 2] = this.b,
        e
    }
    fromBufferAttribute(e, t) {
        return this.r = e.getX(t),
        this.g = e.getY(t),
        this.b = e.getZ(t),
        this
    }
    toJSON() {
        return this.getHex()
    }
    *[Symbol.iterator]() {
        yield this.r,
        yield this.g,
        yield this.b
    }
}
ze.NAMES = qg;
let ps;
class Xg {
    static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
            return e.src;
        let t;
        if (e instanceof HTMLCanvasElement)
            t = e;
        else {
            ps === void 0 && (ps = la("canvas")),
            ps.width = e.width,
            ps.height = e.height;
            const n = ps.getContext("2d");
            e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height),
            t = ps
        }
        return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
        t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const t = la("canvas");
            t.width = e.width,
            t.height = e.height;
            const n = t.getContext("2d");
            n.drawImage(e, 0, 0, e.width, e.height);
            const i = n.getImageData(0, 0, e.width, e.height)
              , r = i.data;
            for (let s = 0; s < r.length; s++)
                r[s] = Xr(r[s] / 255) * 255;
            return n.putImageData(i, 0, 0),
            t
        } else if (e.data) {
            const t = e.data.slice(0);
            for (let n = 0; n < t.length; n++)
                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(Xr(t[n] / 255) * 255) : t[n] = Xr(t[n]);
            return {
                data: t,
                width: e.width,
                height: e.height
            }
        } else
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
            e
    }
}
class Yg {
    constructor(e=null) {
        this.isSource = !0,
        this.uuid = ti(),
        this.data = e,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0)
            return e.images[this.uuid];
        const n = {
            uuid: this.uuid,
            url: ""
        }
          , i = this.data;
        if (i !== null) {
            let r;
            if (Array.isArray(i)) {
                r = [];
                for (let s = 0, a = i.length; s < a; s++)
                    i[s].isDataTexture ? r.push(Tu(i[s].image)) : r.push(Tu(i[s]))
            } else
                r = Tu(i);
            n.url = r
        }
        return t || (e.images[this.uuid] = n),
        n
    }
}
function Tu(o) {
    return typeof HTMLImageElement < "u" && o instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && o instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && o instanceof ImageBitmap ? Xg.getDataURL(o) : o.data ? {
        data: Array.from(o.data),
        width: o.width,
        height: o.height,
        type: o.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
    {})
}
let Mb = 0;
class tn extends oo {
    constructor(e=tn.DEFAULT_IMAGE, t=tn.DEFAULT_MAPPING, n=fn, i=fn, r=It, s=ss, a=Jn, l=es, u=1, c=pr) {
        super(),
        this.isTexture = !0,
        Object.defineProperty(this, "id", {
            value: Mb++
        }),
        this.uuid = ti(),
        this.name = "",
        this.source = new Yg(e),
        this.mipmaps = [],
        this.mapping = t,
        this.wrapS = n,
        this.wrapT = i,
        this.magFilter = r,
        this.minFilter = s,
        this.anisotropy = u,
        this.format = a,
        this.internalFormat = null,
        this.type = l,
        this.offset = new Ze(0,0),
        this.repeat = new Ze(1,1),
        this.center = new Ze(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new Bn,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.encoding = c,
        this.userData = {},
        this.version = 0,
        this.onUpdate = null,
        this.isRenderTargetTexture = !1,
        this.needsPMREMUpdate = !1
    }
    get image() {
        return this.source.data
    }
    set image(e) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name,
        this.source = e.source,
        this.mipmaps = e.mipmaps.slice(0),
        this.mapping = e.mapping,
        this.wrapS = e.wrapS,
        this.wrapT = e.wrapT,
        this.magFilter = e.magFilter,
        this.minFilter = e.minFilter,
        this.anisotropy = e.anisotropy,
        this.format = e.format,
        this.internalFormat = e.internalFormat,
        this.type = e.type,
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        this.rotation = e.rotation,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrix.copy(e.matrix),
        this.generateMipmaps = e.generateMipmaps,
        this.premultiplyAlpha = e.premultiplyAlpha,
        this.flipY = e.flipY,
        this.unpackAlignment = e.unpackAlignment,
        this.encoding = e.encoding,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this.needsUpdate = !0,
        this
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
        const n = {
            metadata: {
                version: 4.5,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return JSON.stringify(this.userData) !== "{}" && (n.userData = this.userData),
        t || (e.textures[this.uuid] = n),
        n
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== Bg)
            return e;
        if (e.applyMatrix3(this.matrix),
        e.x < 0 || e.x > 1)
            switch (this.wrapS) {
            case to:
                e.x = e.x - Math.floor(e.x);
                break;
            case fn:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case Nl:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
            case to:
                e.y = e.y - Math.floor(e.y);
                break;
            case fn:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case Nl:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
            }
        return this.flipY && (e.y = 1 - e.y),
        e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++,
        this.source.needsUpdate = !0)
    }
}
tn.DEFAULT_IMAGE = null;
tn.DEFAULT_MAPPING = Bg;
class ct {
    constructor(e=0, t=0, n=0, i=1) {
        ct.prototype.isVector4 = !0,
        this.x = e,
        this.y = t,
        this.z = n,
        this.w = i
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, t, n, i) {
        return this.x = e,
        this.y = t,
        this.z = n,
        this.w = i,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this.w = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setW(e) {
        return this.w = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        case 3:
            this.w = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z,this.w)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w !== void 0 ? e.w : 1,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this.w += e.w,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this.w += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this.w = e.w + t.w,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this.w += e.w * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this.w -= e.w,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this.w -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this.w = e.w - t.w,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this.w *= e.w,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this.w *= e,
        this
    }
    applyMatrix4(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , r = this.w
          , s = e.elements;
        return this.x = s[0] * t + s[4] * n + s[8] * i + s[12] * r,
        this.y = s[1] * t + s[5] * n + s[9] * i + s[13] * r,
        this.z = s[2] * t + s[6] * n + s[10] * i + s[14] * r,
        this.w = s[3] * t + s[7] * n + s[11] * i + s[15] * r,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = e.x / t,
        this.y = e.y / t,
        this.z = e.z / t),
        this
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, n, i, r;
        const l = e.elements
          , u = l[0]
          , c = l[4]
          , h = l[8]
          , f = l[1]
          , m = l[5]
          , _ = l[9]
          , d = l[2]
          , p = l[6]
          , v = l[10];
        if (Math.abs(c - f) < .01 && Math.abs(h - d) < .01 && Math.abs(_ - p) < .01) {
            if (Math.abs(c + f) < .1 && Math.abs(h + d) < .1 && Math.abs(_ + p) < .1 && Math.abs(u + m + v - 3) < .1)
                return this.set(1, 0, 0, 0),
                this;
            t = Math.PI;
            const S = (u + 1) / 2
              , M = (m + 1) / 2
              , T = (v + 1) / 2
              , L = (c + f) / 4
              , P = (h + d) / 4
              , A = (_ + p) / 4;
            return S > M && S > T ? S < .01 ? (n = 0,
            i = .707106781,
            r = .707106781) : (n = Math.sqrt(S),
            i = L / n,
            r = P / n) : M > T ? M < .01 ? (n = .707106781,
            i = 0,
            r = .707106781) : (i = Math.sqrt(M),
            n = L / i,
            r = A / i) : T < .01 ? (n = .707106781,
            i = .707106781,
            r = 0) : (r = Math.sqrt(T),
            n = P / r,
            i = A / r),
            this.set(n, i, r, t),
            this
        }
        let x = Math.sqrt((p - _) * (p - _) + (h - d) * (h - d) + (f - c) * (f - c));
        return Math.abs(x) < .001 && (x = 1),
        this.x = (p - _) / x,
        this.y = (h - d) / x,
        this.z = (f - c) / x,
        this.w = Math.acos((u + m + v - 1) / 2),
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this.w = Math.min(this.w, e.w),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this.w = Math.max(this.w, e.w),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this.w = Math.max(e.w, Math.min(t.w, this.w)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this.w = Math.max(e, Math.min(t, this.w)),
        this
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this.w += (e.w - this.w) * t,
        this
    }
    lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n,
        this.y = e.y + (t.y - e.y) * n,
        this.z = e.z + (t.z - e.z) * n,
        this.w = e.w + (t.w - e.w) * n,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this.w = e[t + 3],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e[t + 3] = this.w,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this.w = e.getW(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
class ts extends oo {
    constructor(e, t, n={}) {
        super(),
        this.isWebGLRenderTarget = !0,
        this.width = e,
        this.height = t,
        this.depth = 1,
        this.scissor = new ct(0,0,e,t),
        this.scissorTest = !1,
        this.viewport = new ct(0,0,e,t);
        const i = {
            width: e,
            height: t,
            depth: 1
        };
        this.texture = new tn(i,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),
        this.texture.isRenderTargetTexture = !0,
        this.texture.flipY = !1,
        this.texture.generateMipmaps = n.generateMipmaps !== void 0 ? n.generateMipmaps : !1,
        this.texture.internalFormat = n.internalFormat !== void 0 ? n.internalFormat : null,
        this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : It,
        this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0,
        this.stencilBuffer = n.stencilBuffer !== void 0 ? n.stencilBuffer : !1,
        this.depthTexture = n.depthTexture !== void 0 ? n.depthTexture : null,
        this.samples = n.samples !== void 0 ? n.samples : 0
    }
    setSize(e, t, n=1) {
        (this.width !== e || this.height !== t || this.depth !== n) && (this.width = e,
        this.height = t,
        this.depth = n,
        this.texture.image.width = e,
        this.texture.image.height = t,
        this.texture.image.depth = n,
        this.dispose()),
        this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.viewport.copy(e.viewport),
        this.texture = e.texture.clone(),
        this.texture.isRenderTargetTexture = !0;
        const t = Object.assign({}, e.texture.image);
        return this.texture.source = new Yg(t),
        this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.samples = e.samples,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class Kg extends tn {
    constructor(e=null, t=1, n=1, i=1) {
        super(null),
        this.isDataArrayTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: n,
            depth: i
        },
        this.magFilter = Vt,
        this.minFilter = Vt,
        this.wrapR = fn,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class Sb extends tn {
    constructor(e=null, t=1, n=1, i=1) {
        super(null),
        this.isData3DTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: n,
            depth: i
        },
        this.magFilter = Vt,
        this.minFilter = Vt,
        this.wrapR = fn,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class os {
    constructor(e=0, t=0, n=0, i=1) {
        this.isQuaternion = !0,
        this._x = e,
        this._y = t,
        this._z = n,
        this._w = i
    }
    static slerpFlat(e, t, n, i, r, s, a) {
        let l = n[i + 0]
          , u = n[i + 1]
          , c = n[i + 2]
          , h = n[i + 3];
        const f = r[s + 0]
          , m = r[s + 1]
          , _ = r[s + 2]
          , d = r[s + 3];
        if (a === 0) {
            e[t + 0] = l,
            e[t + 1] = u,
            e[t + 2] = c,
            e[t + 3] = h;
            return
        }
        if (a === 1) {
            e[t + 0] = f,
            e[t + 1] = m,
            e[t + 2] = _,
            e[t + 3] = d;
            return
        }
        if (h !== d || l !== f || u !== m || c !== _) {
            let p = 1 - a;
            const v = l * f + u * m + c * _ + h * d
              , x = v >= 0 ? 1 : -1
              , S = 1 - v * v;
            if (S > Number.EPSILON) {
                const T = Math.sqrt(S)
                  , L = Math.atan2(T, v * x);
                p = Math.sin(p * L) / T,
                a = Math.sin(a * L) / T
            }
            const M = a * x;
            if (l = l * p + f * M,
            u = u * p + m * M,
            c = c * p + _ * M,
            h = h * p + d * M,
            p === 1 - a) {
                const T = 1 / Math.sqrt(l * l + u * u + c * c + h * h);
                l *= T,
                u *= T,
                c *= T,
                h *= T
            }
        }
        e[t] = l,
        e[t + 1] = u,
        e[t + 2] = c,
        e[t + 3] = h
    }
    static multiplyQuaternionsFlat(e, t, n, i, r, s) {
        const a = n[i]
          , l = n[i + 1]
          , u = n[i + 2]
          , c = n[i + 3]
          , h = r[s]
          , f = r[s + 1]
          , m = r[s + 2]
          , _ = r[s + 3];
        return e[t] = a * _ + c * h + l * m - u * f,
        e[t + 1] = l * _ + c * f + u * h - a * m,
        e[t + 2] = u * _ + c * m + a * f - l * h,
        e[t + 3] = c * _ - a * h - l * f - u * m,
        e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e,
        this._onChangeCallback()
    }
    set(e, t, n, i) {
        return this._x = e,
        this._y = t,
        this._z = n,
        this._w = i,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._w)
    }
    copy(e) {
        return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this._onChangeCallback(),
        this
    }
    setFromEuler(e, t) {
        const n = e._x
          , i = e._y
          , r = e._z
          , s = e._order
          , a = Math.cos
          , l = Math.sin
          , u = a(n / 2)
          , c = a(i / 2)
          , h = a(r / 2)
          , f = l(n / 2)
          , m = l(i / 2)
          , _ = l(r / 2);
        switch (s) {
        case "XYZ":
            this._x = f * c * h + u * m * _,
            this._y = u * m * h - f * c * _,
            this._z = u * c * _ + f * m * h,
            this._w = u * c * h - f * m * _;
            break;
        case "YXZ":
            this._x = f * c * h + u * m * _,
            this._y = u * m * h - f * c * _,
            this._z = u * c * _ - f * m * h,
            this._w = u * c * h + f * m * _;
            break;
        case "ZXY":
            this._x = f * c * h - u * m * _,
            this._y = u * m * h + f * c * _,
            this._z = u * c * _ + f * m * h,
            this._w = u * c * h - f * m * _;
            break;
        case "ZYX":
            this._x = f * c * h - u * m * _,
            this._y = u * m * h + f * c * _,
            this._z = u * c * _ - f * m * h,
            this._w = u * c * h + f * m * _;
            break;
        case "YZX":
            this._x = f * c * h + u * m * _,
            this._y = u * m * h + f * c * _,
            this._z = u * c * _ - f * m * h,
            this._w = u * c * h - f * m * _;
            break;
        case "XZY":
            this._x = f * c * h - u * m * _,
            this._y = u * m * h - f * c * _,
            this._z = u * c * _ + f * m * h,
            this._w = u * c * h + f * m * _;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
        }
        return t !== !1 && this._onChangeCallback(),
        this
    }
    setFromAxisAngle(e, t) {
        const n = t / 2
          , i = Math.sin(n);
        return this._x = e.x * i,
        this._y = e.y * i,
        this._z = e.z * i,
        this._w = Math.cos(n),
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e) {
        const t = e.elements
          , n = t[0]
          , i = t[4]
          , r = t[8]
          , s = t[1]
          , a = t[5]
          , l = t[9]
          , u = t[2]
          , c = t[6]
          , h = t[10]
          , f = n + a + h;
        if (f > 0) {
            const m = .5 / Math.sqrt(f + 1);
            this._w = .25 / m,
            this._x = (c - l) * m,
            this._y = (r - u) * m,
            this._z = (s - i) * m
        } else if (n > a && n > h) {
            const m = 2 * Math.sqrt(1 + n - a - h);
            this._w = (c - l) / m,
            this._x = .25 * m,
            this._y = (i + s) / m,
            this._z = (r + u) / m
        } else if (a > h) {
            const m = 2 * Math.sqrt(1 + a - n - h);
            this._w = (r - u) / m,
            this._x = (i + s) / m,
            this._y = .25 * m,
            this._z = (l + c) / m
        } else {
            const m = 2 * Math.sqrt(1 + h - n - a);
            this._w = (s - i) / m,
            this._x = (r + u) / m,
            this._y = (l + c) / m,
            this._z = .25 * m
        }
        return this._onChangeCallback(),
        this
    }
    setFromUnitVectors(e, t) {
        let n = e.dot(t) + 1;
        return n < Number.EPSILON ? (n = 0,
        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
        this._y = e.x,
        this._z = 0,
        this._w = n) : (this._x = 0,
        this._y = -e.z,
        this._z = e.y,
        this._w = n)) : (this._x = e.y * t.z - e.z * t.y,
        this._y = e.z * t.x - e.x * t.z,
        this._z = e.x * t.y - e.y * t.x,
        this._w = n),
        this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(Wt(this.dot(e), -1, 1)))
    }
    rotateTowards(e, t) {
        const n = this.angleTo(e);
        if (n === 0)
            return this;
        const i = Math.min(1, t / n);
        return this.slerp(e, i),
        this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : (e = 1 / e,
        this._x = this._x * e,
        this._y = this._y * e,
        this._z = this._z * e,
        this._w = this._w * e),
        this._onChangeCallback(),
        this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, t) {
        const n = e._x
          , i = e._y
          , r = e._z
          , s = e._w
          , a = t._x
          , l = t._y
          , u = t._z
          , c = t._w;
        return this._x = n * c + s * a + i * u - r * l,
        this._y = i * c + s * l + r * a - n * u,
        this._z = r * c + s * u + n * l - i * a,
        this._w = s * c - n * a - i * l - r * u,
        this._onChangeCallback(),
        this
    }
    slerp(e, t) {
        if (t === 0)
            return this;
        if (t === 1)
            return this.copy(e);
        const n = this._x
          , i = this._y
          , r = this._z
          , s = this._w;
        let a = s * e._w + n * e._x + i * e._y + r * e._z;
        if (a < 0 ? (this._w = -e._w,
        this._x = -e._x,
        this._y = -e._y,
        this._z = -e._z,
        a = -a) : this.copy(e),
        a >= 1)
            return this._w = s,
            this._x = n,
            this._y = i,
            this._z = r,
            this;
        const l = 1 - a * a;
        if (l <= Number.EPSILON) {
            const m = 1 - t;
            return this._w = m * s + t * this._w,
            this._x = m * n + t * this._x,
            this._y = m * i + t * this._y,
            this._z = m * r + t * this._z,
            this.normalize(),
            this._onChangeCallback(),
            this
        }
        const u = Math.sqrt(l)
          , c = Math.atan2(u, a)
          , h = Math.sin((1 - t) * c) / u
          , f = Math.sin(t * c) / u;
        return this._w = s * h + this._w * f,
        this._x = n * h + this._x * f,
        this._y = i * h + this._y * f,
        this._z = r * h + this._z * f,
        this._onChangeCallback(),
        this
    }
    slerpQuaternions(e, t, n) {
        return this.copy(e).slerp(t, n)
    }
    random() {
        const e = Math.random()
          , t = Math.sqrt(1 - e)
          , n = Math.sqrt(e)
          , i = 2 * Math.PI * Math.random()
          , r = 2 * Math.PI * Math.random();
        return this.set(t * Math.cos(i), n * Math.sin(r), n * Math.cos(r), t * Math.sin(i))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, t=0) {
        return this._x = e[t],
        this._y = e[t + 1],
        this._z = e[t + 2],
        this._w = e[t + 3],
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._w,
        e
    }
    fromBufferAttribute(e, t) {
        return this._x = e.getX(t),
        this._y = e.getY(t),
        this._z = e.getZ(t),
        this._w = e.getW(t),
        this
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._w
    }
}
class X {
    constructor(e=0, t=0, n=0) {
        X.prototype.isVector3 = !0,
        this.x = e,
        this.y = t,
        this.z = n
    }
    set(e, t, n) {
        return n === void 0 && (n = this.z),
        this.x = e,
        this.y = t,
        this.z = n,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this
    }
    multiplyVectors(e, t) {
        return this.x = e.x * t.x,
        this.y = e.y * t.y,
        this.z = e.z * t.z,
        this
    }
    applyEuler(e) {
        return this.applyQuaternion(xd.setFromEuler(e))
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(xd.setFromAxisAngle(e, t))
    }
    applyMatrix3(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , r = e.elements;
        return this.x = r[0] * t + r[3] * n + r[6] * i,
        this.y = r[1] * t + r[4] * n + r[7] * i,
        this.z = r[2] * t + r[5] * n + r[8] * i,
        this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , r = e.elements
          , s = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
        return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * s,
        this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * s,
        this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * s,
        this
    }
    applyQuaternion(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , r = e.x
          , s = e.y
          , a = e.z
          , l = e.w
          , u = l * t + s * i - a * n
          , c = l * n + a * t - r * i
          , h = l * i + r * n - s * t
          , f = -r * t - s * n - a * i;
        return this.x = u * l + f * -r + c * -a - h * -s,
        this.y = c * l + f * -s + h * -r - u * -a,
        this.z = h * l + f * -a + u * -s - c * -r,
        this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , r = e.elements;
        return this.x = r[0] * t + r[4] * n + r[8] * i,
        this.y = r[1] * t + r[5] * n + r[9] * i,
        this.z = r[2] * t + r[6] * n + r[10] * i,
        this.normalize()
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this
    }
    lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n,
        this.y = e.y + (t.y - e.y) * n,
        this.z = e.z + (t.z - e.z) * n,
        this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, t) {
        const n = e.x
          , i = e.y
          , r = e.z
          , s = t.x
          , a = t.y
          , l = t.z;
        return this.x = i * l - r * a,
        this.y = r * s - n * l,
        this.z = n * a - i * s,
        this
    }
    projectOnVector(e) {
        const t = e.lengthSq();
        if (t === 0)
            return this.set(0, 0, 0);
        const n = e.dot(this) / t;
        return this.copy(e).multiplyScalar(n)
    }
    projectOnPlane(e) {
        return Eu.copy(this).projectOnVector(e),
        this.sub(Eu)
    }
    reflect(e) {
        return this.sub(Eu.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const n = this.dot(e) / t;
        return Math.acos(Wt(n, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , n = this.y - e.y
          , i = this.z - e.z;
        return t * t + n * n + i * i
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, t, n) {
        const i = Math.sin(t) * e;
        return this.x = i * Math.sin(n),
        this.y = Math.cos(t) * e,
        this.z = i * Math.cos(n),
        this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, t, n) {
        return this.x = e * Math.sin(t),
        this.y = n,
        this.z = e * Math.cos(t),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this
    }
    setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length()
          , n = this.setFromMatrixColumn(e, 1).length()
          , i = this.setFromMatrixColumn(e, 2).length();
        return this.x = t,
        this.y = n,
        this.z = i,
        this
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4)
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3)
    }
    setFromEuler(e) {
        return this.x = e._x,
        this.y = e._y,
        this.z = e._z,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this
    }
    randomDirection() {
        const e = (Math.random() - .5) * 2
          , t = Math.random() * Math.PI * 2
          , n = Math.sqrt(1 - e ** 2);
        return this.x = n * Math.cos(t),
        this.y = n * Math.sin(t),
        this.z = e,
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
const Eu = new X
  , xd = new os;
class ao {
    constructor(e=new X(1 / 0,1 / 0,1 / 0), t=new X(-1 / 0,-1 / 0,-1 / 0)) {
        this.isBox3 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromArray(e) {
        let t = 1 / 0
          , n = 1 / 0
          , i = 1 / 0
          , r = -1 / 0
          , s = -1 / 0
          , a = -1 / 0;
        for (let l = 0, u = e.length; l < u; l += 3) {
            const c = e[l]
              , h = e[l + 1]
              , f = e[l + 2];
            c < t && (t = c),
            h < n && (n = h),
            f < i && (i = f),
            c > r && (r = c),
            h > s && (s = h),
            f > a && (a = f)
        }
        return this.min.set(t, n, i),
        this.max.set(r, s, a),
        this
    }
    setFromBufferAttribute(e) {
        let t = 1 / 0
          , n = 1 / 0
          , i = 1 / 0
          , r = -1 / 0
          , s = -1 / 0
          , a = -1 / 0;
        for (let l = 0, u = e.count; l < u; l++) {
            const c = e.getX(l)
              , h = e.getY(l)
              , f = e.getZ(l);
            c < t && (t = c),
            h < n && (n = h),
            f < i && (i = f),
            c > r && (r = c),
            h > s && (s = h),
            f > a && (a = f)
        }
        return this.min.set(t, n, i),
        this.max.set(r, s, a),
        this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const n = Mr.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(n),
        this.max.copy(e).add(n),
        this
    }
    setFromObject(e, t=!1) {
        return this.makeEmpty(),
        this.expandByObject(e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0,
        this.max.x = this.max.y = this.max.z = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    expandByObject(e, t=!1) {
        e.updateWorldMatrix(!1, !1);
        const n = e.geometry;
        if (n !== void 0)
            if (t && n.attributes != null && n.attributes.position !== void 0) {
                const r = n.attributes.position;
                for (let s = 0, a = r.count; s < a; s++)
                    Mr.fromBufferAttribute(r, s).applyMatrix4(e.matrixWorld),
                    this.expandByPoint(Mr)
            } else
                n.boundingBox === null && n.computeBoundingBox(),
                Au.copy(n.boundingBox),
                Au.applyMatrix4(e.matrixWorld),
                this.union(Au);
        const i = e.children;
        for (let r = 0, s = i.length; r < s; r++)
            this.expandByObject(i[r], t);
        return this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, Mr),
        Mr.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let t, n;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
        n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
        n = e.normal.x * this.min.x),
        e.normal.y > 0 ? (t += e.normal.y * this.min.y,
        n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
        n += e.normal.y * this.min.y),
        e.normal.z > 0 ? (t += e.normal.z * this.min.z,
        n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
        n += e.normal.z * this.min.z),
        t <= -e.constant && n >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty())
            return !1;
        this.getCenter(xo),
        za.subVectors(this.max, xo),
        ms.subVectors(e.a, xo),
        gs.subVectors(e.b, xo),
        _s.subVectors(e.c, xo),
        Xi.subVectors(gs, ms),
        Yi.subVectors(_s, gs),
        Sr.subVectors(ms, _s);
        let t = [0, -Xi.z, Xi.y, 0, -Yi.z, Yi.y, 0, -Sr.z, Sr.y, Xi.z, 0, -Xi.x, Yi.z, 0, -Yi.x, Sr.z, 0, -Sr.x, -Xi.y, Xi.x, 0, -Yi.y, Yi.x, 0, -Sr.y, Sr.x, 0];
        return !Cu(t, ms, gs, _s, za) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !Cu(t, ms, gs, _s, za)) ? !1 : (Ua.crossVectors(Xi, Yi),
        t = [Ua.x, Ua.y, Ua.z],
        Cu(t, ms, gs, _s, za))
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return Mr.copy(e).clamp(this.min, this.max).sub(e).length()
    }
    getBoundingSphere(e) {
        return this.getCenter(e.center),
        e.radius = this.getSize(Mr).length() * .5,
        e
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (_i[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        _i[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        _i[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        _i[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        _i[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        _i[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        _i[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        _i[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(_i),
        this)
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const _i = [new X, new X, new X, new X, new X, new X, new X, new X]
  , Mr = new X
  , Au = new ao
  , ms = new X
  , gs = new X
  , _s = new X
  , Xi = new X
  , Yi = new X
  , Sr = new X
  , xo = new X
  , za = new X
  , Ua = new X
  , Dr = new X;
function Cu(o, e, t, n, i) {
    for (let r = 0, s = o.length - 3; r <= s; r += 3) {
        Dr.fromArray(o, r);
        const a = i.x * Math.abs(Dr.x) + i.y * Math.abs(Dr.y) + i.z * Math.abs(Dr.z)
          , l = e.dot(Dr)
          , u = t.dot(Dr)
          , c = n.dot(Dr);
        if (Math.max(-Math.max(l, u, c), Math.min(l, u, c)) > a)
            return !1
    }
    return !0
}
const Db = new ao
  , yd = new X
  , Ba = new X
  , Lu = new X;
class lo {
    constructor(e=new X, t=-1) {
        this.center = e,
        this.radius = t
    }
    set(e, t) {
        return this.center.copy(e),
        this.radius = t,
        this
    }
    setFromPoints(e, t) {
        const n = this.center;
        t !== void 0 ? n.copy(t) : Db.setFromPoints(e).getCenter(n);
        let i = 0;
        for (let r = 0, s = e.length; r < s; r++)
            i = Math.max(i, n.distanceToSquared(e[r]));
        return this.radius = Math.sqrt(i),
        this
    }
    copy(e) {
        return this.center.copy(e.center),
        this.radius = e.radius,
        this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0),
        this.radius = -1,
        this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, t) {
        const n = this.center.distanceToSquared(e);
        return t.copy(e),
        n > this.radius * this.radius && (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
        t
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(),
        e) : (e.set(this.center, this.center),
        e.expandByScalar(this.radius),
        e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e),
        this.radius = this.radius * e.getMaxScaleOnAxis(),
        this
    }
    translate(e) {
        return this.center.add(e),
        this
    }
    expandByPoint(e) {
        Lu.subVectors(e, this.center);
        const t = Lu.lengthSq();
        if (t > this.radius * this.radius) {
            const n = Math.sqrt(t)
              , i = (n - this.radius) * .5;
            this.center.add(Lu.multiplyScalar(i / n)),
            this.radius += i
        }
        return this
    }
    union(e) {
        return this.center.equals(e.center) === !0 ? Ba.set(0, 0, 1).multiplyScalar(e.radius) : Ba.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius),
        this.expandByPoint(yd.copy(e.center).add(Ba)),
        this.expandByPoint(yd.copy(e.center).sub(Ba)),
        this
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const vi = new X
  , Ru = new X
  , Va = new X
  , Ki = new X
  , Pu = new X
  , Ga = new X
  , Iu = new X;
class ph {
    constructor(e=new X, t=new X(0,0,-1)) {
        this.origin = e,
        this.direction = t
    }
    set(e, t) {
        return this.origin.copy(e),
        this.direction.copy(t),
        this
    }
    copy(e) {
        return this.origin.copy(e.origin),
        this.direction.copy(e.direction),
        this
    }
    at(e, t) {
        return t.copy(this.direction).multiplyScalar(e).add(this.origin)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(),
        this
    }
    recast(e) {
        return this.origin.copy(this.at(e, vi)),
        this
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const n = t.dot(this.direction);
        return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const t = vi.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (vi.copy(this.direction).multiplyScalar(t).add(this.origin),
        vi.distanceToSquared(e))
    }
    distanceSqToSegment(e, t, n, i) {
        Ru.copy(e).add(t).multiplyScalar(.5),
        Va.copy(t).sub(e).normalize(),
        Ki.copy(this.origin).sub(Ru);
        const r = e.distanceTo(t) * .5
          , s = -this.direction.dot(Va)
          , a = Ki.dot(this.direction)
          , l = -Ki.dot(Va)
          , u = Ki.lengthSq()
          , c = Math.abs(1 - s * s);
        let h, f, m, _;
        if (c > 0)
            if (h = s * l - a,
            f = s * a - l,
            _ = r * c,
            h >= 0)
                if (f >= -_)
                    if (f <= _) {
                        const d = 1 / c;
                        h *= d,
                        f *= d,
                        m = h * (h + s * f + 2 * a) + f * (s * h + f + 2 * l) + u
                    } else
                        f = r,
                        h = Math.max(0, -(s * f + a)),
                        m = -h * h + f * (f + 2 * l) + u;
                else
                    f = -r,
                    h = Math.max(0, -(s * f + a)),
                    m = -h * h + f * (f + 2 * l) + u;
            else
                f <= -_ ? (h = Math.max(0, -(-s * r + a)),
                f = h > 0 ? -r : Math.min(Math.max(-r, -l), r),
                m = -h * h + f * (f + 2 * l) + u) : f <= _ ? (h = 0,
                f = Math.min(Math.max(-r, -l), r),
                m = f * (f + 2 * l) + u) : (h = Math.max(0, -(s * r + a)),
                f = h > 0 ? r : Math.min(Math.max(-r, -l), r),
                m = -h * h + f * (f + 2 * l) + u);
        else
            f = s > 0 ? -r : r,
            h = Math.max(0, -(s * f + a)),
            m = -h * h + f * (f + 2 * l) + u;
        return n && n.copy(this.direction).multiplyScalar(h).add(this.origin),
        i && i.copy(Va).multiplyScalar(f).add(Ru),
        m
    }
    intersectSphere(e, t) {
        vi.subVectors(e.center, this.origin);
        const n = vi.dot(this.direction)
          , i = vi.dot(vi) - n * n
          , r = e.radius * e.radius;
        if (i > r)
            return null;
        const s = Math.sqrt(r - i)
          , a = n - s
          , l = n + s;
        return a < 0 && l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t)
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (t === 0)
            return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const n = -(this.origin.dot(e.normal) + e.constant) / t;
        return n >= 0 ? n : null
    }
    intersectPlane(e, t) {
        const n = this.distanceToPlane(e);
        return n === null ? null : this.at(n, t)
    }
    intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0
    }
    intersectBox(e, t) {
        let n, i, r, s, a, l;
        const u = 1 / this.direction.x
          , c = 1 / this.direction.y
          , h = 1 / this.direction.z
          , f = this.origin;
        return u >= 0 ? (n = (e.min.x - f.x) * u,
        i = (e.max.x - f.x) * u) : (n = (e.max.x - f.x) * u,
        i = (e.min.x - f.x) * u),
        c >= 0 ? (r = (e.min.y - f.y) * c,
        s = (e.max.y - f.y) * c) : (r = (e.max.y - f.y) * c,
        s = (e.min.y - f.y) * c),
        n > s || r > i || ((r > n || n !== n) && (n = r),
        (s < i || i !== i) && (i = s),
        h >= 0 ? (a = (e.min.z - f.z) * h,
        l = (e.max.z - f.z) * h) : (a = (e.max.z - f.z) * h,
        l = (e.min.z - f.z) * h),
        n > l || a > i) || ((a > n || n !== n) && (n = a),
        (l < i || i !== i) && (i = l),
        i < 0) ? null : this.at(n >= 0 ? n : i, t)
    }
    intersectsBox(e) {
        return this.intersectBox(e, vi) !== null
    }
    intersectTriangle(e, t, n, i, r) {
        Pu.subVectors(t, e),
        Ga.subVectors(n, e),
        Iu.crossVectors(Pu, Ga);
        let s = this.direction.dot(Iu), a;
        if (s > 0) {
            if (i)
                return null;
            a = 1
        } else if (s < 0)
            a = -1,
            s = -s;
        else
            return null;
        Ki.subVectors(this.origin, e);
        const l = a * this.direction.dot(Ga.crossVectors(Ki, Ga));
        if (l < 0)
            return null;
        const u = a * this.direction.dot(Pu.cross(Ki));
        if (u < 0 || l + u > s)
            return null;
        const c = -a * Ki.dot(Iu);
        return c < 0 ? null : this.at(c / s, r)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e),
        this.direction.transformDirection(e),
        this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class Ke {
    constructor() {
        Ke.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
    }
    set(e, t, n, i, r, s, a, l, u, c, h, f, m, _, d, p) {
        const v = this.elements;
        return v[0] = e,
        v[4] = t,
        v[8] = n,
        v[12] = i,
        v[1] = r,
        v[5] = s,
        v[9] = a,
        v[13] = l,
        v[2] = u,
        v[6] = c,
        v[10] = h,
        v[14] = f,
        v[3] = m,
        v[7] = _,
        v[11] = d,
        v[15] = p,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    clone() {
        return new Ke().fromArray(this.elements)
    }
    copy(e) {
        const t = this.elements
          , n = e.elements;
        return t[0] = n[0],
        t[1] = n[1],
        t[2] = n[2],
        t[3] = n[3],
        t[4] = n[4],
        t[5] = n[5],
        t[6] = n[6],
        t[7] = n[7],
        t[8] = n[8],
        t[9] = n[9],
        t[10] = n[10],
        t[11] = n[11],
        t[12] = n[12],
        t[13] = n[13],
        t[14] = n[14],
        t[15] = n[15],
        this
    }
    copyPosition(e) {
        const t = this.elements
          , n = e.elements;
        return t[12] = n[12],
        t[13] = n[13],
        t[14] = n[14],
        this
    }
    setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
        this
    }
    extractBasis(e, t, n) {
        return e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        n.setFromMatrixColumn(this, 2),
        this
    }
    makeBasis(e, t, n) {
        return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1),
        this
    }
    extractRotation(e) {
        const t = this.elements
          , n = e.elements
          , i = 1 / vs.setFromMatrixColumn(e, 0).length()
          , r = 1 / vs.setFromMatrixColumn(e, 1).length()
          , s = 1 / vs.setFromMatrixColumn(e, 2).length();
        return t[0] = n[0] * i,
        t[1] = n[1] * i,
        t[2] = n[2] * i,
        t[3] = 0,
        t[4] = n[4] * r,
        t[5] = n[5] * r,
        t[6] = n[6] * r,
        t[7] = 0,
        t[8] = n[8] * s,
        t[9] = n[9] * s,
        t[10] = n[10] * s,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromEuler(e) {
        const t = this.elements
          , n = e.x
          , i = e.y
          , r = e.z
          , s = Math.cos(n)
          , a = Math.sin(n)
          , l = Math.cos(i)
          , u = Math.sin(i)
          , c = Math.cos(r)
          , h = Math.sin(r);
        if (e.order === "XYZ") {
            const f = s * c
              , m = s * h
              , _ = a * c
              , d = a * h;
            t[0] = l * c,
            t[4] = -l * h,
            t[8] = u,
            t[1] = m + _ * u,
            t[5] = f - d * u,
            t[9] = -a * l,
            t[2] = d - f * u,
            t[6] = _ + m * u,
            t[10] = s * l
        } else if (e.order === "YXZ") {
            const f = l * c
              , m = l * h
              , _ = u * c
              , d = u * h;
            t[0] = f + d * a,
            t[4] = _ * a - m,
            t[8] = s * u,
            t[1] = s * h,
            t[5] = s * c,
            t[9] = -a,
            t[2] = m * a - _,
            t[6] = d + f * a,
            t[10] = s * l
        } else if (e.order === "ZXY") {
            const f = l * c
              , m = l * h
              , _ = u * c
              , d = u * h;
            t[0] = f - d * a,
            t[4] = -s * h,
            t[8] = _ + m * a,
            t[1] = m + _ * a,
            t[5] = s * c,
            t[9] = d - f * a,
            t[2] = -s * u,
            t[6] = a,
            t[10] = s * l
        } else if (e.order === "ZYX") {
            const f = s * c
              , m = s * h
              , _ = a * c
              , d = a * h;
            t[0] = l * c,
            t[4] = _ * u - m,
            t[8] = f * u + d,
            t[1] = l * h,
            t[5] = d * u + f,
            t[9] = m * u - _,
            t[2] = -u,
            t[6] = a * l,
            t[10] = s * l
        } else if (e.order === "YZX") {
            const f = s * l
              , m = s * u
              , _ = a * l
              , d = a * u;
            t[0] = l * c,
            t[4] = d - f * h,
            t[8] = _ * h + m,
            t[1] = h,
            t[5] = s * c,
            t[9] = -a * c,
            t[2] = -u * c,
            t[6] = m * h + _,
            t[10] = f - d * h
        } else if (e.order === "XZY") {
            const f = s * l
              , m = s * u
              , _ = a * l
              , d = a * u;
            t[0] = l * c,
            t[4] = -h,
            t[8] = u * c,
            t[1] = f * h + d,
            t[5] = s * c,
            t[9] = m * h - _,
            t[2] = _ * h - m,
            t[6] = a * c,
            t[10] = d * h + f
        }
        return t[3] = 0,
        t[7] = 0,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(Tb, e, Eb)
    }
    lookAt(e, t, n) {
        const i = this.elements;
        return vn.subVectors(e, t),
        vn.lengthSq() === 0 && (vn.z = 1),
        vn.normalize(),
        $i.crossVectors(n, vn),
        $i.lengthSq() === 0 && (Math.abs(n.z) === 1 ? vn.x += 1e-4 : vn.z += 1e-4,
        vn.normalize(),
        $i.crossVectors(n, vn)),
        $i.normalize(),
        Ha.crossVectors(vn, $i),
        i[0] = $i.x,
        i[4] = Ha.x,
        i[8] = vn.x,
        i[1] = $i.y,
        i[5] = Ha.y,
        i[9] = vn.y,
        i[2] = $i.z,
        i[6] = Ha.z,
        i[10] = vn.z,
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const n = e.elements
          , i = t.elements
          , r = this.elements
          , s = n[0]
          , a = n[4]
          , l = n[8]
          , u = n[12]
          , c = n[1]
          , h = n[5]
          , f = n[9]
          , m = n[13]
          , _ = n[2]
          , d = n[6]
          , p = n[10]
          , v = n[14]
          , x = n[3]
          , S = n[7]
          , M = n[11]
          , T = n[15]
          , L = i[0]
          , P = i[4]
          , A = i[8]
          , C = i[12]
          , N = i[1]
          , G = i[5]
          , q = i[9]
          , g = i[13]
          , w = i[2]
          , E = i[6]
          , R = i[10]
          , z = i[14]
          , b = i[3]
          , y = i[7]
          , D = i[11]
          , I = i[15];
        return r[0] = s * L + a * N + l * w + u * b,
        r[4] = s * P + a * G + l * E + u * y,
        r[8] = s * A + a * q + l * R + u * D,
        r[12] = s * C + a * g + l * z + u * I,
        r[1] = c * L + h * N + f * w + m * b,
        r[5] = c * P + h * G + f * E + m * y,
        r[9] = c * A + h * q + f * R + m * D,
        r[13] = c * C + h * g + f * z + m * I,
        r[2] = _ * L + d * N + p * w + v * b,
        r[6] = _ * P + d * G + p * E + v * y,
        r[10] = _ * A + d * q + p * R + v * D,
        r[14] = _ * C + d * g + p * z + v * I,
        r[3] = x * L + S * N + M * w + T * b,
        r[7] = x * P + S * G + M * E + T * y,
        r[11] = x * A + S * q + M * R + T * D,
        r[15] = x * C + S * g + M * z + T * I,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[4] *= e,
        t[8] *= e,
        t[12] *= e,
        t[1] *= e,
        t[5] *= e,
        t[9] *= e,
        t[13] *= e,
        t[2] *= e,
        t[6] *= e,
        t[10] *= e,
        t[14] *= e,
        t[3] *= e,
        t[7] *= e,
        t[11] *= e,
        t[15] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , n = e[4]
          , i = e[8]
          , r = e[12]
          , s = e[1]
          , a = e[5]
          , l = e[9]
          , u = e[13]
          , c = e[2]
          , h = e[6]
          , f = e[10]
          , m = e[14]
          , _ = e[3]
          , d = e[7]
          , p = e[11]
          , v = e[15];
        return _ * (+r * l * h - i * u * h - r * a * f + n * u * f + i * a * m - n * l * m) + d * (+t * l * m - t * u * f + r * s * f - i * s * m + i * u * c - r * l * c) + p * (+t * u * h - t * a * m - r * s * h + n * s * m + r * a * c - n * u * c) + v * (-i * a * c - t * l * h + t * a * f + i * s * h - n * s * f + n * l * c)
    }
    transpose() {
        const e = this.elements;
        let t;
        return t = e[1],
        e[1] = e[4],
        e[4] = t,
        t = e[2],
        e[2] = e[8],
        e[8] = t,
        t = e[6],
        e[6] = e[9],
        e[9] = t,
        t = e[3],
        e[3] = e[12],
        e[12] = t,
        t = e[7],
        e[7] = e[13],
        e[13] = t,
        t = e[11],
        e[11] = e[14],
        e[14] = t,
        this
    }
    setPosition(e, t, n) {
        const i = this.elements;
        return e.isVector3 ? (i[12] = e.x,
        i[13] = e.y,
        i[14] = e.z) : (i[12] = e,
        i[13] = t,
        i[14] = n),
        this
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , n = e[1]
          , i = e[2]
          , r = e[3]
          , s = e[4]
          , a = e[5]
          , l = e[6]
          , u = e[7]
          , c = e[8]
          , h = e[9]
          , f = e[10]
          , m = e[11]
          , _ = e[12]
          , d = e[13]
          , p = e[14]
          , v = e[15]
          , x = h * p * u - d * f * u + d * l * m - a * p * m - h * l * v + a * f * v
          , S = _ * f * u - c * p * u - _ * l * m + s * p * m + c * l * v - s * f * v
          , M = c * d * u - _ * h * u + _ * a * m - s * d * m - c * a * v + s * h * v
          , T = _ * h * l - c * d * l - _ * a * f + s * d * f + c * a * p - s * h * p
          , L = t * x + n * S + i * M + r * T;
        if (L === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const P = 1 / L;
        return e[0] = x * P,
        e[1] = (d * f * r - h * p * r - d * i * m + n * p * m + h * i * v - n * f * v) * P,
        e[2] = (a * p * r - d * l * r + d * i * u - n * p * u - a * i * v + n * l * v) * P,
        e[3] = (h * l * r - a * f * r - h * i * u + n * f * u + a * i * m - n * l * m) * P,
        e[4] = S * P,
        e[5] = (c * p * r - _ * f * r + _ * i * m - t * p * m - c * i * v + t * f * v) * P,
        e[6] = (_ * l * r - s * p * r - _ * i * u + t * p * u + s * i * v - t * l * v) * P,
        e[7] = (s * f * r - c * l * r + c * i * u - t * f * u - s * i * m + t * l * m) * P,
        e[8] = M * P,
        e[9] = (_ * h * r - c * d * r - _ * n * m + t * d * m + c * n * v - t * h * v) * P,
        e[10] = (s * d * r - _ * a * r + _ * n * u - t * d * u - s * n * v + t * a * v) * P,
        e[11] = (c * a * r - s * h * r - c * n * u + t * h * u + s * n * m - t * a * m) * P,
        e[12] = T * P,
        e[13] = (c * d * i - _ * h * i + _ * n * f - t * d * f - c * n * p + t * h * p) * P,
        e[14] = (_ * a * i - s * d * i - _ * n * l + t * d * l + s * n * p - t * a * p) * P,
        e[15] = (s * h * i - c * a * i + c * n * l - t * h * l - s * n * f + t * a * f) * P,
        this
    }
    scale(e) {
        const t = this.elements
          , n = e.x
          , i = e.y
          , r = e.z;
        return t[0] *= n,
        t[4] *= i,
        t[8] *= r,
        t[1] *= n,
        t[5] *= i,
        t[9] *= r,
        t[2] *= n,
        t[6] *= i,
        t[10] *= r,
        t[3] *= n,
        t[7] *= i,
        t[11] *= r,
        this
    }
    getMaxScaleOnAxis() {
        const e = this.elements
          , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
          , n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
          , i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, n, i))
    }
    makeTranslation(e, t, n) {
        return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
        this
    }
    makeRotationX(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationY(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationZ(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    makeRotationAxis(e, t) {
        const n = Math.cos(t)
          , i = Math.sin(t)
          , r = 1 - n
          , s = e.x
          , a = e.y
          , l = e.z
          , u = r * s
          , c = r * a;
        return this.set(u * s + n, u * a - i * l, u * l + i * a, 0, u * a + i * l, c * a + n, c * l - i * s, 0, u * l - i * a, c * l + i * s, r * l * l + n, 0, 0, 0, 0, 1),
        this
    }
    makeScale(e, t, n) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
        this
    }
    makeShear(e, t, n, i, r, s) {
        return this.set(1, n, r, 0, e, 1, s, 0, t, i, 1, 0, 0, 0, 0, 1),
        this
    }
    compose(e, t, n) {
        const i = this.elements
          , r = t._x
          , s = t._y
          , a = t._z
          , l = t._w
          , u = r + r
          , c = s + s
          , h = a + a
          , f = r * u
          , m = r * c
          , _ = r * h
          , d = s * c
          , p = s * h
          , v = a * h
          , x = l * u
          , S = l * c
          , M = l * h
          , T = n.x
          , L = n.y
          , P = n.z;
        return i[0] = (1 - (d + v)) * T,
        i[1] = (m + M) * T,
        i[2] = (_ - S) * T,
        i[3] = 0,
        i[4] = (m - M) * L,
        i[5] = (1 - (f + v)) * L,
        i[6] = (p + x) * L,
        i[7] = 0,
        i[8] = (_ + S) * P,
        i[9] = (p - x) * P,
        i[10] = (1 - (f + d)) * P,
        i[11] = 0,
        i[12] = e.x,
        i[13] = e.y,
        i[14] = e.z,
        i[15] = 1,
        this
    }
    decompose(e, t, n) {
        const i = this.elements;
        let r = vs.set(i[0], i[1], i[2]).length();
        const s = vs.set(i[4], i[5], i[6]).length()
          , a = vs.set(i[8], i[9], i[10]).length();
        this.determinant() < 0 && (r = -r),
        e.x = i[12],
        e.y = i[13],
        e.z = i[14],
        Kn.copy(this);
        const u = 1 / r
          , c = 1 / s
          , h = 1 / a;
        return Kn.elements[0] *= u,
        Kn.elements[1] *= u,
        Kn.elements[2] *= u,
        Kn.elements[4] *= c,
        Kn.elements[5] *= c,
        Kn.elements[6] *= c,
        Kn.elements[8] *= h,
        Kn.elements[9] *= h,
        Kn.elements[10] *= h,
        t.setFromRotationMatrix(Kn),
        n.x = r,
        n.y = s,
        n.z = a,
        this
    }
    makePerspective(e, t, n, i, r, s) {
        const a = this.elements
          , l = 2 * r / (t - e)
          , u = 2 * r / (n - i)
          , c = (t + e) / (t - e)
          , h = (n + i) / (n - i)
          , f = -(s + r) / (s - r)
          , m = -2 * s * r / (s - r);
        return a[0] = l,
        a[4] = 0,
        a[8] = c,
        a[12] = 0,
        a[1] = 0,
        a[5] = u,
        a[9] = h,
        a[13] = 0,
        a[2] = 0,
        a[6] = 0,
        a[10] = f,
        a[14] = m,
        a[3] = 0,
        a[7] = 0,
        a[11] = -1,
        a[15] = 0,
        this
    }
    makeOrthographic(e, t, n, i, r, s) {
        const a = this.elements
          , l = 1 / (t - e)
          , u = 1 / (n - i)
          , c = 1 / (s - r)
          , h = (t + e) * l
          , f = (n + i) * u
          , m = (s + r) * c;
        return a[0] = 2 * l,
        a[4] = 0,
        a[8] = 0,
        a[12] = -h,
        a[1] = 0,
        a[5] = 2 * u,
        a[9] = 0,
        a[13] = -f,
        a[2] = 0,
        a[6] = 0,
        a[10] = -2 * c,
        a[14] = -m,
        a[3] = 0,
        a[7] = 0,
        a[11] = 0,
        a[15] = 1,
        this
    }
    equals(e) {
        const t = this.elements
          , n = e.elements;
        for (let i = 0; i < 16; i++)
            if (t[i] !== n[i])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let n = 0; n < 16; n++)
            this.elements[n] = e[n + t];
        return this
    }
    toArray(e=[], t=0) {
        const n = this.elements;
        return e[t] = n[0],
        e[t + 1] = n[1],
        e[t + 2] = n[2],
        e[t + 3] = n[3],
        e[t + 4] = n[4],
        e[t + 5] = n[5],
        e[t + 6] = n[6],
        e[t + 7] = n[7],
        e[t + 8] = n[8],
        e[t + 9] = n[9],
        e[t + 10] = n[10],
        e[t + 11] = n[11],
        e[t + 12] = n[12],
        e[t + 13] = n[13],
        e[t + 14] = n[14],
        e[t + 15] = n[15],
        e
    }
}
const vs = new X
  , Kn = new Ke
  , Tb = new X(0,0,0)
  , Eb = new X(1,1,1)
  , $i = new X
  , Ha = new X
  , vn = new X
  , bd = new Ke
  , wd = new os;
class ma {
    constructor(e=0, t=0, n=0, i=ma.DefaultOrder) {
        this.isEuler = !0,
        this._x = e,
        this._y = t,
        this._z = n,
        this._order = i
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e,
        this._onChangeCallback()
    }
    set(e, t, n, i=this._order) {
        return this._x = e,
        this._y = t,
        this._z = n,
        this._order = i,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._order)
    }
    copy(e) {
        return this._x = e._x,
        this._y = e._y,
        this._z = e._z,
        this._order = e._order,
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e, t=this._order, n=!0) {
        const i = e.elements
          , r = i[0]
          , s = i[4]
          , a = i[8]
          , l = i[1]
          , u = i[5]
          , c = i[9]
          , h = i[2]
          , f = i[6]
          , m = i[10];
        switch (t) {
        case "XYZ":
            this._y = Math.asin(Wt(a, -1, 1)),
            Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, m),
            this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(f, u),
            this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-Wt(c, -1, 1)),
            Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, m),
            this._z = Math.atan2(l, u)) : (this._y = Math.atan2(-h, r),
            this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(Wt(f, -1, 1)),
            Math.abs(f) < .9999999 ? (this._y = Math.atan2(-h, m),
            this._z = Math.atan2(-s, u)) : (this._y = 0,
            this._z = Math.atan2(l, r));
            break;
        case "ZYX":
            this._y = Math.asin(-Wt(h, -1, 1)),
            Math.abs(h) < .9999999 ? (this._x = Math.atan2(f, m),
            this._z = Math.atan2(l, r)) : (this._x = 0,
            this._z = Math.atan2(-s, u));
            break;
        case "YZX":
            this._z = Math.asin(Wt(l, -1, 1)),
            Math.abs(l) < .9999999 ? (this._x = Math.atan2(-c, u),
            this._y = Math.atan2(-h, r)) : (this._x = 0,
            this._y = Math.atan2(a, m));
            break;
        case "XZY":
            this._z = Math.asin(-Wt(s, -1, 1)),
            Math.abs(s) < .9999999 ? (this._x = Math.atan2(f, u),
            this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-c, m),
            this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
        }
        return this._order = t,
        n === !0 && this._onChangeCallback(),
        this
    }
    setFromQuaternion(e, t, n) {
        return bd.makeRotationFromQuaternion(e),
        this.setFromRotationMatrix(bd, t, n)
    }
    setFromVector3(e, t=this._order) {
        return this.set(e.x, e.y, e.z, t)
    }
    reorder(e) {
        return wd.setFromEuler(this),
        this.setFromQuaternion(wd, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0],
        this._y = e[1],
        this._z = e[2],
        e[3] !== void 0 && (this._order = e[3]),
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._order,
        e
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._order
    }
    toVector3() {
        console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")
    }
}
ma.DefaultOrder = "XYZ";
ma.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
class $g {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) !== 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0
    }
}
let Ab = 0;
const Md = new X
  , xs = new os
  , xi = new Ke
  , Wa = new X
  , yo = new X
  , Cb = new X
  , Lb = new os
  , Sd = new X(1,0,0)
  , Dd = new X(0,1,0)
  , Td = new X(0,0,1)
  , Rb = {
    type: "added"
}
  , Ed = {
    type: "removed"
};
class yt extends oo {
    constructor() {
        super(),
        this.isObject3D = !0,
        Object.defineProperty(this, "id", {
            value: Ab++
        }),
        this.uuid = ti(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = yt.DefaultUp.clone();
        const e = new X
          , t = new ma
          , n = new os
          , i = new X(1,1,1);
        function r() {
            n.setFromEuler(t, !1)
        }
        function s() {
            t.setFromQuaternion(n, void 0, !1)
        }
        t._onChange(r),
        n._onChange(s),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            modelViewMatrix: {
                value: new Ke
            },
            normalMatrix: {
                value: new Bn
            }
        }),
        this.matrix = new Ke,
        this.matrixWorld = new Ke,
        this.matrixAutoUpdate = yt.DefaultMatrixAutoUpdate,
        this.matrixWorldNeedsUpdate = !1,
        this.matrixWorldAutoUpdate = yt.DefaultMatrixWorldAutoUpdate,
        this.layers = new $g,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.userData = {}
    }
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e),
        this
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, t) {
        return xs.setFromAxisAngle(e, t),
        this.quaternion.multiply(xs),
        this
    }
    rotateOnWorldAxis(e, t) {
        return xs.setFromAxisAngle(e, t),
        this.quaternion.premultiply(xs),
        this
    }
    rotateX(e) {
        return this.rotateOnAxis(Sd, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(Dd, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(Td, e)
    }
    translateOnAxis(e, t) {
        return Md.copy(e).applyQuaternion(this.quaternion),
        this.position.add(Md.multiplyScalar(t)),
        this
    }
    translateX(e) {
        return this.translateOnAxis(Sd, e)
    }
    translateY(e) {
        return this.translateOnAxis(Dd, e)
    }
    translateZ(e) {
        return this.translateOnAxis(Td, e)
    }
    localToWorld(e) {
        return e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return e.applyMatrix4(xi.copy(this.matrixWorld).invert())
    }
    lookAt(e, t, n) {
        e.isVector3 ? Wa.copy(e) : Wa.set(e, t, n);
        const i = this.parent;
        this.updateWorldMatrix(!0, !1),
        yo.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? xi.lookAt(yo, Wa, this.up) : xi.lookAt(Wa, yo, this.up),
        this.quaternion.setFromRotationMatrix(xi),
        i && (xi.extractRotation(i.matrixWorld),
        xs.setFromRotationMatrix(xi),
        this.quaternion.premultiply(xs.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
                this.add(arguments[t]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
        this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e),
        e.parent = this,
        this.children.push(e),
        e.dispatchEvent(Rb)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
        this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let n = 0; n < arguments.length; n++)
                this.remove(arguments[n]);
            return this
        }
        const t = this.children.indexOf(e);
        return t !== -1 && (e.parent = null,
        this.children.splice(t, 1),
        e.dispatchEvent(Ed)),
        this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this),
        this
    }
    clear() {
        for (let e = 0; e < this.children.length; e++) {
            const t = this.children[e];
            t.parent = null,
            t.dispatchEvent(Ed)
        }
        return this.children.length = 0,
        this
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1),
        xi.copy(this.matrixWorld).invert(),
        e.parent !== null && (e.parent.updateWorldMatrix(!0, !1),
        xi.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(xi),
        this.add(e),
        e.updateWorldMatrix(!1, !0),
        this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, t) {
        if (this[e] === t)
            return this;
        for (let n = 0, i = this.children.length; n < i; n++) {
            const s = this.children[n].getObjectByProperty(e, t);
            if (s !== void 0)
                return s
        }
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(yo, e, Cb),
        e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(yo, Lb, e),
        e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++)
            t[n].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1)
            return;
        e(this);
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++)
            t[n].traverseVisible(e)
    }
    traverseAncestors(e) {
        const t = this.parent;
        t !== null && (e(t),
        t.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        this.matrixWorldNeedsUpdate = !1,
        e = !0);
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++) {
            const r = t[n];
            (r.matrixWorldAutoUpdate === !0 || e === !0) && r.updateMatrixWorld(e)
        }
    }
    updateWorldMatrix(e, t) {
        const n = this.parent;
        if (e === !0 && n !== null && n.matrixWorldAutoUpdate === !0 && n.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        t === !0) {
            const i = this.children;
            for (let r = 0, s = i.length; r < s; r++) {
                const a = i[r];
                a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0)
            }
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string"
          , n = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        },
        n.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const i = {};
        i.uuid = this.uuid,
        i.type = this.type,
        this.name !== "" && (i.name = this.name),
        this.castShadow === !0 && (i.castShadow = !0),
        this.receiveShadow === !0 && (i.receiveShadow = !0),
        this.visible === !1 && (i.visible = !1),
        this.frustumCulled === !1 && (i.frustumCulled = !1),
        this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
        JSON.stringify(this.userData) !== "{}" && (i.userData = this.userData),
        i.layers = this.layers.mask,
        i.matrix = this.matrix.toArray(),
        this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
        this.isInstancedMesh && (i.type = "InstancedMesh",
        i.count = this.count,
        i.instanceMatrix = this.instanceMatrix.toJSON(),
        this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON()));
        function r(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)),
            l.uuid
        }
        if (this.isScene)
            this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)),
            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            i.geometry = r(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
                const l = a.shapes;
                if (Array.isArray(l))
                    for (let u = 0, c = l.length; u < c; u++) {
                        const h = l[u];
                        r(e.shapes, h)
                    }
                else
                    r(e.shapes, l)
            }
        }
        if (this.isSkinnedMesh && (i.bindMode = this.bindMode,
        i.bindMatrix = this.bindMatrix.toArray(),
        this.skeleton !== void 0 && (r(e.skeletons, this.skeleton),
        i.skeleton = this.skeleton.uuid)),
        this.material !== void 0)
            if (Array.isArray(this.material)) {
                const a = [];
                for (let l = 0, u = this.material.length; l < u; l++)
                    a.push(r(e.materials, this.material[l]));
                i.material = a
            } else
                i.material = r(e.materials, this.material);
        if (this.children.length > 0) {
            i.children = [];
            for (let a = 0; a < this.children.length; a++)
                i.children.push(this.children[a].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            i.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
                const l = this.animations[a];
                i.animations.push(r(e.animations, l))
            }
        }
        if (t) {
            const a = s(e.geometries)
              , l = s(e.materials)
              , u = s(e.textures)
              , c = s(e.images)
              , h = s(e.shapes)
              , f = s(e.skeletons)
              , m = s(e.animations)
              , _ = s(e.nodes);
            a.length > 0 && (n.geometries = a),
            l.length > 0 && (n.materials = l),
            u.length > 0 && (n.textures = u),
            c.length > 0 && (n.images = c),
            h.length > 0 && (n.shapes = h),
            f.length > 0 && (n.skeletons = f),
            m.length > 0 && (n.animations = m),
            _.length > 0 && (n.nodes = _)
        }
        return n.object = i,
        n;
        function s(a) {
            const l = [];
            for (const u in a) {
                const c = a[u];
                delete c.metadata,
                l.push(c)
            }
            return l
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, t=!0) {
        if (this.name = e.name,
        this.up.copy(e.up),
        this.position.copy(e.position),
        this.rotation.order = e.rotation.order,
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
        this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
        this.layers.mask = e.layers.mask,
        this.visible = e.visible,
        this.castShadow = e.castShadow,
        this.receiveShadow = e.receiveShadow,
        this.frustumCulled = e.frustumCulled,
        this.renderOrder = e.renderOrder,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        t === !0)
            for (let n = 0; n < e.children.length; n++) {
                const i = e.children[n];
                this.add(i.clone())
            }
        return this
    }
}
yt.DefaultUp = new X(0,1,0);
yt.DefaultMatrixAutoUpdate = !0;
yt.DefaultMatrixWorldAutoUpdate = !0;
const $n = new X
  , yi = new X
  , Fu = new X
  , bi = new X
  , ys = new X
  , bs = new X
  , Ad = new X
  , Ou = new X
  , Nu = new X
  , ku = new X;
class Ci {
    constructor(e=new X, t=new X, n=new X) {
        this.a = e,
        this.b = t,
        this.c = n
    }
    static getNormal(e, t, n, i) {
        i.subVectors(n, t),
        $n.subVectors(e, t),
        i.cross($n);
        const r = i.lengthSq();
        return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
    }
    static getBarycoord(e, t, n, i, r) {
        $n.subVectors(i, t),
        yi.subVectors(n, t),
        Fu.subVectors(e, t);
        const s = $n.dot($n)
          , a = $n.dot(yi)
          , l = $n.dot(Fu)
          , u = yi.dot(yi)
          , c = yi.dot(Fu)
          , h = s * u - a * a;
        if (h === 0)
            return r.set(-2, -1, -1);
        const f = 1 / h
          , m = (u * l - a * c) * f
          , _ = (s * c - a * l) * f;
        return r.set(1 - m - _, _, m)
    }
    static containsPoint(e, t, n, i) {
        return this.getBarycoord(e, t, n, i, bi),
        bi.x >= 0 && bi.y >= 0 && bi.x + bi.y <= 1
    }
    static getUV(e, t, n, i, r, s, a, l) {
        return this.getBarycoord(e, t, n, i, bi),
        l.set(0, 0),
        l.addScaledVector(r, bi.x),
        l.addScaledVector(s, bi.y),
        l.addScaledVector(a, bi.z),
        l
    }
    static isFrontFacing(e, t, n, i) {
        return $n.subVectors(n, t),
        yi.subVectors(e, t),
        $n.cross(yi).dot(i) < 0
    }
    set(e, t, n) {
        return this.a.copy(e),
        this.b.copy(t),
        this.c.copy(n),
        this
    }
    setFromPointsAndIndices(e, t, n, i) {
        return this.a.copy(e[t]),
        this.b.copy(e[n]),
        this.c.copy(e[i]),
        this
    }
    setFromAttributeAndIndices(e, t, n, i) {
        return this.a.fromBufferAttribute(e, t),
        this.b.fromBufferAttribute(e, n),
        this.c.fromBufferAttribute(e, i),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a),
        this.b.copy(e.b),
        this.c.copy(e.c),
        this
    }
    getArea() {
        return $n.subVectors(this.c, this.b),
        yi.subVectors(this.a, this.b),
        $n.cross(yi).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return Ci.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, t) {
        return Ci.getBarycoord(e, this.a, this.b, this.c, t)
    }
    getUV(e, t, n, i, r) {
        return Ci.getUV(e, this.a, this.b, this.c, t, n, i, r)
    }
    containsPoint(e) {
        return Ci.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return Ci.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, t) {
        const n = this.a
          , i = this.b
          , r = this.c;
        let s, a;
        ys.subVectors(i, n),
        bs.subVectors(r, n),
        Ou.subVectors(e, n);
        const l = ys.dot(Ou)
          , u = bs.dot(Ou);
        if (l <= 0 && u <= 0)
            return t.copy(n);
        Nu.subVectors(e, i);
        const c = ys.dot(Nu)
          , h = bs.dot(Nu);
        if (c >= 0 && h <= c)
            return t.copy(i);
        const f = l * h - c * u;
        if (f <= 0 && l >= 0 && c <= 0)
            return s = l / (l - c),
            t.copy(n).addScaledVector(ys, s);
        ku.subVectors(e, r);
        const m = ys.dot(ku)
          , _ = bs.dot(ku);
        if (_ >= 0 && m <= _)
            return t.copy(r);
        const d = m * u - l * _;
        if (d <= 0 && u >= 0 && _ <= 0)
            return a = u / (u - _),
            t.copy(n).addScaledVector(bs, a);
        const p = c * _ - m * h;
        if (p <= 0 && h - c >= 0 && m - _ >= 0)
            return Ad.subVectors(r, i),
            a = (h - c) / (h - c + (m - _)),
            t.copy(i).addScaledVector(Ad, a);
        const v = 1 / (p + d + f);
        return s = d * v,
        a = f * v,
        t.copy(n).addScaledVector(ys, s).addScaledVector(bs, a)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
let Pb = 0;
class fi extends oo {
    constructor() {
        super(),
        this.isMaterial = !0,
        Object.defineProperty(this, "id", {
            value: Pb++
        }),
        this.uuid = ti(),
        this.name = "",
        this.type = "Material",
        this.blending = Gs,
        this.side = Jr,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.blendSrc = kg,
        this.blendDst = zg,
        this.blendEquation = Ls,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.depthFunc = Dc,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = lb,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = Mu,
        this.stencilZFail = Mu,
        this.stencilZPass = Mu,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++,
        this._alphaTest = e
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setPhilosophy(e) {
        if (e !== void 0)
            for (const t in e) {
                const n = e[t];
                if (n === void 0) {
                    console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                    continue
                }
                const i = this[t];
                if (i === void 0) {
                    console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.");
                    continue
                }
                i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n
            }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        t && (e = {
            textures: {},
            images: {}
        });
        const n = {
            metadata: {
                version: 4.5,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        n.uuid = this.uuid,
        n.type = this.type,
        this.name !== "" && (n.name = this.name),
        this.color && this.color.isColor && (n.color = this.color.getHex()),
        this.roughness !== void 0 && (n.roughness = this.roughness),
        this.metalness !== void 0 && (n.metalness = this.metalness),
        this.sheen !== void 0 && (n.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
        this.emissiveIntensity && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (n.shininess = this.shininess),
        this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
        n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        this.iridescence !== void 0 && (n.iridescence = this.iridescence),
        this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR),
        this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
        this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
        this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid,
        n.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid,
        n.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid,
        n.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid,
        n.normalMapType = this.normalMapType,
        n.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid,
        n.displacementScale = this.displacementScale,
        n.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid,
        this.combine !== void 0 && (n.combine = this.combine)),
        this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid),
        this.transmission !== void 0 && (n.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        this.thickness !== void 0 && (n.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        this.attenuationDistance !== void 0 && (n.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (n.size = this.size),
        this.shadowSide !== null && (n.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation),
        this.blending !== Gs && (n.blending = this.blending),
        this.side !== Jr && (n.side = this.side),
        this.vertexColors && (n.vertexColors = !0),
        this.opacity < 1 && (n.opacity = this.opacity),
        this.transparent === !0 && (n.transparent = this.transparent),
        n.depthFunc = this.depthFunc,
        n.depthTest = this.depthTest,
        n.depthWrite = this.depthWrite,
        n.colorWrite = this.colorWrite,
        n.stencilWrite = this.stencilWrite,
        n.stencilWriteMask = this.stencilWriteMask,
        n.stencilFunc = this.stencilFunc,
        n.stencilRef = this.stencilRef,
        n.stencilFuncMask = this.stencilFuncMask,
        n.stencilFail = this.stencilFail,
        n.stencilZFail = this.stencilZFail,
        n.stencilZPass = this.stencilZPass,
        this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation),
        this.polygonOffset === !0 && (n.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth),
        this.dashSize !== void 0 && (n.dashSize = this.dashSize),
        this.gapSize !== void 0 && (n.gapSize = this.gapSize),
        this.scale !== void 0 && (n.scale = this.scale),
        this.dithering === !0 && (n.dithering = !0),
        this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
        this.alphaToCoverage === !0 && (n.alphaToCoverage = this.alphaToCoverage),
        this.premultipliedAlpha === !0 && (n.premultipliedAlpha = this.premultipliedAlpha),
        this.wireframe === !0 && (n.wireframe = this.wireframe),
        this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (n.flatShading = this.flatShading),
        this.visible === !1 && (n.visible = !1),
        this.toneMapped === !1 && (n.toneMapped = !1),
        this.fog === !1 && (n.fog = !1),
        JSON.stringify(this.userData) !== "{}" && (n.userData = this.userData);
        function i(r) {
            const s = [];
            for (const a in r) {
                const l = r[a];
                delete l.metadata,
                s.push(l)
            }
            return s
        }
        if (t) {
            const r = i(e.textures)
              , s = i(e.images);
            r.length > 0 && (n.textures = r),
            s.length > 0 && (n.images = s)
        }
        return n
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name,
        this.blending = e.blending,
        this.side = e.side,
        this.vertexColors = e.vertexColors,
        this.opacity = e.opacity,
        this.transparent = e.transparent,
        this.blendSrc = e.blendSrc,
        this.blendDst = e.blendDst,
        this.blendEquation = e.blendEquation,
        this.blendSrcAlpha = e.blendSrcAlpha,
        this.blendDstAlpha = e.blendDstAlpha,
        this.blendEquationAlpha = e.blendEquationAlpha,
        this.depthFunc = e.depthFunc,
        this.depthTest = e.depthTest,
        this.depthWrite = e.depthWrite,
        this.stencilWriteMask = e.stencilWriteMask,
        this.stencilFunc = e.stencilFunc,
        this.stencilRef = e.stencilRef,
        this.stencilFuncMask = e.stencilFuncMask,
        this.stencilFail = e.stencilFail,
        this.stencilZFail = e.stencilZFail,
        this.stencilZPass = e.stencilZPass,
        this.stencilWrite = e.stencilWrite;
        const t = e.clippingPlanes;
        let n = null;
        if (t !== null) {
            const i = t.length;
            n = new Array(i);
            for (let r = 0; r !== i; ++r)
                n[r] = t[r].clone()
        }
        return this.clippingPlanes = n,
        this.clipIntersection = e.clipIntersection,
        this.clipShadows = e.clipShadows,
        this.shadowSide = e.shadowSide,
        this.colorWrite = e.colorWrite,
        this.precision = e.precision,
        this.polygonOffset = e.polygonOffset,
        this.polygonOffsetFactor = e.polygonOffsetFactor,
        this.polygonOffsetUnits = e.polygonOffsetUnits,
        this.dithering = e.dithering,
        this.alphaTest = e.alphaTest,
        this.alphaToCoverage = e.alphaToCoverage,
        this.premultipliedAlpha = e.premultipliedAlpha,
        this.visible = e.visible,
        this.toneMapped = e.toneMapped,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
}
class Ur extends fi {
    constructor(e) {
        super(),
        this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new ze(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = Ug,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setPhilosophy(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
const St = new X
  , ja = new Ze;
class gn {
    constructor(e, t, n) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0,
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.normalized = n === !0,
        this.usage = Lc,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    copy(e) {
        return this.name = e.name,
        this.array = new e.array.constructor(e.array),
        this.itemSize = e.itemSize,
        this.count = e.count,
        this.normalized = e.normalized,
        this.usage = e.usage,
        this
    }
    copyAt(e, t, n) {
        e *= this.itemSize,
        n *= t.itemSize;
        for (let i = 0, r = this.itemSize; i < r; i++)
            this.array[e + i] = t.array[n + i];
        return this
    }
    copyArray(e) {
        return this.array.set(e),
        this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let t = 0, n = this.count; t < n; t++)
                ja.fromBufferAttribute(this, t),
                ja.applyMatrix3(e),
                this.setXY(t, ja.x, ja.y);
        else if (this.itemSize === 3)
            for (let t = 0, n = this.count; t < n; t++)
                St.fromBufferAttribute(this, t),
                St.applyMatrix3(e),
                this.setXYZ(t, St.x, St.y, St.z);
        return this
    }
    applyMatrix4(e) {
        for (let t = 0, n = this.count; t < n; t++)
            St.fromBufferAttribute(this, t),
            St.applyMatrix4(e),
            this.setXYZ(t, St.x, St.y, St.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, n = this.count; t < n; t++)
            St.fromBufferAttribute(this, t),
            St.applyNormalMatrix(e),
            this.setXYZ(t, St.x, St.y, St.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, n = this.count; t < n; t++)
            St.fromBufferAttribute(this, t),
            St.transformDirection(e),
            this.setXYZ(t, St.x, St.y, St.z);
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = ki(t, this.array)),
        t
    }
    setX(e, t) {
        return this.normalized && (t = lt(t, this.array)),
        this.array[e * this.itemSize] = t,
        this
    }
    getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = ki(t, this.array)),
        t
    }
    setY(e, t) {
        return this.normalized && (t = lt(t, this.array)),
        this.array[e * this.itemSize + 1] = t,
        this
    }
    getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = ki(t, this.array)),
        t
    }
    setZ(e, t) {
        return this.normalized && (t = lt(t, this.array)),
        this.array[e * this.itemSize + 2] = t,
        this
    }
    getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = ki(t, this.array)),
        t
    }
    setW(e, t) {
        return this.normalized && (t = lt(t, this.array)),
        this.array[e * this.itemSize + 3] = t,
        this
    }
    setXY(e, t, n) {
        return e *= this.itemSize,
        this.normalized && (t = lt(t, this.array),
        n = lt(n, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = n,
        this
    }
    setXYZ(e, t, n, i) {
        return e *= this.itemSize,
        this.normalized && (t = lt(t, this.array),
        n = lt(n, this.array),
        i = lt(i, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = n,
        this.array[e + 2] = i,
        this
    }
    setXYZW(e, t, n, i, r) {
        return e *= this.itemSize,
        this.normalized && (t = lt(t, this.array),
        n = lt(n, this.array),
        i = lt(i, this.array),
        r = lt(r, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = n,
        this.array[e + 2] = i,
        this.array[e + 3] = r,
        this
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    clone() {
        return new this.constructor(this.array,this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name),
        this.usage !== Lc && (e.usage = this.usage),
        (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange),
        e
    }
    copyColorsArray() {
        console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")
    }
    copyVector2sArray() {
        console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")
    }
    copyVector3sArray() {
        console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")
    }
    copyVector4sArray() {
        console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")
    }
}
class Zg extends gn {
    constructor(e, t, n) {
        super(new Uint16Array(e), t, n)
    }
}
class Qg extends gn {
    constructor(e, t, n) {
        super(new Uint32Array(e), t, n)
    }
}
class Bi extends gn {
    constructor(e, t, n) {
        super(new Float32Array(e), t, n)
    }
}
let Ib = 0;
const Ln = new Ke
  , zu = new yt
  , ws = new X
  , xn = new ao
  , bo = new ao
  , Ot = new X;
class pi extends oo {
    constructor() {
        super(),
        this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", {
            value: Ib++
        }),
        this.uuid = ti(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new (jg(e) ? Qg : Zg)(e,1) : this.index = e,
        this
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, t) {
        return this.attributes[e] = t,
        this
    }
    deleteAttribute(e) {
        return delete this.attributes[e],
        this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, t, n=0) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: n
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, t) {
        this.drawRange.start = e,
        this.drawRange.count = t
    }
    applyMatrix4(e) {
        const t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e),
        t.needsUpdate = !0);
        const n = this.attributes.normal;
        if (n !== void 0) {
            const r = new Bn().getNormalMatrix(e);
            n.applyNormalMatrix(r),
            n.needsUpdate = !0
        }
        const i = this.attributes.tangent;
        return i !== void 0 && (i.transformDirection(e),
        i.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
    }
    applyQuaternion(e) {
        return Ln.makeRotationFromQuaternion(e),
        this.applyMatrix4(Ln),
        this
    }
    rotateX(e) {
        return Ln.makeRotationX(e),
        this.applyMatrix4(Ln),
        this
    }
    rotateY(e) {
        return Ln.makeRotationY(e),
        this.applyMatrix4(Ln),
        this
    }
    rotateZ(e) {
        return Ln.makeRotationZ(e),
        this.applyMatrix4(Ln),
        this
    }
    translate(e, t, n) {
        return Ln.makeTranslation(e, t, n),
        this.applyMatrix4(Ln),
        this
    }
    scale(e, t, n) {
        return Ln.makeScale(e, t, n),
        this.applyMatrix4(Ln),
        this
    }
    lookAt(e) {
        return zu.lookAt(e),
        zu.updateMatrix(),
        this.applyMatrix4(zu.matrix),
        this
    }
    center() {
        return this.computeBoundingBox(),
        this.boundingBox.getCenter(ws).negate(),
        this.translate(ws.x, ws.y, ws.z),
        this
    }
    setFromPoints(e) {
        const t = [];
        for (let n = 0, i = e.length; n < i; n++) {
            const r = e[n];
            t.push(r.x, r.y, r.z || 0)
        }
        return this.setAttribute("position", new Bi(t,3)),
        this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new ao);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
            this.boundingBox.set(new X(-1 / 0,-1 / 0,-1 / 0), new X(1 / 0,1 / 0,1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e),
            t)
                for (let n = 0, i = t.length; n < i; n++) {
                    const r = t[n];
                    xn.setFromBufferAttribute(r),
                    this.morphTargetsRelative ? (Ot.addVectors(this.boundingBox.min, xn.min),
                    this.boundingBox.expandByPoint(Ot),
                    Ot.addVectors(this.boundingBox.max, xn.max),
                    this.boundingBox.expandByPoint(Ot)) : (this.boundingBox.expandByPoint(xn.min),
                    this.boundingBox.expandByPoint(xn.max))
                }
        } else
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new lo);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
            this.boundingSphere.set(new X, 1 / 0);
            return
        }
        if (e) {
            const n = this.boundingSphere.center;
            if (xn.setFromBufferAttribute(e),
            t)
                for (let r = 0, s = t.length; r < s; r++) {
                    const a = t[r];
                    bo.setFromBufferAttribute(a),
                    this.morphTargetsRelative ? (Ot.addVectors(xn.min, bo.min),
                    xn.expandByPoint(Ot),
                    Ot.addVectors(xn.max, bo.max),
                    xn.expandByPoint(Ot)) : (xn.expandByPoint(bo.min),
                    xn.expandByPoint(bo.max))
                }
            xn.getCenter(n);
            let i = 0;
            for (let r = 0, s = e.count; r < s; r++)
                Ot.fromBufferAttribute(e, r),
                i = Math.max(i, n.distanceToSquared(Ot));
            if (t)
                for (let r = 0, s = t.length; r < s; r++) {
                    const a = t[r]
                      , l = this.morphTargetsRelative;
                    for (let u = 0, c = a.count; u < c; u++)
                        Ot.fromBufferAttribute(a, u),
                        l && (ws.fromBufferAttribute(e, u),
                        Ot.add(ws)),
                        i = Math.max(i, n.distanceToSquared(Ot))
                }
            this.boundingSphere.radius = Math.sqrt(i),
            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index
          , t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const n = e.array
          , i = t.position.array
          , r = t.normal.array
          , s = t.uv.array
          , a = i.length / 3;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new gn(new Float32Array(4 * a),4));
        const l = this.getAttribute("tangent").array
          , u = []
          , c = [];
        for (let N = 0; N < a; N++)
            u[N] = new X,
            c[N] = new X;
        const h = new X
          , f = new X
          , m = new X
          , _ = new Ze
          , d = new Ze
          , p = new Ze
          , v = new X
          , x = new X;
        function S(N, G, q) {
            h.fromArray(i, N * 3),
            f.fromArray(i, G * 3),
            m.fromArray(i, q * 3),
            _.fromArray(s, N * 2),
            d.fromArray(s, G * 2),
            p.fromArray(s, q * 2),
            f.sub(h),
            m.sub(h),
            d.sub(_),
            p.sub(_);
            const g = 1 / (d.x * p.y - p.x * d.y);
            !isFinite(g) || (v.copy(f).multiplyScalar(p.y).addScaledVector(m, -d.y).multiplyScalar(g),
            x.copy(m).multiplyScalar(d.x).addScaledVector(f, -p.x).multiplyScalar(g),
            u[N].add(v),
            u[G].add(v),
            u[q].add(v),
            c[N].add(x),
            c[G].add(x),
            c[q].add(x))
        }
        let M = this.groups;
        M.length === 0 && (M = [{
            start: 0,
            count: n.length
        }]);
        for (let N = 0, G = M.length; N < G; ++N) {
            const q = M[N]
              , g = q.start
              , w = q.count;
            for (let E = g, R = g + w; E < R; E += 3)
                S(n[E + 0], n[E + 1], n[E + 2])
        }
        const T = new X
          , L = new X
          , P = new X
          , A = new X;
        function C(N) {
            P.fromArray(r, N * 3),
            A.copy(P);
            const G = u[N];
            T.copy(G),
            T.sub(P.multiplyScalar(P.dot(G))).normalize(),
            L.crossVectors(A, G);
            const g = L.dot(c[N]) < 0 ? -1 : 1;
            l[N * 4] = T.x,
            l[N * 4 + 1] = T.y,
            l[N * 4 + 2] = T.z,
            l[N * 4 + 3] = g
        }
        for (let N = 0, G = M.length; N < G; ++N) {
            const q = M[N]
              , g = q.start
              , w = q.count;
            for (let E = g, R = g + w; E < R; E += 3)
                C(n[E + 0]),
                C(n[E + 1]),
                C(n[E + 2])
        }
    }
    computeVertexNormals() {
        const e = this.index
          , t = this.getAttribute("position");
        if (t !== void 0) {
            let n = this.getAttribute("normal");
            if (n === void 0)
                n = new gn(new Float32Array(t.count * 3),3),
                this.setAttribute("normal", n);
            else
                for (let f = 0, m = n.count; f < m; f++)
                    n.setXYZ(f, 0, 0, 0);
            const i = new X
              , r = new X
              , s = new X
              , a = new X
              , l = new X
              , u = new X
              , c = new X
              , h = new X;
            if (e)
                for (let f = 0, m = e.count; f < m; f += 3) {
                    const _ = e.getX(f + 0)
                      , d = e.getX(f + 1)
                      , p = e.getX(f + 2);
                    i.fromBufferAttribute(t, _),
                    r.fromBufferAttribute(t, d),
                    s.fromBufferAttribute(t, p),
                    c.subVectors(s, r),
                    h.subVectors(i, r),
                    c.cross(h),
                    a.fromBufferAttribute(n, _),
                    l.fromBufferAttribute(n, d),
                    u.fromBufferAttribute(n, p),
                    a.add(c),
                    l.add(c),
                    u.add(c),
                    n.setXYZ(_, a.x, a.y, a.z),
                    n.setXYZ(d, l.x, l.y, l.z),
                    n.setXYZ(p, u.x, u.y, u.z)
                }
            else
                for (let f = 0, m = t.count; f < m; f += 3)
                    i.fromBufferAttribute(t, f + 0),
                    r.fromBufferAttribute(t, f + 1),
                    s.fromBufferAttribute(t, f + 2),
                    c.subVectors(s, r),
                    h.subVectors(i, r),
                    c.cross(h),
                    n.setXYZ(f + 0, c.x, c.y, c.z),
                    n.setXYZ(f + 1, c.x, c.y, c.z),
                    n.setXYZ(f + 2, c.x, c.y, c.z);
            this.normalizeNormals(),
            n.needsUpdate = !0
        }
    }
    merge() {
        return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."),
        this
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, n = e.count; t < n; t++)
            Ot.fromBufferAttribute(e, t),
            Ot.normalize(),
            e.setXYZ(t, Ot.x, Ot.y, Ot.z)
    }
    toNonIndexed() {
        function e(a, l) {
            const u = a.array
              , c = a.itemSize
              , h = a.normalized
              , f = new u.constructor(l.length * c);
            let m = 0
              , _ = 0;
            for (let d = 0, p = l.length; d < p; d++) {
                a.isInterleavedBufferAttribute ? m = l[d] * a.data.stride + a.offset : m = l[d] * c;
                for (let v = 0; v < c; v++)
                    f[_++] = u[m++]
            }
            return new gn(f,c,h)
        }
        if (this.index === null)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
            this;
        const t = new pi
          , n = this.index.array
          , i = this.attributes;
        for (const a in i) {
            const l = i[a]
              , u = e(l, n);
            t.setAttribute(a, u)
        }
        const r = this.morphAttributes;
        for (const a in r) {
            const l = []
              , u = r[a];
            for (let c = 0, h = u.length; c < h; c++) {
                const f = u[c]
                  , m = e(f, n);
                l.push(m)
            }
            t.morphAttributes[a] = l
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const s = this.groups;
        for (let a = 0, l = s.length; a < l; a++) {
            const u = s[a];
            t.addGroup(u.start, u.count, u.materialIndex)
        }
        return t
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.5,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid,
        e.type = this.type,
        this.name !== "" && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        this.parameters !== void 0) {
            const l = this.parameters;
            for (const u in l)
                l[u] !== void 0 && (e[u] = l[u]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const t = this.index;
        t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        const n = this.attributes;
        for (const l in n) {
            const u = n[l];
            e.data.attributes[l] = u.toJSON(e.data)
        }
        const i = {};
        let r = !1;
        for (const l in this.morphAttributes) {
            const u = this.morphAttributes[l]
              , c = [];
            for (let h = 0, f = u.length; h < f; h++) {
                const m = u[h];
                c.push(m.toJSON(e.data))
            }
            c.length > 0 && (i[l] = c,
            r = !0)
        }
        r && (e.data.morphAttributes = i,
        e.data.morphTargetsRelative = this.morphTargetsRelative);
        const s = this.groups;
        s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
        const a = this.boundingSphere;
        return a !== null && (e.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius
        }),
        e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const n = e.index;
        n !== null && this.setIndex(n.clone(t));
        const i = e.attributes;
        for (const u in i) {
            const c = i[u];
            this.setAttribute(u, c.clone(t))
        }
        const r = e.morphAttributes;
        for (const u in r) {
            const c = []
              , h = r[u];
            for (let f = 0, m = h.length; f < m; f++)
                c.push(h[f].clone(t));
            this.morphAttributes[u] = c
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const s = e.groups;
        for (let u = 0, c = s.length; u < c; u++) {
            const h = s[u];
            this.addGroup(h.start, h.count, h.materialIndex)
        }
        const a = e.boundingBox;
        a !== null && (this.boundingBox = a.clone());
        const l = e.boundingSphere;
        return l !== null && (this.boundingSphere = l.clone()),
        this.drawRange.start = e.drawRange.start,
        this.drawRange.count = e.drawRange.count,
        this.userData = e.userData,
        e.parameters !== void 0 && (this.parameters = Object.assign({}, e.parameters)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const Cd = new Ke
  , Ms = new ph
  , Uu = new lo
  , Zi = new X
  , Qi = new X
  , Ji = new X
  , Bu = new X
  , Vu = new X
  , Gu = new X
  , qa = new X
  , Xa = new X
  , Ya = new X
  , Ka = new Ze
  , $a = new Ze
  , Za = new Ze
  , Hu = new X
  , Qa = new X;
class Vn extends yt {
    constructor(e=new pi, t=new Ur) {
        super(),
        this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
        this.material = e.material,
        this.geometry = e.geometry,
        this
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , n = Object.keys(t);
        if (n.length > 0) {
            const i = t[n[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let r = 0, s = i.length; r < s; r++) {
                    const a = i[r].name || String(r);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = r
                }
            }
        }
    }
    raycast(e, t) {
        const n = this.geometry
          , i = this.material
          , r = this.matrixWorld;
        if (i === void 0 || (n.boundingSphere === null && n.computeBoundingSphere(),
        Uu.copy(n.boundingSphere),
        Uu.applyMatrix4(r),
        e.ray.intersectsSphere(Uu) === !1) || (Cd.copy(r).invert(),
        Ms.copy(e.ray).applyMatrix4(Cd),
        n.boundingBox !== null && Ms.intersectsBox(n.boundingBox) === !1))
            return;
        let s;
        const a = n.index
          , l = n.attributes.position
          , u = n.morphAttributes.position
          , c = n.morphTargetsRelative
          , h = n.attributes.uv
          , f = n.attributes.uv2
          , m = n.groups
          , _ = n.drawRange;
        if (a !== null)
            if (Array.isArray(i))
                for (let d = 0, p = m.length; d < p; d++) {
                    const v = m[d]
                      , x = i[v.materialIndex]
                      , S = Math.max(v.start, _.start)
                      , M = Math.min(a.count, Math.min(v.start + v.count, _.start + _.count));
                    for (let T = S, L = M; T < L; T += 3) {
                        const P = a.getX(T)
                          , A = a.getX(T + 1)
                          , C = a.getX(T + 2);
                        s = Ja(this, x, e, Ms, l, u, c, h, f, P, A, C),
                        s && (s.faceIndex = Math.floor(T / 3),
                        s.face.materialIndex = v.materialIndex,
                        t.push(s))
                    }
                }
            else {
                const d = Math.max(0, _.start)
                  , p = Math.min(a.count, _.start + _.count);
                for (let v = d, x = p; v < x; v += 3) {
                    const S = a.getX(v)
                      , M = a.getX(v + 1)
                      , T = a.getX(v + 2);
                    s = Ja(this, i, e, Ms, l, u, c, h, f, S, M, T),
                    s && (s.faceIndex = Math.floor(v / 3),
                    t.push(s))
                }
            }
        else if (l !== void 0)
            if (Array.isArray(i))
                for (let d = 0, p = m.length; d < p; d++) {
                    const v = m[d]
                      , x = i[v.materialIndex]
                      , S = Math.max(v.start, _.start)
                      , M = Math.min(l.count, Math.min(v.start + v.count, _.start + _.count));
                    for (let T = S, L = M; T < L; T += 3) {
                        const P = T
                          , A = T + 1
                          , C = T + 2;
                        s = Ja(this, x, e, Ms, l, u, c, h, f, P, A, C),
                        s && (s.faceIndex = Math.floor(T / 3),
                        s.face.materialIndex = v.materialIndex,
                        t.push(s))
                    }
                }
            else {
                const d = Math.max(0, _.start)
                  , p = Math.min(l.count, _.start + _.count);
                for (let v = d, x = p; v < x; v += 3) {
                    const S = v
                      , M = v + 1
                      , T = v + 2;
                    s = Ja(this, i, e, Ms, l, u, c, h, f, S, M, T),
                    s && (s.faceIndex = Math.floor(v / 3),
                    t.push(s))
                }
            }
    }
}
function Fb(o, e, t, n, i, r, s, a) {
    let l;
    if (e.side === Wn ? l = n.intersectTriangle(s, r, i, !0, a) : l = n.intersectTriangle(i, r, s, e.side !== Oi, a),
    l === null)
        return null;
    Qa.copy(a),
    Qa.applyMatrix4(o.matrixWorld);
    const u = t.ray.origin.distanceTo(Qa);
    return u < t.near || u > t.far ? null : {
        distance: u,
        point: Qa.clone(),
        object: o
    }
}
function Ja(o, e, t, n, i, r, s, a, l, u, c, h) {
    Zi.fromBufferAttribute(i, u),
    Qi.fromBufferAttribute(i, c),
    Ji.fromBufferAttribute(i, h);
    const f = o.morphTargetInfluences;
    if (r && f) {
        qa.set(0, 0, 0),
        Xa.set(0, 0, 0),
        Ya.set(0, 0, 0);
        for (let _ = 0, d = r.length; _ < d; _++) {
            const p = f[_]
              , v = r[_];
            p !== 0 && (Bu.fromBufferAttribute(v, u),
            Vu.fromBufferAttribute(v, c),
            Gu.fromBufferAttribute(v, h),
            s ? (qa.addScaledVector(Bu, p),
            Xa.addScaledVector(Vu, p),
            Ya.addScaledVector(Gu, p)) : (qa.addScaledVector(Bu.sub(Zi), p),
            Xa.addScaledVector(Vu.sub(Qi), p),
            Ya.addScaledVector(Gu.sub(Ji), p)))
        }
        Zi.add(qa),
        Qi.add(Xa),
        Ji.add(Ya)
    }
    o.isSkinnedMesh && (o.boneTransform(u, Zi),
    o.boneTransform(c, Qi),
    o.boneTransform(h, Ji));
    const m = Fb(o, e, t, n, Zi, Qi, Ji, Hu);
    if (m) {
        a && (Ka.fromBufferAttribute(a, u),
        $a.fromBufferAttribute(a, c),
        Za.fromBufferAttribute(a, h),
        m.uv = Ci.getUV(Hu, Zi, Qi, Ji, Ka, $a, Za, new Ze)),
        l && (Ka.fromBufferAttribute(l, u),
        $a.fromBufferAttribute(l, c),
        Za.fromBufferAttribute(l, h),
        m.uv2 = Ci.getUV(Hu, Zi, Qi, Ji, Ka, $a, Za, new Ze));
        const _ = {
            a: u,
            b: c,
            c: h,
            normal: new X,
            materialIndex: 0
        };
        Ci.getNormal(Zi, Qi, Ji, _.normal),
        m.face = _
    }
    return m
}
class ga extends pi {
    constructor(e=1, t=1, n=1, i=1, r=1, s=1) {
        super(),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: n,
            widthSegments: i,
            heightSegments: r,
            depthSegments: s
        };
        const a = this;
        i = Math.floor(i),
        r = Math.floor(r),
        s = Math.floor(s);
        const l = []
          , u = []
          , c = []
          , h = [];
        let f = 0
          , m = 0;
        _("z", "y", "x", -1, -1, n, t, e, s, r, 0),
        _("z", "y", "x", 1, -1, n, t, -e, s, r, 1),
        _("x", "z", "y", 1, 1, e, n, t, i, s, 2),
        _("x", "z", "y", 1, -1, e, n, -t, i, s, 3),
        _("x", "y", "z", 1, -1, e, t, n, i, r, 4),
        _("x", "y", "z", -1, -1, e, t, -n, i, r, 5),
        this.setIndex(l),
        this.setAttribute("position", new Bi(u,3)),
        this.setAttribute("normal", new Bi(c,3)),
        this.setAttribute("uv", new Bi(h,2));
        function _(d, p, v, x, S, M, T, L, P, A, C) {
            const N = M / P
              , G = T / A
              , q = M / 2
              , g = T / 2
              , w = L / 2
              , E = P + 1
              , R = A + 1;
            let z = 0
              , b = 0;
            const y = new X;
            for (let D = 0; D < R; D++) {
                const I = D * G - g;
                for (let F = 0; F < E; F++) {
                    const B = F * N - q;
                    y[d] = B * x,
                    y[p] = I * S,
                    y[v] = w,
                    u.push(y.x, y.y, y.z),
                    y[d] = 0,
                    y[p] = 0,
                    y[v] = L > 0 ? 1 : -1,
                    c.push(y.x, y.y, y.z),
                    h.push(F / P),
                    h.push(1 - D / A),
                    z += 1
                }
            }
            for (let D = 0; D < A; D++)
                for (let I = 0; I < P; I++) {
                    const F = f + I + E * D
                      , B = f + I + E * (D + 1)
                      , H = f + (I + 1) + E * (D + 1)
                      , W = f + (I + 1) + E * D;
                    l.push(F, B, W),
                    l.push(B, H, W),
                    b += 6
                }
            a.addGroup(m, b, C),
            m += b,
            f += z
        }
    }
    static fromJSON(e) {
        return new ga(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
    }
}
function ro(o) {
    const e = {};
    for (const t in o) {
        e[t] = {};
        for (const n in o[t]) {
            const i = o[t][n];
            i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? e[t][n] = i.clone() : Array.isArray(i) ? e[t][n] = i.slice() : e[t][n] = i
        }
    }
    return e
}
function Ht(o) {
    const e = {};
    for (let t = 0; t < o.length; t++) {
        const n = ro(o[t]);
        for (const i in n)
            e[i] = n[i]
    }
    return e
}
function Ob(o) {
    const e = [];
    for (let t = 0; t < o.length; t++)
        e.push(o[t].clone());
    return e
}
const Nb = {
    clone: ro,
    merge: Ht
};
var kb = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`
  , zb = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class mr extends fi {
    constructor(e) {
        super(),
        this.isShaderMaterial = !0,
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.uniformsGroups = [],
        this.vertexShader = kb,
        this.fragmentShader = zb,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        },
        this.defaultAttributePhilosophy = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        e !== void 0 && this.setPhilosophy(e)
    }
    copy(e) {
        return super.copy(e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = ro(e.uniforms),
        this.uniformsGroups = Ob(e.uniformsGroups),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.fog = e.fog,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.extensions = Object.assign({}, e.extensions),
        this.glslVersion = e.glslVersion,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        t.glslVersion = this.glslVersion,
        t.uniforms = {};
        for (const i in this.uniforms) {
            const s = this.uniforms[i].value;
            s && s.isTexture ? t.uniforms[i] = {
                type: "t",
                value: s.toJSON(e).uuid
            } : s && s.isColor ? t.uniforms[i] = {
                type: "c",
                value: s.getHex()
            } : s && s.isVector2 ? t.uniforms[i] = {
                type: "v2",
                value: s.toArray()
            } : s && s.isVector3 ? t.uniforms[i] = {
                type: "v3",
                value: s.toArray()
            } : s && s.isVector4 ? t.uniforms[i] = {
                type: "v4",
                value: s.toArray()
            } : s && s.isMatrix3 ? t.uniforms[i] = {
                type: "m3",
                value: s.toArray()
            } : s && s.isMatrix4 ? t.uniforms[i] = {
                type: "m4",
                value: s.toArray()
            } : t.uniforms[i] = {
                value: s
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader;
        const n = {};
        for (const i in this.extensions)
            this.extensions[i] === !0 && (n[i] = !0);
        return Object.keys(n).length > 0 && (t.extensions = n),
        t
    }
}
class Jg extends yt {
    constructor() {
        super(),
        this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new Ke,
        this.projectionMatrix = new Ke,
        this.projectionMatrixInverse = new Ke
    }
    copy(e, t) {
        return super.copy(e, t),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        this
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(-t[8], -t[9], -t[10]).normalize()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class un extends Jg {
    constructor(e=50, t=1, n=.1, i=2e3) {
        super(),
        this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = n,
        this.far = i,
        this.focus = 10,
        this.aspect = t,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.fov = e.fov,
        this.zoom = e.zoom,
        this.near = e.near,
        this.far = e.far,
        this.focus = e.focus,
        this.aspect = e.aspect,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this.filmGauge = e.filmGauge,
        this.filmOffset = e.filmOffset,
        this
    }
    setFocalLength(e) {
        const t = .5 * this.getFilmHeight() / e;
        this.fov = aa * 2 * Math.atan(t),
        this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(jo * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return aa * 2 * Math.atan(Math.tan(jo * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    setViewOffset(e, t, n, i, r, s) {
        this.aspect = e / t,
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = n,
        this.view.offsetY = i,
        this.view.width = r,
        this.view.height = s,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let t = e * Math.tan(jo * .5 * this.fov) / this.zoom
          , n = 2 * t
          , i = this.aspect * n
          , r = -.5 * i;
        const s = this.view;
        if (this.view !== null && this.view.enabled) {
            const l = s.fullWidth
              , u = s.fullHeight;
            r += s.offsetX * i / l,
            t -= s.offsetY * n / u,
            i *= s.width / l,
            n *= s.height / u
        }
        const a = this.filmOffset;
        a !== 0 && (r += e * a / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.fov = this.fov,
        t.object.zoom = this.zoom,
        t.object.near = this.near,
        t.object.far = this.far,
        t.object.focus = this.focus,
        t.object.aspect = this.aspect,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t.object.filmGauge = this.filmGauge,
        t.object.filmOffset = this.filmOffset,
        t
    }
}
const Ss = 90
  , Ds = 1;
class Ub extends yt {
    constructor(e, t, n) {
        super(),
        this.type = "CubeCamera",
        this.renderTarget = n;
        const i = new un(Ss,Ds,e,t);
        i.layers = this.layers,
        i.up.set(0, -1, 0),
        i.lookAt(new X(1,0,0)),
        this.add(i);
        const r = new un(Ss,Ds,e,t);
        r.layers = this.layers,
        r.up.set(0, -1, 0),
        r.lookAt(new X(-1,0,0)),
        this.add(r);
        const s = new un(Ss,Ds,e,t);
        s.layers = this.layers,
        s.up.set(0, 0, 1),
        s.lookAt(new X(0,1,0)),
        this.add(s);
        const a = new un(Ss,Ds,e,t);
        a.layers = this.layers,
        a.up.set(0, 0, -1),
        a.lookAt(new X(0,-1,0)),
        this.add(a);
        const l = new un(Ss,Ds,e,t);
        l.layers = this.layers,
        l.up.set(0, -1, 0),
        l.lookAt(new X(0,0,1)),
        this.add(l);
        const u = new un(Ss,Ds,e,t);
        u.layers = this.layers,
        u.up.set(0, -1, 0),
        u.lookAt(new X(0,0,-1)),
        this.add(u)
    }
    update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        const n = this.renderTarget
          , [i,r,s,a,l,u] = this.children
          , c = e.getRenderTarget()
          , h = e.toneMapping
          , f = e.xr.enabled;
        e.toneMapping = Ui,
        e.xr.enabled = !1;
        const m = n.texture.generateMipmaps;
        n.texture.generateMipmaps = !1,
        e.setRenderTarget(n, 0),
        e.render(t, i),
        e.setRenderTarget(n, 1),
        e.render(t, r),
        e.setRenderTarget(n, 2),
        e.render(t, s),
        e.setRenderTarget(n, 3),
        e.render(t, a),
        e.setRenderTarget(n, 4),
        e.render(t, l),
        n.texture.generateMipmaps = m,
        e.setRenderTarget(n, 5),
        e.render(t, u),
        e.setRenderTarget(c),
        e.toneMapping = h,
        e.xr.enabled = f,
        n.texture.needsPMREMUpdate = !0
    }
}
class e_ extends tn {
    constructor(e, t, n, i, r, s, a, l, u, c) {
        e = e !== void 0 ? e : [],
        t = t !== void 0 ? t : Js,
        super(e, t, n, i, r, s, a, l, u, c),
        this.isCubeTexture = !0,
        this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class Bb extends ts {
    constructor(e, t={}) {
        super(e, e, t),
        this.isWebGLCubeRenderTarget = !0;
        const n = {
            width: e,
            height: e,
            depth: 1
        }
          , i = [n, n, n, n, n, n];
        this.texture = new e_(i,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),
        this.texture.isRenderTargetTexture = !0,
        this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1,
        this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : It
    }
    fromEquirectangularTexture(e, t) {
        this.texture.type = t.type,
        this.texture.encoding = t.encoding,
        this.texture.generateMipmaps = t.generateMipmaps,
        this.texture.minFilter = t.minFilter,
        this.texture.magFilter = t.magFilter;
        const n = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        }
          , i = new ga(5,5,5)
          , r = new mr({
            name: "CubemapFromEquirect",
            uniforms: ro(n.uniforms),
            vertexShader: n.vertexShader,
            fragmentShader: n.fragmentShader,
            side: Wn,
            blending: hr
        });
        r.uniforms.tEquirect.value = t;
        const s = new Vn(i,r)
          , a = t.minFilter;
        return t.minFilter === ss && (t.minFilter = It),
        new Ub(1,10,this).update(e, s),
        t.minFilter = a,
        s.geometry.dispose(),
        s.material.dispose(),
        this
    }
    clear(e, t, n, i) {
        const r = e.getRenderTarget();
        for (let s = 0; s < 6; s++)
            e.setRenderTarget(this, s),
            e.clear(t, n, i);
        e.setRenderTarget(r)
    }
}
const Wu = new X
  , Vb = new X
  , Gb = new Bn;
class Ar {
    constructor(e=new X(1,0,0), t=0) {
        this.isPlane = !0,
        this.normal = e,
        this.constant = t
    }
    set(e, t) {
        return this.normal.copy(e),
        this.constant = t,
        this
    }
    setComponents(e, t, n, i) {
        return this.normal.set(e, t, n),
        this.constant = i,
        this
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e),
        this.constant = -t.dot(this.normal),
        this
    }
    setFromCoplanarPoints(e, t, n) {
        const i = Wu.subVectors(n, t).cross(Vb.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(i, e),
        this
    }
    copy(e) {
        return this.normal.copy(e.normal),
        this.constant = e.constant,
        this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e),
        this.constant *= e,
        this
    }
    negate() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, t) {
        return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
    }
    intersectLine(e, t) {
        const n = e.delta(Wu)
          , i = this.normal.dot(n);
        if (i === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        const r = -(e.start.dot(this.normal) + this.constant) / i;
        return r < 0 || r > 1 ? null : t.copy(n).multiplyScalar(r).add(e.start)
    }
    intersectsLine(e) {
        const t = this.distanceToPoint(e.start)
          , n = this.distanceToPoint(e.end);
        return t < 0 && n > 0 || n < 0 && t > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, t) {
        const n = t || Gb.getNormalMatrix(e)
          , i = this.coplanarPoint(Wu).applyMatrix4(e)
          , r = this.normal.applyMatrix3(n).normalize();
        return this.constant = -i.dot(r),
        this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal),
        this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const Ts = new lo
  , el = new X;
class mh {
    constructor(e=new Ar, t=new Ar, n=new Ar, i=new Ar, r=new Ar, s=new Ar) {
        this.planes = [e, t, n, i, r, s]
    }
    set(e, t, n, i, r, s) {
        const a = this.planes;
        return a[0].copy(e),
        a[1].copy(t),
        a[2].copy(n),
        a[3].copy(i),
        a[4].copy(r),
        a[5].copy(s),
        this
    }
    copy(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++)
            t[n].copy(e.planes[n]);
        return this
    }
    setFromProjectionMatrix(e) {
        const t = this.planes
          , n = e.elements
          , i = n[0]
          , r = n[1]
          , s = n[2]
          , a = n[3]
          , l = n[4]
          , u = n[5]
          , c = n[6]
          , h = n[7]
          , f = n[8]
          , m = n[9]
          , _ = n[10]
          , d = n[11]
          , p = n[12]
          , v = n[13]
          , x = n[14]
          , S = n[15];
        return t[0].setComponents(a - i, h - l, d - f, S - p).normalize(),
        t[1].setComponents(a + i, h + l, d + f, S + p).normalize(),
        t[2].setComponents(a + r, h + u, d + m, S + v).normalize(),
        t[3].setComponents(a - r, h - u, d - m, S - v).normalize(),
        t[4].setComponents(a - s, h - c, d - _, S - x).normalize(),
        t[5].setComponents(a + s, h + c, d + _, S + x).normalize(),
        this
    }
    intersectsObject(e) {
        const t = e.geometry;
        return t.boundingSphere === null && t.computeBoundingSphere(),
        Ts.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
        this.intersectsSphere(Ts)
    }
    intersectsSprite(e) {
        return Ts.center.set(0, 0, 0),
        Ts.radius = .7071067811865476,
        Ts.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(Ts)
    }
    intersectsSphere(e) {
        const t = this.planes
          , n = e.center
          , i = -e.radius;
        for (let r = 0; r < 6; r++)
            if (t[r].distanceToPoint(n) < i)
                return !1;
        return !0
    }
    intersectsBox(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++) {
            const i = t[n];
            if (el.x = i.normal.x > 0 ? e.max.x : e.min.x,
            el.y = i.normal.y > 0 ? e.max.y : e.min.y,
            el.z = i.normal.z > 0 ? e.max.z : e.min.z,
            i.distanceToPoint(el) < 0)
                return !1
        }
        return !0
    }
    containsPoint(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++)
            if (t[n].distanceToPoint(e) < 0)
                return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
function t_() {
    let o = null
      , e = !1
      , t = null
      , n = null;
    function i(r, s) {
        t(r, s),
        n = o.requestAnimationFrame(i)
    }
    return {
        start: function() {
            e !== !0 && t !== null && (n = o.requestAnimationFrame(i),
            e = !0)
        },
        stop: function() {
            o.cancelAnimationFrame(n),
            e = !1
        },
        setAnimationLoop: function(r) {
            t = r
        },
        setContext: function(r) {
            o = r
        }
    }
}
function Hb(o, e) {
    const t = e.isWebGL2
      , n = new WeakMap;
    function i(u, c) {
        const h = u.array
          , f = u.usage
          , m = o.createBuffer();
        o.bindBuffer(c, m),
        o.bufferData(c, h, f),
        u.onUploadCallback();
        let _;
        if (h instanceof Float32Array)
            _ = 5126;
        else if (h instanceof Uint16Array)
            if (u.isFloat16BufferAttribute)
                if (t)
                    _ = 5131;
                else
                    throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
            else
                _ = 5123;
        else if (h instanceof Int16Array)
            _ = 5122;
        else if (h instanceof Uint32Array)
            _ = 5125;
        else if (h instanceof Int32Array)
            _ = 5124;
        else if (h instanceof Int8Array)
            _ = 5120;
        else if (h instanceof Uint8Array)
            _ = 5121;
        else if (h instanceof Uint8ClampedArray)
            _ = 5121;
        else
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + h);
        return {
            buffer: m,
            type: _,
            bytesPerElement: h.BYTES_PER_ELEMENT,
            version: u.version
        }
    }
    function r(u, c, h) {
        const f = c.array
          , m = c.updateRange;
        o.bindBuffer(h, u),
        m.count === -1 ? o.bufferSubData(h, 0, f) : (t ? o.bufferSubData(h, m.offset * f.BYTES_PER_ELEMENT, f, m.offset, m.count) : o.bufferSubData(h, m.offset * f.BYTES_PER_ELEMENT, f.subarray(m.offset, m.offset + m.count)),
        m.count = -1)
    }
    function s(u) {
        return u.isInterleavedBufferAttribute && (u = u.data),
        n.get(u)
    }
    function a(u) {
        u.isInterleavedBufferAttribute && (u = u.data);
        const c = n.get(u);
        c && (o.deleteBuffer(c.buffer),
        n.delete(u))
    }
    function l(u, c) {
        if (u.isGLBufferAttribute) {
            const f = n.get(u);
            (!f || f.version < u.version) && n.set(u, {
                buffer: u.buffer,
                type: u.type,
                bytesPerElement: u.elementSize,
                version: u.version
            });
            return
        }
        u.isInterleavedBufferAttribute && (u = u.data);
        const h = n.get(u);
        h === void 0 ? n.set(u, i(u, c)) : h.version < u.version && (r(h.buffer, u, c),
        h.version = u.version)
    }
    return {
        get: s,
        remove: a,
        update: l
    }
}
class gh extends pi {
    constructor(e=1, t=1, n=1, i=1) {
        super(),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: n,
            heightSegments: i
        };
        const r = e / 2
          , s = t / 2
          , a = Math.floor(n)
          , l = Math.floor(i)
          , u = a + 1
          , c = l + 1
          , h = e / a
          , f = t / l
          , m = []
          , _ = []
          , d = []
          , p = [];
        for (let v = 0; v < c; v++) {
            const x = v * f - s;
            for (let S = 0; S < u; S++) {
                const M = S * h - r;
                _.push(M, -x, 0),
                d.push(0, 0, 1),
                p.push(S / a),
                p.push(1 - v / l)
            }
        }
        for (let v = 0; v < l; v++)
            for (let x = 0; x < a; x++) {
                const S = x + u * v
                  , M = x + u * (v + 1)
                  , T = x + 1 + u * (v + 1)
                  , L = x + 1 + u * v;
                m.push(S, M, L),
                m.push(M, T, L)
            }
        this.setIndex(m),
        this.setAttribute("position", new Bi(_,3)),
        this.setAttribute("normal", new Bi(d,3)),
        this.setAttribute("uv", new Bi(p,2))
    }
    static fromJSON(e) {
        return new gh(e.width,e.height,e.widthSegments,e.heightSegments)
    }
}
var Wb = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`
  , jb = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , qb = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`
  , Xb = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`
  , Yb = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`
  , Kb = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`
  , $b = "vec3 transformed = vec3( position );"
  , Zb = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`
  , Qb = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`
  , Jb = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`
  , ew = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`
  , tw = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`
  , nw = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`
  , iw = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`
  , rw = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`
  , sw = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`
  , ow = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`
  , aw = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`
  , lw = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`
  , uw = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`
  , cw = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`
  , hw = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`
  , fw = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`
  , dw = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`
  , pw = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`
  , mw = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`
  , gw = "gl_FragColor = linearToOutputTexel( gl_FragColor );"
  , _w = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`
  , vw = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`
  , xw = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`
  , yw = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`
  , bw = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`
  , ww = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`
  , Mw = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`
  , Sw = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`
  , Dw = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`
  , Tw = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`
  , Ew = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`
  , Aw = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`
  , Cw = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`
  , Lw = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`
  , Rw = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert
#define Material_LightProbeLOD( material )	(0)`
  , Pw = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`
  , Iw = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`
  , Fw = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`
  , Ow = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`
  , Nw = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`
  , kw = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`
  , zw = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`
  , Uw = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`
  , Bw = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`
  , Vw = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`
  , Gw = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`
  , Hw = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`
  , Ww = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , jw = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`
  , qw = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`
  , Xw = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`
  , Yw = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`
  , Kw = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`
  , $w = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , Zw = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`
  , Qw = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`
  , Jw = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`
  , eM = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`
  , tM = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`
  , nM = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`
  , iM = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`
  , rM = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`
  , sM = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , oM = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , aM = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`
  , lM = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`
  , uM = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`
  , cM = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`
  , hM = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`
  , fM = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`
  , dM = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`
  , pM = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`
  , mM = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`
  , gM = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`
  , _M = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`
  , vM = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`
  , xM = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`
  , yM = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`
  , bM = `#if NUM_SPOT_LIGHT_COORDS > 0
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`
  , wM = `#if NUM_SPOT_LIGHT_COORDS > 0
  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`
  , MM = `#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`
  , SM = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`
  , DM = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`
  , TM = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`
  , EM = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`
  , AM = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`
  , CM = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`
  , LM = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`
  , RM = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`
  , PM = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`
  , IM = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`
  , FM = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`
  , OM = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`
  , NM = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`
  , kM = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`
  , zM = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`
  , UM = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`
  , BM = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`
  , VM = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const GM = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`
  , HM = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );
	#endif
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , WM = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , jM = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , qM = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`
  , XM = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`
  , YM = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`
  , KM = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`
  , $M = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`
  , ZM = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , QM = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , JM = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , eS = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`
  , tS = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , nS = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , iS = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , rS = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`
  , sS = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , oS = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`
  , aS = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`
  , lS = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , uS = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , cS = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`
  , hS = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , fS = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , dS = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , pS = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`
  , mS = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , gS = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , _S = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`
  , vS = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , xS = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`
  , We = {
    alphamap_fragment: Wb,
    alphamap_pars_fragment: jb,
    alphatest_fragment: qb,
    alphatest_pars_fragment: Xb,
    aomap_fragment: Yb,
    aomap_pars_fragment: Kb,
    begin_vertex: $b,
    beginnormal_vertex: Zb,
    bsdfs: Qb,
    iridescence_fragment: Jb,
    bumpmap_pars_fragment: ew,
    clipping_planes_fragment: tw,
    clipping_planes_pars_fragment: nw,
    clipping_planes_pars_vertex: iw,
    clipping_planes_vertex: rw,
    color_fragment: sw,
    color_pars_fragment: ow,
    color_pars_vertex: aw,
    color_vertex: lw,
    common: uw,
    cube_uv_reflection_fragment: cw,
    defaultnormal_vertex: hw,
    displacementmap_pars_vertex: fw,
    displacementmap_vertex: dw,
    emissivemap_fragment: pw,
    emissivemap_pars_fragment: mw,
    encodings_fragment: gw,
    encodings_pars_fragment: _w,
    envmap_fragment: vw,
    envmap_common_pars_fragment: xw,
    envmap_pars_fragment: yw,
    envmap_pars_vertex: bw,
    envmap_physical_pars_fragment: Iw,
    envmap_vertex: ww,
    fog_vertex: Mw,
    fog_pars_vertex: Sw,
    fog_fragment: Dw,
    fog_pars_fragment: Tw,
    gradientmap_pars_fragment: Ew,
    lightmap_fragment: Aw,
    lightmap_pars_fragment: Cw,
    lights_lambert_fragment: Lw,
    lights_lambert_pars_fragment: Rw,
    lights_pars_begin: Pw,
    lights_toon_fragment: Fw,
    lights_toon_pars_fragment: Ow,
    lights_phong_fragment: Nw,
    lights_phong_pars_fragment: kw,
    lights_physical_fragment: zw,
    lights_physical_pars_fragment: Uw,
    lights_fragment_begin: Bw,
    lights_fragment_maps: Vw,
    lights_fragment_end: Gw,
    logdepthbuf_fragment: Hw,
    logdepthbuf_pars_fragment: Ww,
    logdepthbuf_pars_vertex: jw,
    logdepthbuf_vertex: qw,
    map_fragment: Xw,
    map_pars_fragment: Yw,
    map_particle_fragment: Kw,
    map_particle_pars_fragment: $w,
    metalnessmap_fragment: Zw,
    metalnessmap_pars_fragment: Qw,
    morphcolor_vertex: Jw,
    morphnormal_vertex: eM,
    morphtarget_pars_vertex: tM,
    morphtarget_vertex: nM,
    normal_fragment_begin: iM,
    normal_fragment_maps: rM,
    normal_pars_fragment: sM,
    normal_pars_vertex: oM,
    normal_vertex: aM,
    normalmap_pars_fragment: lM,
    clearcoat_normal_fragment_begin: uM,
    clearcoat_normal_fragment_maps: cM,
    clearcoat_pars_fragment: hM,
    iridescence_pars_fragment: fM,
    output_fragment: dM,
    packing: pM,
    premultiplied_alpha_fragment: mM,
    project_vertex: gM,
    dithering_fragment: _M,
    dithering_pars_fragment: vM,
    roughnessmap_fragment: xM,
    roughnessmap_pars_fragment: yM,
    shadowmap_pars_fragment: bM,
    shadowmap_pars_vertex: wM,
    shadowmap_vertex: MM,
    shadowmask_pars_fragment: SM,
    skinbase_vertex: DM,
    skinning_pars_vertex: TM,
    skinning_vertex: EM,
    skinnormal_vertex: AM,
    specularmap_fragment: CM,
    specularmap_pars_fragment: LM,
    tonemapping_fragment: RM,
    tonemapping_pars_fragment: PM,
    transmission_fragment: IM,
    transmission_pars_fragment: FM,
    uv_pars_fragment: OM,
    uv_pars_vertex: NM,
    uv_vertex: kM,
    uv2_pars_fragment: zM,
    uv2_pars_vertex: UM,
    uv2_vertex: BM,
    worldpos_vertex: VM,
    background_vert: GM,
    background_frag: HM,
    cube_vert: WM,
    cube_frag: jM,
    depth_vert: qM,
    depth_frag: XM,
    distanceRGBA_vert: YM,
    distanceRGBA_frag: KM,
    equirect_vert: $M,
    equirect_frag: ZM,
    linedashed_vert: QM,
    linedashed_frag: JM,
    meshbasic_vert: eS,
    meshbasic_frag: tS,
    meshlambert_vert: nS,
    meshlambert_frag: iS,
    meshmatcap_vert: rS,
    meshmatcap_frag: sS,
    meshnormal_vert: oS,
    meshnormal_frag: aS,
    meshphong_vert: lS,
    meshphong_frag: uS,
    meshphysical_vert: cS,
    meshphysical_frag: hS,
    meshtoon_vert: fS,
    meshtoon_frag: dS,
    points_vert: pS,
    points_frag: mS,
    shadow_vert: gS,
    shadow_frag: _S,
    sprite_vert: vS,
    sprite_frag: xS
}
  , ge = {
    common: {
        diffuse: {
            value: new ze(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        uvTransform: {
            value: new Bn
        },
        uv2Transform: {
            value: new Bn
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalScale: {
            value: new Ze(1,1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new ze(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotLightMap: {
            value: []
        },
        spotShadowMap: {
            value: []
        },
        spotLightMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new ze(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new Bn
        }
    },
    sprite: {
        diffuse: {
            value: new ze(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new Ze(.5,.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new Bn
        }
    }
}
  , si = {
    basic: {
        uniforms: Ht([ge.common, ge.specularmap, ge.envmap, ge.aomap, ge.lightmap, ge.fog]),
        vertexShader: We.meshbasic_vert,
        fragmentShader: We.meshbasic_frag
    },
    lambert: {
        uniforms: Ht([ge.common, ge.specularmap, ge.envmap, ge.aomap, ge.lightmap, ge.emissivemap, ge.bumpmap, ge.normalmap, ge.displacementmap, ge.fog, ge.lights, {
            emissive: {
                value: new ze(0)
            }
        }]),
        vertexShader: We.meshlambert_vert,
        fragmentShader: We.meshlambert_frag
    },
    phong: {
        uniforms: Ht([ge.common, ge.specularmap, ge.envmap, ge.aomap, ge.lightmap, ge.emissivemap, ge.bumpmap, ge.normalmap, ge.displacementmap, ge.fog, ge.lights, {
            emissive: {
                value: new ze(0)
            },
            specular: {
                value: new ze(1118481)
            },
            shininess: {
                value: 30
            }
        }]),
        vertexShader: We.meshphong_vert,
        fragmentShader: We.meshphong_frag
    },
    standard: {
        uniforms: Ht([ge.common, ge.envmap, ge.aomap, ge.lightmap, ge.emissivemap, ge.bumpmap, ge.normalmap, ge.displacementmap, ge.roughnessmap, ge.metalnessmap, ge.fog, ge.lights, {
            emissive: {
                value: new ze(0)
            },
            roughness: {
                value: 1
            },
            metalness: {
                value: 0
            },
            envMapIntensity: {
                value: 1
            }
        }]),
        vertexShader: We.meshphysical_vert,
        fragmentShader: We.meshphysical_frag
    },
    toon: {
        uniforms: Ht([ge.common, ge.aomap, ge.lightmap, ge.emissivemap, ge.bumpmap, ge.normalmap, ge.displacementmap, ge.gradientmap, ge.fog, ge.lights, {
            emissive: {
                value: new ze(0)
            }
        }]),
        vertexShader: We.meshtoon_vert,
        fragmentShader: We.meshtoon_frag
    },
    matcap: {
        uniforms: Ht([ge.common, ge.bumpmap, ge.normalmap, ge.displacementmap, ge.fog, {
            matcap: {
                value: null
            }
        }]),
        vertexShader: We.meshmatcap_vert,
        fragmentShader: We.meshmatcap_frag
    },
    points: {
        uniforms: Ht([ge.points, ge.fog]),
        vertexShader: We.points_vert,
        fragmentShader: We.points_frag
    },
    dashed: {
        uniforms: Ht([ge.common, ge.fog, {
            scale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            totalSize: {
                value: 2
            }
        }]),
        vertexShader: We.linedashed_vert,
        fragmentShader: We.linedashed_frag
    },
    depth: {
        uniforms: Ht([ge.common, ge.displacementmap]),
        vertexShader: We.depth_vert,
        fragmentShader: We.depth_frag
    },
    normal: {
        uniforms: Ht([ge.common, ge.bumpmap, ge.normalmap, ge.displacementmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: We.meshnormal_vert,
        fragmentShader: We.meshnormal_frag
    },
    sprite: {
        uniforms: Ht([ge.sprite, ge.fog]),
        vertexShader: We.sprite_vert,
        fragmentShader: We.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new Bn
            },
            t2D: {
                value: null
            }
        },
        vertexShader: We.background_vert,
        fragmentShader: We.background_frag
    },
    cube: {
        uniforms: Ht([ge.envmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: We.cube_vert,
        fragmentShader: We.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: We.equirect_vert,
        fragmentShader: We.equirect_frag
    },
    distanceRGBA: {
        uniforms: Ht([ge.common, ge.displacementmap, {
            referencePosition: {
                value: new X
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1e3
            }
        }]),
        vertexShader: We.distanceRGBA_vert,
        fragmentShader: We.distanceRGBA_frag
    },
    shadow: {
        uniforms: Ht([ge.lights, ge.fog, {
            color: {
                value: new ze(0)
            },
            opacity: {
                value: 1
            }
        }]),
        vertexShader: We.shadow_vert,
        fragmentShader: We.shadow_frag
    }
};
si.physical = {
    uniforms: Ht([si.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatNormalScale: {
            value: new Ze(1,1)
        },
        clearcoatNormalMap: {
            value: null
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new ze(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionSamplerSize: {
            value: new Ze
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new ze(0)
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularColor: {
            value: new ze(1,1,1)
        },
        specularColorMap: {
            value: null
        }
    }]),
    vertexShader: We.meshphysical_vert,
    fragmentShader: We.meshphysical_frag
};
function yS(o, e, t, n, i, r) {
    const s = new ze(0);
    let a = i === !0 ? 0 : 1, l, u, c = null, h = 0, f = null;
    function m(d, p) {
        let v = !1
          , x = p.isScene === !0 ? p.background : null;
        x && x.isTexture && (x = e.get(x));
        const S = o.xr
          , M = S.getSession && S.getSession();
        M && M.environmentBlendMode === "additive" && (x = null),
        x === null ? _(s, a) : x && x.isColor && (_(x, 1),
        v = !0),
        (o.autoClear || v) && o.clear(o.autoClearColor, o.autoClearDepth, o.autoClearStencil),
        x && (x.isCubeTexture || x.mapping === jl) ? (u === void 0 && (u = new Vn(new ga(1,1,1),new mr({
            name: "BackgroundCubeMaterial",
            uniforms: ro(si.cube.uniforms),
            vertexShader: si.cube.vertexShader,
            fragmentShader: si.cube.fragmentShader,
            side: Wn,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        u.geometry.deleteAttribute("normal"),
        u.geometry.deleteAttribute("uv"),
        u.onBeforeRender = function(T, L, P) {
            this.matrixWorld.copyPosition(P.matrixWorld)
        }
        ,
        Object.defineProperty(u.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }),
        n.update(u)),
        u.material.uniforms.envMap.value = x,
        u.material.uniforms.flipEnvMap.value = x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1,
        (c !== x || h !== x.version || f !== o.toneMapping) && (u.material.needsUpdate = !0,
        c = x,
        h = x.version,
        f = o.toneMapping),
        u.layers.enableAll(),
        d.unshift(u, u.geometry, u.material, 0, 0, null)) : x && x.isTexture && (l === void 0 && (l = new Vn(new gh(2,2),new mr({
            name: "BackgroundMaterial",
            uniforms: ro(si.background.uniforms),
            vertexShader: si.background.vertexShader,
            fragmentShader: si.background.fragmentShader,
            side: Jr,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        l.geometry.deleteAttribute("normal"),
        Object.defineProperty(l.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }),
        n.update(l)),
        l.material.uniforms.t2D.value = x,
        x.matrixAutoUpdate === !0 && x.updateMatrix(),
        l.material.uniforms.uvTransform.value.copy(x.matrix),
        (c !== x || h !== x.version || f !== o.toneMapping) && (l.material.needsUpdate = !0,
        c = x,
        h = x.version,
        f = o.toneMapping),
        l.layers.enableAll(),
        d.unshift(l, l.geometry, l.material, 0, 0, null))
    }
    function _(d, p) {
        t.buffers.color.setClear(d.r, d.g, d.b, p, r)
    }
    return {
        getClearColor: function() {
            return s
        },
        setClearColor: function(d, p=1) {
            s.set(d),
            a = p,
            _(s, a)
        },
        getClearAlpha: function() {
            return a
        },
        setClearAlpha: function(d) {
            a = d,
            _(s, a)
        },
        render: m
    }
}
function bS(o, e, t, n) {
    const i = o.getParameter(34921)
      , r = n.isWebGL2 ? null : e.get("OES_vertex_array_object")
      , s = n.isWebGL2 || r !== null
      , a = {}
      , l = p(null);
    let u = l
      , c = !1;
    function h(w, E, R, z, b) {
        let y = !1;
        if (s) {
            const D = d(z, R, E);
            u !== D && (u = D,
            m(u.object)),
            y = v(w, z, R, b),
            y && x(w, z, R, b)
        } else {
            const D = E.wireframe === !0;
            (u.geometry !== z.id || u.program !== R.id || u.wireframe !== D) && (u.geometry = z.id,
            u.program = R.id,
            u.wireframe = D,
            y = !0)
        }
        b !== null && t.update(b, 34963),
        (y || c) && (c = !1,
        A(w, E, R, z),
        b !== null && o.bindBuffer(34963, t.get(b).buffer))
    }
    function f() {
        return n.isWebGL2 ? o.createVertexArray() : r.createVertexArrayOES()
    }
    function m(w) {
        return n.isWebGL2 ? o.bindVertexArray(w) : r.bindVertexArrayOES(w)
    }
    function _(w) {
        return n.isWebGL2 ? o.deleteVertexArray(w) : r.deleteVertexArrayOES(w)
    }
    function d(w, E, R) {
        const z = R.wireframe === !0;
        let b = a[w.id];
        b === void 0 && (b = {},
        a[w.id] = b);
        let y = b[E.id];
        y === void 0 && (y = {},
        b[E.id] = y);
        let D = y[z];
        return D === void 0 && (D = p(f()),
        y[z] = D),
        D
    }
    function p(w) {
        const E = []
          , R = []
          , z = [];
        for (let b = 0; b < i; b++)
            E[b] = 0,
            R[b] = 0,
            z[b] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: E,
            enabledAttributes: R,
            attributeDivisors: z,
            object: w,
            attributes: {},
            index: null
        }
    }
    function v(w, E, R, z) {
        const b = u.attributes
          , y = E.attributes;
        let D = 0;
        const I = R.getAttributes();
        for (const F in I)
            if (I[F].location >= 0) {
                const H = b[F];
                let W = y[F];
                if (W === void 0 && (F === "instanceMatrix" && w.instanceMatrix && (W = w.instanceMatrix),
                F === "instanceColor" && w.instanceColor && (W = w.instanceColor)),
                H === void 0 || H.attribute !== W || W && H.data !== W.data)
                    return !0;
                D++
            }
        return u.attributesNum !== D || u.index !== z
    }
    function x(w, E, R, z) {
        const b = {}
          , y = E.attributes;
        let D = 0;
        const I = R.getAttributes();
        for (const F in I)
            if (I[F].location >= 0) {
                let H = y[F];
                H === void 0 && (F === "instanceMatrix" && w.instanceMatrix && (H = w.instanceMatrix),
                F === "instanceColor" && w.instanceColor && (H = w.instanceColor));
                const W = {};
                W.attribute = H,
                H && H.data && (W.data = H.data),
                b[F] = W,
                D++
            }
        u.attributes = b,
        u.attributesNum = D,
        u.index = z
    }
    function S() {
        const w = u.newAttributes;
        for (let E = 0, R = w.length; E < R; E++)
            w[E] = 0
    }
    function M(w) {
        T(w, 0)
    }
    function T(w, E) {
        const R = u.newAttributes
          , z = u.enabledAttributes
          , b = u.attributeDivisors;
        R[w] = 1,
        z[w] === 0 && (o.enableVertexAttribArray(w),
        z[w] = 1),
        b[w] !== E && ((n.isWebGL2 ? o : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](w, E),
        b[w] = E)
    }
    function L() {
        const w = u.newAttributes
          , E = u.enabledAttributes;
        for (let R = 0, z = E.length; R < z; R++)
            E[R] !== w[R] && (o.disableVertexAttribArray(R),
            E[R] = 0)
    }
    function P(w, E, R, z, b, y) {
        n.isWebGL2 === !0 && (R === 5124 || R === 5125) ? o.vertexAttribIPointer(w, E, R, b, y) : o.vertexAttribPointer(w, E, R, z, b, y)
    }
    function A(w, E, R, z) {
        if (n.isWebGL2 === !1 && (w.isInstancedMesh || z.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
            return;
        S();
        const b = z.attributes
          , y = R.getAttributes()
          , D = E.defaultAttributePhilosophy;
        for (const I in y) {
            const F = y[I];
            if (F.location >= 0) {
                let B = b[I];
                if (B === void 0 && (I === "instanceMatrix" && w.instanceMatrix && (B = w.instanceMatrix),
                I === "instanceColor" && w.instanceColor && (B = w.instanceColor)),
                B !== void 0) {
                    const H = B.normalized
                      , W = B.itemSize
                      , U = t.get(B);
                    if (U === void 0)
                        continue;
                    const K = U.buffer
                      , te = U.type
                      , he = U.bytesPerElement;
                    if (B.isInterleavedBufferAttribute) {
                        const ne = B.data
                          , ce = ne.stride
                          , oe = B.offset;
                        if (ne.isInstancedInterleavedBuffer) {
                            for (let ue = 0; ue < F.locationSize; ue++)
                                T(F.location + ue, ne.meshPerAttribute);
                            w.isInstancedMesh !== !0 && z._maxInstanceCount === void 0 && (z._maxInstanceCount = ne.meshPerAttribute * ne.count)
                        } else
                            for (let ue = 0; ue < F.locationSize; ue++)
                                M(F.location + ue);
                        o.bindBuffer(34962, K);
                        for (let ue = 0; ue < F.locationSize; ue++)
                            P(F.location + ue, W / F.locationSize, te, H, ce * he, (oe + W / F.locationSize * ue) * he)
                    } else {
                        if (B.isInstancedBufferAttribute) {
                            for (let ne = 0; ne < F.locationSize; ne++)
                                T(F.location + ne, B.meshPerAttribute);
                            w.isInstancedMesh !== !0 && z._maxInstanceCount === void 0 && (z._maxInstanceCount = B.meshPerAttribute * B.count)
                        } else
                            for (let ne = 0; ne < F.locationSize; ne++)
                                M(F.location + ne);
                        o.bindBuffer(34962, K);
                        for (let ne = 0; ne < F.locationSize; ne++)
                            P(F.location + ne, W / F.locationSize, te, H, W * he, W / F.locationSize * ne * he)
                    }
                } else if (D !== void 0) {
                    const H = D[I];
                    if (H !== void 0)
                        switch (H.length) {
                        case 2:
                            o.vertexAttrib2fv(F.location, H);
                            break;
                        case 3:
                            o.vertexAttrib3fv(F.location, H);
                            break;
                        case 4:
                            o.vertexAttrib4fv(F.location, H);
                            break;
                        default:
                            o.vertexAttrib1fv(F.location, H)
                        }
                }
            }
        }
        L()
    }
    function C() {
        q();
        for (const w in a) {
            const E = a[w];
            for (const R in E) {
                const z = E[R];
                for (const b in z)
                    _(z[b].object),
                    delete z[b];
                delete E[R]
            }
            delete a[w]
        }
    }
    function N(w) {
        if (a[w.id] === void 0)
            return;
        const E = a[w.id];
        for (const R in E) {
            const z = E[R];
            for (const b in z)
                _(z[b].object),
                delete z[b];
            delete E[R]
        }
        delete a[w.id]
    }
    function G(w) {
        for (const E in a) {
            const R = a[E];
            if (R[w.id] === void 0)
                continue;
            const z = R[w.id];
            for (const b in z)
                _(z[b].object),
                delete z[b];
            delete R[w.id]
        }
    }
    function q() {
        g(),
        c = !0,
        u !== l && (u = l,
        m(u.object))
    }
    function g() {
        l.geometry = null,
        l.program = null,
        l.wireframe = !1
    }
    return {
        setup: h,
        reset: q,
        resetDefaultState: g,
        dispose: C,
        releaseStatesOfGeometry: N,
        releaseStatesOfProgram: G,
        initAttributes: S,
        enableAttribute: M,
        disableUnusedAttributes: L
    }
}
function wS(o, e, t, n) {
    const i = n.isWebGL2;
    let r;
    function s(u) {
        r = u
    }
    function a(u, c) {
        o.drawArrays(r, u, c),
        t.update(c, r, 1)
    }
    function l(u, c, h) {
        if (h === 0)
            return;
        let f, m;
        if (i)
            f = o,
            m = "drawArraysInstanced";
        else if (f = e.get("ANGLE_instanced_arrays"),
        m = "drawArraysInstancedANGLE",
        f === null) {
            console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        f[m](r, u, c, h),
        t.update(c, r, h)
    }
    this.setMode = s,
    this.render = a,
    this.renderInstances = l
}
function MS(o, e, t) {
    let n;
    function i() {
        if (n !== void 0)
            return n;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const P = e.get("EXT_texture_filter_anisotropic");
            n = o.getParameter(P.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else
            n = 0;
        return n
    }
    function r(P) {
        if (P === "highp") {
            if (o.getShaderPrecisionFormat(35633, 36338).precision > 0 && o.getShaderPrecisionFormat(35632, 36338).precision > 0)
                return "highp";
            P = "mediump"
        }
        return P === "mediump" && o.getShaderPrecisionFormat(35633, 36337).precision > 0 && o.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
    }
    const s = typeof WebGL2RenderingContext < "u" && o instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext < "u" && o instanceof WebGL2ComputeRenderingContext;
    let a = t.precision !== void 0 ? t.precision : "highp";
    const l = r(a);
    l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."),
    a = l);
    const u = s || e.has("WEBGL_draw_buffers")
      , c = t.logarithmicDepthBuffer === !0
      , h = o.getParameter(34930)
      , f = o.getParameter(35660)
      , m = o.getParameter(3379)
      , _ = o.getParameter(34076)
      , d = o.getParameter(34921)
      , p = o.getParameter(36347)
      , v = o.getParameter(36348)
      , x = o.getParameter(36349)
      , S = f > 0
      , M = s || e.has("OES_texture_float")
      , T = S && M
      , L = s ? o.getParameter(36183) : 0;
    return {
        isWebGL2: s,
        drawBuffers: u,
        getMaxAnisotropy: i,
        getMaxPrecision: r,
        precision: a,
        logarithmicDepthBuffer: c,
        maxTextures: h,
        maxVertexTextures: f,
        maxTextureSize: m,
        maxCubemapSize: _,
        maxAttributes: d,
        maxVertexUniforms: p,
        maxVaryings: v,
        maxFragmentUniforms: x,
        vertexTextures: S,
        floatFragmentTextures: M,
        floatVertexTextures: T,
        maxSamples: L
    }
}
function SS(o) {
    const e = this;
    let t = null
      , n = 0
      , i = !1
      , r = !1;
    const s = new Ar
      , a = new Bn
      , l = {
        value: null,
        needsUpdate: !1
    };
    this.uniform = l,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(h, f, m) {
        const _ = h.length !== 0 || f || n !== 0 || i;
        return i = f,
        t = c(h, m, 0),
        n = h.length,
        _
    }
    ,
    this.beginShadows = function() {
        r = !0,
        c(null)
    }
    ,
    this.endShadows = function() {
        r = !1,
        u()
    }
    ,
    this.setState = function(h, f, m) {
        const _ = h.clippingPlanes
          , d = h.clipIntersection
          , p = h.clipShadows
          , v = o.get(h);
        if (!i || _ === null || _.length === 0 || r && !p)
            r ? c(null) : u();
        else {
            const x = r ? 0 : n
              , S = x * 4;
            let M = v.clippingState || null;
            l.value = M,
            M = c(_, f, S, m);
            for (let T = 0; T !== S; ++T)
                M[T] = t[T];
            v.clippingState = M,
            this.numIntersection = d ? this.numPlanes : 0,
            this.numPlanes += x
        }
    }
    ;
    function u() {
        l.value !== t && (l.value = t,
        l.needsUpdate = n > 0),
        e.numPlanes = n,
        e.numIntersection = 0
    }
    function c(h, f, m, _) {
        const d = h !== null ? h.length : 0;
        let p = null;
        if (d !== 0) {
            if (p = l.value,
            _ !== !0 || p === null) {
                const v = m + d * 4
                  , x = f.matrixWorldInverse;
                a.getNormalMatrix(x),
                (p === null || p.length < v) && (p = new Float32Array(v));
                for (let S = 0, M = m; S !== d; ++S,
                M += 4)
                    s.copy(h[S]).applyMatrix4(x, a),
                    s.normal.toArray(p, M),
                    p[M + 3] = s.constant
            }
            l.value = p,
            l.needsUpdate = !0
        }
        return e.numPlanes = d,
        e.numIntersection = 0,
        p
    }
}
function DS(o) {
    let e = new WeakMap;
    function t(s, a) {
        return a === Tc ? s.mapping = Js : a === Ec && (s.mapping = eo),
        s
    }
    function n(s) {
        if (s && s.isTexture && s.isRenderTargetTexture === !1) {
            const a = s.mapping;
            if (a === Tc || a === Ec)
                if (e.has(s)) {
                    const l = e.get(s).texture;
                    return t(l, s.mapping)
                } else {
                    const l = s.image;
                    if (l && l.height > 0) {
                        const u = new Bb(l.height / 2);
                        return u.fromEquirectangularTexture(o, s),
                        e.set(s, u),
                        s.addEventListener("dispose", i),
                        t(u.texture, s.mapping)
                    } else
                        return null
                }
        }
        return s
    }
    function i(s) {
        const a = s.target;
        a.removeEventListener("dispose", i);
        const l = e.get(a);
        l !== void 0 && (e.delete(a),
        l.dispose())
    }
    function r() {
        e = new WeakMap
    }
    return {
        get: n,
        dispose: r
    }
}
class _h extends Jg {
    constructor(e=-1, t=1, n=1, i=-1, r=.1, s=2e3) {
        super(),
        this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = t,
        this.top = n,
        this.bottom = i,
        this.near = r,
        this.far = s,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.left = e.left,
        this.right = e.right,
        this.top = e.top,
        this.bottom = e.bottom,
        this.near = e.near,
        this.far = e.far,
        this.zoom = e.zoom,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this
    }
    setViewOffset(e, t, n, i, r, s) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = n,
        this.view.offsetY = i,
        this.view.width = r,
        this.view.height = s,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom)
          , t = (this.top - this.bottom) / (2 * this.zoom)
          , n = (this.right + this.left) / 2
          , i = (this.top + this.bottom) / 2;
        let r = n - e
          , s = n + e
          , a = i + t
          , l = i - t;
        if (this.view !== null && this.view.enabled) {
            const u = (this.right - this.left) / this.view.fullWidth / this.zoom
              , c = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            r += u * this.view.offsetX,
            s = r + u * this.view.width,
            a -= c * this.view.offsetY,
            l = a - c * this.view.height
        }
        this.projectionMatrix.makeOrthographic(r, s, a, l, this.near, this.far),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom,
        t.object.left = this.left,
        t.object.right = this.right,
        t.object.top = this.top,
        t.object.bottom = this.bottom,
        t.object.near = this.near,
        t.object.far = this.far,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t
    }
}
const Ns = 4
  , Ld = [.125, .215, .35, .446, .526, .582]
  , Pr = 20
  , ju = new _h
  , Rd = new ze;
let qu = null;
const Cr = (1 + Math.sqrt(5)) / 2
  , Es = 1 / Cr
  , Pd = [new X(1,1,1), new X(-1,1,1), new X(1,1,-1), new X(-1,1,-1), new X(0,Cr,Es), new X(0,Cr,-Es), new X(Es,0,Cr), new X(-Es,0,Cr), new X(Cr,Es,0), new X(-Cr,Es,0)];
class Id {
    constructor(e) {
        this._renderer = e,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, t=0, n=.1, i=100) {
        qu = this._renderer.getRenderTarget(),
        this._setSize(256);
        const r = this._allocateTargets();
        return r.depthBuffer = !0,
        this._sceneToCubeUV(e, n, i, r),
        t > 0 && this._blur(r, 0, 0, t),
        this._applyPMREM(r),
        this._cleanup(r),
        r
    }
    fromEquirectangular(e, t=null) {
        return this._fromTexture(e, t)
    }
    fromCubemap(e, t=null) {
        return this._fromTexture(e, t)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = Nd(),
        this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = Od(),
        this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(qu),
        e.scissorTest = !1,
        tl(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, t) {
        e.mapping === Js || e.mapping === eo ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
        qu = this._renderer.getRenderTarget();
        const n = t || this._allocateTargets();
        return this._textureToCubeUV(e, n),
        this._applyPMREM(n),
        this._cleanup(n),
        n
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112)
          , t = 4 * this._cubeSize
          , n = {
            magFilter: It,
            minFilter: It,
            generateMipmaps: !1,
            type: Ni,
            format: Jn,
            encoding: pr,
            depthBuffer: !1
        }
          , i = Fd(e, t, n);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e) {
            this._pingPongRenderTarget !== null && this._dispose(),
            this._pingPongRenderTarget = Fd(e, t, n);
            const {_lodMax: r} = this;
            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = TS(r)),
            this._blurMaterial = ES(r, e, t)
        }
        return i
    }
    _compileMaterial(e) {
        const t = new Vn(this._lodPlanes[0],e);
        this._renderer.compile(t, ju)
    }
    _sceneToCubeUV(e, t, n, i) {
        const a = new un(90,1,t,n)
          , l = [1, -1, 1, 1, 1, 1]
          , u = [1, 1, 1, -1, -1, -1]
          , c = this._renderer
          , h = c.autoClear
          , f = c.toneMapping;
        c.getClearColor(Rd),
        c.toneMapping = Ui,
        c.autoClear = !1;
        const m = new Ur({
            name: "PMREM.Background",
            side: Wn,
            depthWrite: !1,
            depthTest: !1
        })
          , _ = new Vn(new ga,m);
        let d = !1;
        const p = e.background;
        p ? p.isColor && (m.color.copy(p),
        e.background = null,
        d = !0) : (m.color.copy(Rd),
        d = !0);
        for (let v = 0; v < 6; v++) {
            const x = v % 3;
            x === 0 ? (a.up.set(0, l[v], 0),
            a.lookAt(u[v], 0, 0)) : x === 1 ? (a.up.set(0, 0, l[v]),
            a.lookAt(0, u[v], 0)) : (a.up.set(0, l[v], 0),
            a.lookAt(0, 0, u[v]));
            const S = this._cubeSize;
            tl(i, x * S, v > 2 ? S : 0, S, S),
            c.setRenderTarget(i),
            d && c.render(_, a),
            c.render(e, a)
        }
        _.geometry.dispose(),
        _.material.dispose(),
        c.toneMapping = f,
        c.autoClear = h,
        e.background = p
    }
    _textureToCubeUV(e, t) {
        const n = this._renderer
          , i = e.mapping === Js || e.mapping === eo;
        i ? (this._cubemapMaterial === null && (this._cubemapMaterial = Nd()),
        this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Od());
        const r = i ? this._cubemapMaterial : this._equirectMaterial
          , s = new Vn(this._lodPlanes[0],r)
          , a = r.uniforms;
        a.envMap.value = e;
        const l = this._cubeSize;
        tl(t, 0, 0, 3 * l, 2 * l),
        n.setRenderTarget(t),
        n.render(s, ju)
    }
    _applyPMREM(e) {
        const t = this._renderer
          , n = t.autoClear;
        t.autoClear = !1;
        for (let i = 1; i < this._lodPlanes.length; i++) {
            const r = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1])
              , s = Pd[(i - 1) % Pd.length];
            this._blur(e, i - 1, i, r, s)
        }
        t.autoClear = n
    }
    _blur(e, t, n, i, r) {
        const s = this._pingPongRenderTarget;
        this._halfBlur(e, s, t, n, i, "latitudinal", r),
        this._halfBlur(s, e, n, n, i, "longitudinal", r)
    }
    _halfBlur(e, t, n, i, r, s, a) {
        const l = this._renderer
          , u = this._blurMaterial;
        s !== "latitudinal" && s !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const c = 3
          , h = new Vn(this._lodPlanes[i],u)
          , f = u.uniforms
          , m = this._sizeLods[n] - 1
          , _ = isFinite(r) ? Math.PI / (2 * m) : 2 * Math.PI / (2 * Pr - 1)
          , d = r / _
          , p = isFinite(r) ? 1 + Math.floor(c * d) : Pr;
        p > Pr && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${p} samples when the maximum is set to ${Pr}`);
        const v = [];
        let x = 0;
        for (let P = 0; P < Pr; ++P) {
            const A = P / d
              , C = Math.exp(-A * A / 2);
            v.push(C),
            P === 0 ? x += C : P < p && (x += 2 * C)
        }
        for (let P = 0; P < v.length; P++)
            v[P] = v[P] / x;
        f.envMap.value = e.texture,
        f.samples.value = p,
        f.weights.value = v,
        f.latitudinal.value = s === "latitudinal",
        a && (f.poleAxis.value = a);
        const {_lodMax: S} = this;
        f.dTheta.value = _,
        f.mipInt.value = S - n;
        const M = this._sizeLods[i]
          , T = 3 * M * (i > S - Ns ? i - S + Ns : 0)
          , L = 4 * (this._cubeSize - M);
        tl(t, T, L, 3 * M, 2 * M),
        l.setRenderTarget(t),
        l.render(h, ju)
    }
}
function TS(o) {
    const e = []
      , t = []
      , n = [];
    let i = o;
    const r = o - Ns + 1 + Ld.length;
    for (let s = 0; s < r; s++) {
        const a = Math.pow(2, i);
        t.push(a);
        let l = 1 / a;
        s > o - Ns ? l = Ld[s - o + Ns - 1] : s === 0 && (l = 0),
        n.push(l);
        const u = 1 / (a - 2)
          , c = -u
          , h = 1 + u
          , f = [c, c, h, c, h, h, c, c, h, h, c, h]
          , m = 6
          , _ = 6
          , d = 3
          , p = 2
          , v = 1
          , x = new Float32Array(d * _ * m)
          , S = new Float32Array(p * _ * m)
          , M = new Float32Array(v * _ * m);
        for (let L = 0; L < m; L++) {
            const P = L % 3 * 2 / 3 - 1
              , A = L > 2 ? 0 : -1
              , C = [P, A, 0, P + 2 / 3, A, 0, P + 2 / 3, A + 1, 0, P, A, 0, P + 2 / 3, A + 1, 0, P, A + 1, 0];
            x.set(C, d * _ * L),
            S.set(f, p * _ * L);
            const N = [L, L, L, L, L, L];
            M.set(N, v * _ * L)
        }
        const T = new pi;
        T.setAttribute("position", new gn(x,d)),
        T.setAttribute("uv", new gn(S,p)),
        T.setAttribute("faceIndex", new gn(M,v)),
        e.push(T),
        i > Ns && i--
    }
    return {
        lodPlanes: e,
        sizeLods: t,
        sigmas: n
    }
}
function Fd(o, e, t) {
    const n = new ts(o,e,t);
    return n.texture.mapping = jl,
    n.texture.name = "PMREM.cubeUv",
    n.scissorTest = !0,
    n
}
function tl(o, e, t, n, i) {
    o.viewport.set(e, t, n, i),
    o.scissor.set(e, t, n, i)
}
function ES(o, e, t) {
    const n = new Float32Array(Pr)
      , i = new X(0,1,0);
    return new mr({
        name: "SphericalGaussianBlur",
        defines: {
            n: Pr,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${o}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: n
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: i
            }
        },
        vertexShader: vh(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: hr,
        depthTest: !1,
        depthWrite: !1
    })
}
function Od() {
    return new mr({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: vh(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: hr,
        depthTest: !1,
        depthWrite: !1
    })
}
function Nd() {
    return new mr({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: vh(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: hr,
        depthTest: !1,
        depthWrite: !1
    })
}
function vh() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function AS(o) {
    let e = new WeakMap
      , t = null;
    function n(a) {
        if (a && a.isTexture) {
            const l = a.mapping
              , u = l === Tc || l === Ec
              , c = l === Js || l === eo;
            if (u || c)
                if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
                    a.needsPMREMUpdate = !1;
                    let h = e.get(a);
                    return t === null && (t = new Id(o)),
                    h = u ? t.fromEquirectangular(a, h) : t.fromCubemap(a, h),
                    e.set(a, h),
                    h.texture
                } else {
                    if (e.has(a))
                        return e.get(a).texture;
                    {
                        const h = a.image;
                        if (u && h && h.height > 0 || c && h && i(h)) {
                            t === null && (t = new Id(o));
                            const f = u ? t.fromEquirectangular(a) : t.fromCubemap(a);
                            return e.set(a, f),
                            a.addEventListener("dispose", r),
                            f.texture
                        } else
                            return null
                    }
                }
        }
        return a
    }
    function i(a) {
        let l = 0;
        const u = 6;
        for (let c = 0; c < u; c++)
            a[c] !== void 0 && l++;
        return l === u
    }
    function r(a) {
        const l = a.target;
        l.removeEventListener("dispose", r);
        const u = e.get(l);
        u !== void 0 && (e.delete(l),
        u.dispose())
    }
    function s() {
        e = new WeakMap,
        t !== null && (t.dispose(),
        t = null)
    }
    return {
        get: n,
        dispose: s
    }
}
function CS(o) {
    const e = {};
    function t(n) {
        if (e[n] !== void 0)
            return e[n];
        let i;
        switch (n) {
        case "WEBGL_depth_texture":
            i = o.getExtension("WEBGL_depth_texture") || o.getExtension("MOZ_WEBGL_depth_texture") || o.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            i = o.getExtension("EXT_texture_filter_anisotropic") || o.getExtension("MOZ_EXT_texture_filter_anisotropic") || o.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            i = o.getExtension("WEBGL_compressed_texture_s3tc") || o.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || o.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            i = o.getExtension("WEBGL_compressed_texture_pvrtc") || o.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            i = o.getExtension(n)
        }
        return e[n] = i,
        i
    }
    return {
        has: function(n) {
            return t(n) !== null
        },
        init: function(n) {
            n.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"),
            t("OES_texture_float"),
            t("OES_texture_half_float"),
            t("OES_texture_half_float_linear"),
            t("OES_standard_derivatives"),
            t("OES_element_index_uint"),
            t("OES_vertex_array_object"),
            t("ANGLE_instanced_arrays")),
            t("OES_texture_float_linear"),
            t("EXT_color_buffer_half_float"),
            t("WEBGL_multisampled_render_to_texture")
        },
        get: function(n) {
            const i = t(n);
            return i === null && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."),
            i
        }
    }
}
function LS(o, e, t, n) {
    const i = {}
      , r = new WeakMap;
    function s(h) {
        const f = h.target;
        f.index !== null && e.remove(f.index);
        for (const _ in f.attributes)
            e.remove(f.attributes[_]);
        f.removeEventListener("dispose", s),
        delete i[f.id];
        const m = r.get(f);
        m && (e.remove(m),
        r.delete(f)),
        n.releaseStatesOfGeometry(f),
        f.isInstancedBufferGeometry === !0 && delete f._maxInstanceCount,
        t.memory.geometries--
    }
    function a(h, f) {
        return i[f.id] === !0 || (f.addEventListener("dispose", s),
        i[f.id] = !0,
        t.memory.geometries++),
        f
    }
    function l(h) {
        const f = h.attributes;
        for (const _ in f)
            e.update(f[_], 34962);
        const m = h.morphAttributes;
        for (const _ in m) {
            const d = m[_];
            for (let p = 0, v = d.length; p < v; p++)
                e.update(d[p], 34962)
        }
    }
    function u(h) {
        const f = []
          , m = h.index
          , _ = h.attributes.position;
        let d = 0;
        if (m !== null) {
            const x = m.array;
            d = m.version;
            for (let S = 0, M = x.length; S < M; S += 3) {
                const T = x[S + 0]
                  , L = x[S + 1]
                  , P = x[S + 2];
                f.push(T, L, L, P, P, T)
            }
        } else {
            const x = _.array;
            d = _.version;
            for (let S = 0, M = x.length / 3 - 1; S < M; S += 3) {
                const T = S + 0
                  , L = S + 1
                  , P = S + 2;
                f.push(T, L, L, P, P, T)
            }
        }
        const p = new (jg(f) ? Qg : Zg)(f,1);
        p.version = d;
        const v = r.get(h);
        v && e.remove(v),
        r.set(h, p)
    }
    function c(h) {
        const f = r.get(h);
        if (f) {
            const m = h.index;
            m !== null && f.version < m.version && u(h)
        } else
            u(h);
        return r.get(h)
    }
    return {
        get: a,
        update: l,
        getWireframeAttribute: c
    }
}
function RS(o, e, t, n) {
    const i = n.isWebGL2;
    let r;
    function s(f) {
        r = f
    }
    let a, l;
    function u(f) {
        a = f.type,
        l = f.bytesPerElement
    }
    function c(f, m) {
        o.drawElements(r, m, a, f * l),
        t.update(m, r, 1)
    }
    function h(f, m, _) {
        if (_ === 0)
            return;
        let d, p;
        if (i)
            d = o,
            p = "drawElementsInstanced";
        else if (d = e.get("ANGLE_instanced_arrays"),
        p = "drawElementsInstancedANGLE",
        d === null) {
            console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        d[p](r, m, a, f * l, _),
        t.update(m, r, _)
    }
    this.setMode = s,
    this.setIndex = u,
    this.render = c,
    this.renderInstances = h
}
function PS(o) {
    const e = {
        geometries: 0,
        textures: 0
    }
      , t = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function n(r, s, a) {
        switch (t.calls++,
        s) {
        case 4:
            t.triangles += a * (r / 3);
            break;
        case 1:
            t.lines += a * (r / 2);
            break;
        case 3:
            t.lines += a * (r - 1);
            break;
        case 2:
            t.lines += a * r;
            break;
        case 0:
            t.points += a * r;
            break;
        default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", s);
            break
        }
    }
    function i() {
        t.frame++,
        t.calls = 0,
        t.triangles = 0,
        t.points = 0,
        t.lines = 0
    }
    return {
        memory: e,
        render: t,
        programs: null,
        autoReset: !0,
        reset: i,
        update: n
    }
}
function IS(o, e) {
    return o[0] - e[0]
}
function FS(o, e) {
    return Math.abs(e[1]) - Math.abs(o[1])
}
function OS(o, e, t) {
    const n = {}
      , i = new Float32Array(8)
      , r = new WeakMap
      , s = new ct
      , a = [];
    for (let u = 0; u < 8; u++)
        a[u] = [u, 0];
    function l(u, c, h, f) {
        const m = u.morphTargetInfluences;
        if (e.isWebGL2 === !0) {
            const _ = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color
              , d = _ !== void 0 ? _.length : 0;
            let p = r.get(c);
            if (p === void 0 || p.count !== d) {
                let E = function() {
                    g.dispose(),
                    r.delete(c),
                    c.removeEventListener("dispose", E)
                };
                p !== void 0 && p.texture.dispose();
                const S = c.morphAttributes.position !== void 0
                  , M = c.morphAttributes.normal !== void 0
                  , T = c.morphAttributes.color !== void 0
                  , L = c.morphAttributes.position || []
                  , P = c.morphAttributes.normal || []
                  , A = c.morphAttributes.color || [];
                let C = 0;
                S === !0 && (C = 1),
                M === !0 && (C = 2),
                T === !0 && (C = 3);
                let N = c.attributes.position.count * C
                  , G = 1;
                N > e.maxTextureSize && (G = Math.ceil(N / e.maxTextureSize),
                N = e.maxTextureSize);
                const q = new Float32Array(N * G * 4 * d)
                  , g = new Kg(q,N,G,d);
                g.type = Qn,
                g.needsUpdate = !0;
                const w = C * 4;
                for (let R = 0; R < d; R++) {
                    const z = L[R]
                      , b = P[R]
                      , y = A[R]
                      , D = N * G * 4 * R;
                    for (let I = 0; I < z.count; I++) {
                        const F = I * w;
                        S === !0 && (s.fromBufferAttribute(z, I),
                        q[D + F + 0] = s.x,
                        q[D + F + 1] = s.y,
                        q[D + F + 2] = s.z,
                        q[D + F + 3] = 0),
                        M === !0 && (s.fromBufferAttribute(b, I),
                        q[D + F + 4] = s.x,
                        q[D + F + 5] = s.y,
                        q[D + F + 6] = s.z,
                        q[D + F + 7] = 0),
                        T === !0 && (s.fromBufferAttribute(y, I),
                        q[D + F + 8] = s.x,
                        q[D + F + 9] = s.y,
                        q[D + F + 10] = s.z,
                        q[D + F + 11] = y.itemSize === 4 ? s.w : 1)
                    }
                }
                p = {
                    count: d,
                    texture: g,
                    size: new Ze(N,G)
                },
                r.set(c, p),
                c.addEventListener("dispose", E)
            }
            let v = 0;
            for (let S = 0; S < m.length; S++)
                v += m[S];
            const x = c.morphTargetsRelative ? 1 : 1 - v;
            f.getUniforms().setValue(o, "morphTargetBaseInfluence", x),
            f.getUniforms().setValue(o, "morphTargetInfluences", m),
            f.getUniforms().setValue(o, "morphTargetsTexture", p.texture, t),
            f.getUniforms().setValue(o, "morphTargetsTextureSize", p.size)
        } else {
            const _ = m === void 0 ? 0 : m.length;
            let d = n[c.id];
            if (d === void 0 || d.length !== _) {
                d = [];
                for (let M = 0; M < _; M++)
                    d[M] = [M, 0];
                n[c.id] = d
            }
            for (let M = 0; M < _; M++) {
                const T = d[M];
                T[0] = M,
                T[1] = m[M]
            }
            d.sort(FS);
            for (let M = 0; M < 8; M++)
                M < _ && d[M][1] ? (a[M][0] = d[M][0],
                a[M][1] = d[M][1]) : (a[M][0] = Number.MAX_SAFE_INTEGER,
                a[M][1] = 0);
            a.sort(IS);
            const p = c.morphAttributes.position
              , v = c.morphAttributes.normal;
            let x = 0;
            for (let M = 0; M < 8; M++) {
                const T = a[M]
                  , L = T[0]
                  , P = T[1];
                L !== Number.MAX_SAFE_INTEGER && P ? (p && c.getAttribute("morphTarget" + M) !== p[L] && c.setAttribute("morphTarget" + M, p[L]),
                v && c.getAttribute("morphNormal" + M) !== v[L] && c.setAttribute("morphNormal" + M, v[L]),
                i[M] = P,
                x += P) : (p && c.hasAttribute("morphTarget" + M) === !0 && c.deleteAttribute("morphTarget" + M),
                v && c.hasAttribute("morphNormal" + M) === !0 && c.deleteAttribute("morphNormal" + M),
                i[M] = 0)
            }
            const S = c.morphTargetsRelative ? 1 : 1 - x;
            f.getUniforms().setValue(o, "morphTargetBaseInfluence", S),
            f.getUniforms().setValue(o, "morphTargetInfluences", i)
        }
    }
    return {
        update: l
    }
}
function NS(o, e, t, n) {
    let i = new WeakMap;
    function r(l) {
        const u = n.render.frame
          , c = l.geometry
          , h = e.get(l, c);
        return i.get(h) !== u && (e.update(h),
        i.set(h, u)),
        l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a),
        t.update(l.instanceMatrix, 34962),
        l.instanceColor !== null && t.update(l.instanceColor, 34962)),
        h
    }
    function s() {
        i = new WeakMap
    }
    function a(l) {
        const u = l.target;
        u.removeEventListener("dispose", a),
        t.remove(u.instanceMatrix),
        u.instanceColor !== null && t.remove(u.instanceColor)
    }
    return {
        update: r,
        dispose: s
    }
}
const n_ = new tn
  , i_ = new Kg
  , r_ = new Sb
  , s_ = new e_
  , kd = []
  , zd = []
  , Ud = new Float32Array(16)
  , Bd = new Float32Array(9)
  , Vd = new Float32Array(4);
function uo(o, e, t) {
    const n = o[0];
    if (n <= 0 || n > 0)
        return o;
    const i = e * t;
    let r = kd[i];
    if (r === void 0 && (r = new Float32Array(i),
    kd[i] = r),
    e !== 0) {
        n.toArray(r, 0);
        for (let s = 1, a = 0; s !== e; ++s)
            a += t,
            o[s].toArray(r, a)
    }
    return r
}
function nn(o, e) {
    if (o.length !== e.length)
        return !1;
    for (let t = 0, n = o.length; t < n; t++)
        if (o[t] !== e[t])
            return !1;
    return !0
}
function rn(o, e) {
    for (let t = 0, n = e.length; t < n; t++)
        o[t] = e[t]
}
function ql(o, e) {
    let t = zd[e];
    t === void 0 && (t = new Int32Array(e),
    zd[e] = t);
    for (let n = 0; n !== e; ++n)
        t[n] = o.allocateTextureUnit();
    return t
}
function kS(o, e) {
    const t = this.cache;
    t[0] !== e && (o.uniform1f(this.addr, e),
    t[0] = e)
}
function zS(o, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (o.uniform2f(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (nn(t, e))
            return;
        o.uniform2fv(this.addr, e),
        rn(t, e)
    }
}
function US(o, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (o.uniform3f(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else if (e.r !== void 0)
        (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (o.uniform3f(this.addr, e.r, e.g, e.b),
        t[0] = e.r,
        t[1] = e.g,
        t[2] = e.b);
    else {
        if (nn(t, e))
            return;
        o.uniform3fv(this.addr, e),
        rn(t, e)
    }
}
function BS(o, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (o.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (nn(t, e))
            return;
        o.uniform4fv(this.addr, e),
        rn(t, e)
    }
}
function VS(o, e) {
    const t = this.cache
      , n = e.elements;
    if (n === void 0) {
        if (nn(t, e))
            return;
        o.uniformMatrix2fv(this.addr, !1, e),
        rn(t, e)
    } else {
        if (nn(t, n))
            return;
        Vd.set(n),
        o.uniformMatrix2fv(this.addr, !1, Vd),
        rn(t, n)
    }
}
function GS(o, e) {
    const t = this.cache
      , n = e.elements;
    if (n === void 0) {
        if (nn(t, e))
            return;
        o.uniformMatrix3fv(this.addr, !1, e),
        rn(t, e)
    } else {
        if (nn(t, n))
            return;
        Bd.set(n),
        o.uniformMatrix3fv(this.addr, !1, Bd),
        rn(t, n)
    }
}
function HS(o, e) {
    const t = this.cache
      , n = e.elements;
    if (n === void 0) {
        if (nn(t, e))
            return;
        o.uniformMatrix4fv(this.addr, !1, e),
        rn(t, e)
    } else {
        if (nn(t, n))
            return;
        Ud.set(n),
        o.uniformMatrix4fv(this.addr, !1, Ud),
        rn(t, n)
    }
}
function WS(o, e) {
    const t = this.cache;
    t[0] !== e && (o.uniform1i(this.addr, e),
    t[0] = e)
}
function jS(o, e) {
    const t = this.cache;
    nn(t, e) || (o.uniform2iv(this.addr, e),
    rn(t, e))
}
function qS(o, e) {
    const t = this.cache;
    nn(t, e) || (o.uniform3iv(this.addr, e),
    rn(t, e))
}
function XS(o, e) {
    const t = this.cache;
    nn(t, e) || (o.uniform4iv(this.addr, e),
    rn(t, e))
}
function YS(o, e) {
    const t = this.cache;
    t[0] !== e && (o.uniform1ui(this.addr, e),
    t[0] = e)
}
function KS(o, e) {
    const t = this.cache;
    nn(t, e) || (o.uniform2uiv(this.addr, e),
    rn(t, e))
}
function $S(o, e) {
    const t = this.cache;
    nn(t, e) || (o.uniform3uiv(this.addr, e),
    rn(t, e))
}
function ZS(o, e) {
    const t = this.cache;
    nn(t, e) || (o.uniform4uiv(this.addr, e),
    rn(t, e))
}
function QS(o, e, t) {
    const n = this.cache
      , i = t.allocateTextureUnit();
    n[0] !== i && (o.uniform1i(this.addr, i),
    n[0] = i),
    t.setTexture2D(e || n_, i)
}
function JS(o, e, t) {
    const n = this.cache
      , i = t.allocateTextureUnit();
    n[0] !== i && (o.uniform1i(this.addr, i),
    n[0] = i),
    t.setTexture3D(e || r_, i)
}
function e1(o, e, t) {
    const n = this.cache
      , i = t.allocateTextureUnit();
    n[0] !== i && (o.uniform1i(this.addr, i),
    n[0] = i),
    t.setTextureCube(e || s_, i)
}
function t1(o, e, t) {
    const n = this.cache
      , i = t.allocateTextureUnit();
    n[0] !== i && (o.uniform1i(this.addr, i),
    n[0] = i),
    t.setTexture2DArray(e || i_, i)
}
function n1(o) {
    switch (o) {
    case 5126:
        return kS;
    case 35664:
        return zS;
    case 35665:
        return US;
    case 35666:
        return BS;
    case 35674:
        return VS;
    case 35675:
        return GS;
    case 35676:
        return HS;
    case 5124:
    case 35670:
        return WS;
    case 35667:
    case 35671:
        return jS;
    case 35668:
    case 35672:
        return qS;
    case 35669:
    case 35673:
        return XS;
    case 5125:
        return YS;
    case 36294:
        return KS;
    case 36295:
        return $S;
    case 36296:
        return ZS;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return QS;
    case 35679:
    case 36299:
    case 36307:
        return JS;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return e1;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return t1
    }
}
function i1(o, e) {
    o.uniform1fv(this.addr, e)
}
function r1(o, e) {
    const t = uo(e, this.size, 2);
    o.uniform2fv(this.addr, t)
}
function s1(o, e) {
    const t = uo(e, this.size, 3);
    o.uniform3fv(this.addr, t)
}
function o1(o, e) {
    const t = uo(e, this.size, 4);
    o.uniform4fv(this.addr, t)
}
function a1(o, e) {
    const t = uo(e, this.size, 4);
    o.uniformMatrix2fv(this.addr, !1, t)
}
function l1(o, e) {
    const t = uo(e, this.size, 9);
    o.uniformMatrix3fv(this.addr, !1, t)
}
function u1(o, e) {
    const t = uo(e, this.size, 16);
    o.uniformMatrix4fv(this.addr, !1, t)
}
function c1(o, e) {
    o.uniform1iv(this.addr, e)
}
function h1(o, e) {
    o.uniform2iv(this.addr, e)
}
function f1(o, e) {
    o.uniform3iv(this.addr, e)
}
function d1(o, e) {
    o.uniform4iv(this.addr, e)
}
function p1(o, e) {
    o.uniform1uiv(this.addr, e)
}
function m1(o, e) {
    o.uniform2uiv(this.addr, e)
}
function g1(o, e) {
    o.uniform3uiv(this.addr, e)
}
function _1(o, e) {
    o.uniform4uiv(this.addr, e)
}
function v1(o, e, t) {
    const n = e.length
      , i = ql(t, n);
    o.uniform1iv(this.addr, i);
    for (let r = 0; r !== n; ++r)
        t.setTexture2D(e[r] || n_, i[r])
}
function x1(o, e, t) {
    const n = e.length
      , i = ql(t, n);
    o.uniform1iv(this.addr, i);
    for (let r = 0; r !== n; ++r)
        t.setTexture3D(e[r] || r_, i[r])
}
function y1(o, e, t) {
    const n = e.length
      , i = ql(t, n);
    o.uniform1iv(this.addr, i);
    for (let r = 0; r !== n; ++r)
        t.setTextureCube(e[r] || s_, i[r])
}
function b1(o, e, t) {
    const n = e.length
      , i = ql(t, n);
    o.uniform1iv(this.addr, i);
    for (let r = 0; r !== n; ++r)
        t.setTexture2DArray(e[r] || i_, i[r])
}
function w1(o) {
    switch (o) {
    case 5126:
        return i1;
    case 35664:
        return r1;
    case 35665:
        return s1;
    case 35666:
        return o1;
    case 35674:
        return a1;
    case 35675:
        return l1;
    case 35676:
        return u1;
    case 5124:
    case 35670:
        return c1;
    case 35667:
    case 35671:
        return h1;
    case 35668:
    case 35672:
        return f1;
    case 35669:
    case 35673:
        return d1;
    case 5125:
        return p1;
    case 36294:
        return m1;
    case 36295:
        return g1;
    case 36296:
        return _1;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return v1;
    case 35679:
    case 36299:
    case 36307:
        return x1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return y1;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return b1
    }
}
class M1 {
    constructor(e, t, n) {
        this.id = e,
        this.addr = n,
        this.cache = [],
        this.setValue = n1(t.type)
    }
}
class S1 {
    constructor(e, t, n) {
        this.id = e,
        this.addr = n,
        this.cache = [],
        this.size = t.size,
        this.setValue = w1(t.type)
    }
}
class D1 {
    constructor(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    setValue(e, t, n) {
        const i = this.seq;
        for (let r = 0, s = i.length; r !== s; ++r) {
            const a = i[r];
            a.setValue(e, t[a.id], n)
        }
    }
}
const Xu = /(\w+)(\])?(\[|\.)?/g;
function Gd(o, e) {
    o.seq.push(e),
    o.map[e.id] = e
}
function T1(o, e, t) {
    const n = o.name
      , i = n.length;
    for (Xu.lastIndex = 0; ; ) {
        const r = Xu.exec(n)
          , s = Xu.lastIndex;
        let a = r[1];
        const l = r[2] === "]"
          , u = r[3];
        if (l && (a = a | 0),
        u === void 0 || u === "[" && s + 2 === i) {
            Gd(t, u === void 0 ? new M1(a,o,e) : new S1(a,o,e));
            break
        } else {
            let h = t.map[a];
            h === void 0 && (h = new D1(a),
            Gd(t, h)),
            t = h
        }
    }
}
class wl {
    constructor(e, t) {
        this.seq = [],
        this.map = {};
        const n = e.getProgramParameter(t, 35718);
        for (let i = 0; i < n; ++i) {
            const r = e.getActiveUniform(t, i)
              , s = e.getUniformLocation(t, r.name);
            T1(r, s, this)
        }
    }
    setValue(e, t, n, i) {
        const r = this.map[t];
        r !== void 0 && r.setValue(e, n, i)
    }
    setOptional(e, t, n) {
        const i = t[n];
        i !== void 0 && this.setValue(e, n, i)
    }
    static upload(e, t, n, i) {
        for (let r = 0, s = t.length; r !== s; ++r) {
            const a = t[r]
              , l = n[a.id];
            l.needsUpdate !== !1 && a.setValue(e, l.value, i)
        }
    }
    static seqWithValue(e, t) {
        const n = [];
        for (let i = 0, r = e.length; i !== r; ++i) {
            const s = e[i];
            s.id in t && n.push(s)
        }
        return n
    }
}
function Hd(o, e, t) {
    const n = o.createShader(e);
    return o.shaderSource(n, t),
    o.compileShader(n),
    n
}
let E1 = 0;
function A1(o, e) {
    const t = o.split(`
`)
      , n = []
      , i = Math.max(e - 6, 0)
      , r = Math.min(e + 6, t.length);
    for (let s = i; s < r; s++) {
        const a = s + 1;
        n.push(`${a === e ? ">" : " "} ${a}: ${t[s]}`)
    }
    return n.join(`
`)
}
function C1(o) {
    switch (o) {
    case pr:
        return ["Linear", "( value )"];
    case it:
        return ["sRGB", "( value )"];
    default:
        return console.warn("THREE.WebGLProgram: Unsupported encoding:", o),
        ["Linear", "( value )"]
    }
}
function Wd(o, e, t) {
    const n = o.getShaderParameter(e, 35713)
      , i = o.getShaderInfoLog(e).trim();
    if (n && i === "")
        return "";
    const r = /ERROR: 0:(\d+)/.exec(i);
    if (r) {
        const s = parseInt(r[1]);
        return t.toUpperCase() + `

` + i + `

` + A1(o.getShaderSource(e), s)
    } else
        return i
}
function L1(o, e) {
    const t = C1(e);
    return "vec4 " + o + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }"
}
function R1(o, e) {
    let t;
    switch (e) {
    case ky:
        t = "Linear";
        break;
    case zy:
        t = "Reinhard";
        break;
    case Uy:
        t = "OptimizedCineon";
        break;
    case By:
        t = "ACESFilmic";
        break;
    case Vy:
        t = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        t = "Linear"
    }
    return "vec3 " + o + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
}
function P1(o) {
    return [o.extensionDerivatives || !!o.envMapCubeUVHeight || o.bumpMap || o.tangentSpaceNormalMap || o.clearcoatNormalMap || o.flatShading || o.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (o.extensionFragDepth || o.logarithmicDepthBuffer) && o.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", o.extensionDrawBuffers && o.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (o.extensionShaderTextureLOD || o.envMap || o.transmission) && o.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Po).join(`
`)
}
function I1(o) {
    const e = [];
    for (const t in o) {
        const n = o[t];
        n !== !1 && e.push("#define " + t + " " + n)
    }
    return e.join(`
`)
}
function F1(o, e) {
    const t = {}
      , n = o.getProgramParameter(e, 35721);
    for (let i = 0; i < n; i++) {
        const r = o.getActiveAttrib(e, i)
          , s = r.name;
        let a = 1;
        r.type === 35674 && (a = 2),
        r.type === 35675 && (a = 3),
        r.type === 35676 && (a = 4),
        t[s] = {
            type: r.type,
            location: o.getAttribLocation(e, s),
            locationSize: a
        }
    }
    return t
}
function Po(o) {
    return o !== ""
}
function jd(o, e) {
    const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return o.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function qd(o, e) {
    return o.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const O1 = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Ic(o) {
    return o.replace(O1, N1)
}
function N1(o, e) {
    const t = We[e];
    if (t === void 0)
        throw new Error("Can not resolve #include <" + e + ">");
    return Ic(t)
}
const k1 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Xd(o) {
    return o.replace(k1, z1)
}
function z1(o, e, t, n) {
    let i = "";
    for (let r = parseInt(e); r < parseInt(t); r++)
        i += n.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
    return i
}
function Yd(o) {
    let e = "precision " + o.precision + ` float;
precision ` + o.precision + " int;";
    return o.precision === "highp" ? e += `
#define HIGH_PRECISION` : o.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : o.precision === "lowp" && (e += `
#define LOW_PRECISION`),
    e
}
function U1(o) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return o.shadowMapType === Ng ? e = "SHADOWMAP_TYPE_PCF" : o.shadowMapType === my ? e = "SHADOWMAP_TYPE_PCF_SOFT" : o.shadowMapType === Ro && (e = "SHADOWMAP_TYPE_VSM"),
    e
}
function B1(o) {
    let e = "ENVMAP_TYPE_CUBE";
    if (o.envMap)
        switch (o.envMapMode) {
        case Js:
        case eo:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case jl:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
        }
    return e
}
function V1(o) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (o.envMap)
        switch (o.envMapMode) {
        case eo:
            e = "ENVMAP_MODE_REFRACTION";
            break
        }
    return e
}
function G1(o) {
    let e = "ENVMAP_BLENDING_NONE";
    if (o.envMap)
        switch (o.combine) {
        case Ug:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case Oy:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case Ny:
            e = "ENVMAP_BLENDING_ADD";
            break
        }
    return e
}
function H1(o) {
    const e = o.envMapCubeUVHeight;
    if (e === null)
        return null;
    const t = Math.log2(e) - 2
      , n = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
        texelHeight: n,
        maxMip: t
    }
}
function W1(o, e, t, n) {
    const i = o.getContext()
      , r = t.defines;
    let s = t.vertexShader
      , a = t.fragmentShader;
    const l = U1(t)
      , u = B1(t)
      , c = V1(t)
      , h = G1(t)
      , f = H1(t)
      , m = t.isWebGL2 ? "" : P1(t)
      , _ = I1(r)
      , d = i.createProgram();
    let p, v, x = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
    t.isRawShaderMaterial ? (p = [_].filter(Po).join(`
`),
    p.length > 0 && (p += `
`),
    v = [m, _].filter(Po).join(`
`),
    v.length > 0 && (v += `
`)) : (p = [Yd(t), "#define SHADER_NAME " + t.shaderName, _, t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + c : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.displacementMap && t.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUvs ? "#define USE_UV" : "", t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Po).join(`
`),
    v = [m, Yd(t), "#define SHADER_NAME " + t.shaderName, _, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + u : "", t.envMap ? "#define " + c : "", t.envMap ? "#define " + h : "", f ? "#define CUBEUV_TEXEL_WIDTH " + f.texelWidth : "", f ? "#define CUBEUV_TEXEL_HEIGHT " + f.texelHeight : "", f ? "#define CUBEUV_MAX_MIP " + f.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUvs ? "#define USE_UV" : "", t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== Ui ? "#define TONE_MAPPING" : "", t.toneMapping !== Ui ? We.tonemapping_pars_fragment : "", t.toneMapping !== Ui ? R1("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", We.encodings_pars_fragment, L1("linearToOutputTexel", t.outputEncoding), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(Po).join(`
`)),
    s = Ic(s),
    s = jd(s, t),
    s = qd(s, t),
    a = Ic(a),
    a = jd(a, t),
    a = qd(a, t),
    s = Xd(s),
    a = Xd(a),
    t.isWebGL2 && t.isRawShaderMaterial !== !0 && (x = `#version 300 es
`,
    p = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + p,
    v = ["#define varying in", t.glslVersion === _d ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === _d ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + v);
    const S = x + p + s
      , M = x + v + a
      , T = Hd(i, 35633, S)
      , L = Hd(i, 35632, M);
    if (i.attachShader(d, T),
    i.attachShader(d, L),
    t.index0AttributeName !== void 0 ? i.bindAttribLocation(d, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(d, 0, "position"),
    i.linkProgram(d),
    o.debug.checkShaderErrors) {
        const C = i.getProgramInfoLog(d).trim()
          , N = i.getShaderInfoLog(T).trim()
          , G = i.getShaderInfoLog(L).trim();
        let q = !0
          , g = !0;
        if (i.getProgramParameter(d, 35714) === !1) {
            q = !1;
            const w = Wd(i, T, "vertex")
              , E = Wd(i, L, "fragment");
            console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(d, 35715) + `

Program Info Log: ` + C + `
` + w + `
` + E)
        } else
            C !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", C) : (N === "" || G === "") && (g = !1);
        g && (this.diagnostics = {
            runnable: q,
            programLog: C,
            vertexShader: {
                log: N,
                prefix: p
            },
            fragmentShader: {
                log: G,
                prefix: v
            }
        })
    }
    i.deleteShader(T),
    i.deleteShader(L);
    let P;
    this.getUniforms = function() {
        return P === void 0 && (P = new wl(i,d)),
        P
    }
    ;
    let A;
    return this.getAttributes = function() {
        return A === void 0 && (A = F1(i, d)),
        A
    }
    ,
    this.destroy = function() {
        n.releaseStatesOfProgram(this),
        i.deleteProgram(d),
        this.program = void 0
    }
    ,
    this.name = t.shaderName,
    this.id = E1++,
    this.cacheKey = e,
    this.usedTimes = 1,
    this.program = d,
    this.vertexShader = T,
    this.fragmentShader = L,
    this
}
let j1 = 0;
class q1 {
    constructor() {
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update(e) {
        const t = e.vertexShader
          , n = e.fragmentShader
          , i = this._getShaderStage(t)
          , r = this._getShaderStage(n)
          , s = this._getShaderCacheForMaterial(e);
        return s.has(i) === !1 && (s.add(i),
        i.usedTimes++),
        s.has(r) === !1 && (s.add(r),
        r.usedTimes++),
        this
    }
    remove(e) {
        const t = this.materialCache.get(e);
        for (const n of t)
            n.usedTimes--,
            n.usedTimes === 0 && this.shaderCache.delete(n.code);
        return this.materialCache.delete(e),
        this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        let n = t.get(e);
        return n === void 0 && (n = new Set,
        t.set(e, n)),
        n
    }
    _getShaderStage(e) {
        const t = this.shaderCache;
        let n = t.get(e);
        return n === void 0 && (n = new X1(e),
        t.set(e, n)),
        n
    }
}
class X1 {
    constructor(e) {
        this.id = j1++,
        this.code = e,
        this.usedTimes = 0
    }
}
function Y1(o, e, t, n, i, r, s) {
    const a = new $g
      , l = new q1
      , u = []
      , c = i.isWebGL2
      , h = i.logarithmicDepthBuffer
      , f = i.vertexTextures;
    let m = i.precision;
    const _ = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function d(A, C, N, G, q) {
        const g = G.fog
          , w = q.geometry
          , E = A.isMeshStandardMaterial ? G.environment : null
          , R = (A.isMeshStandardMaterial ? t : e).get(A.envMap || E)
          , z = !!R && R.mapping === jl ? R.image.height : null
          , b = _[A.type];
        A.precision !== null && (m = i.getMaxPrecision(A.precision),
        m !== A.precision && console.warn("THREE.WebGLProgram.getParameters:", A.precision, "not supported, using", m, "instead."));
        const y = w.morphAttributes.position || w.morphAttributes.normal || w.morphAttributes.color
          , D = y !== void 0 ? y.length : 0;
        let I = 0;
        w.morphAttributes.position !== void 0 && (I = 1),
        w.morphAttributes.normal !== void 0 && (I = 2),
        w.morphAttributes.color !== void 0 && (I = 3);
        let F, B, H, W;
        if (b) {
            const ce = si[b];
            F = ce.vertexShader,
            B = ce.fragmentShader
        } else
            F = A.vertexShader,
            B = A.fragmentShader,
            l.update(A),
            H = l.getVertexShaderID(A),
            W = l.getFragmentShaderID(A);
        const U = o.getRenderTarget()
          , K = A.alphaTest > 0
          , te = A.clearcoat > 0
          , he = A.iridescence > 0;
        return {
            isWebGL2: c,
            shaderID: b,
            shaderName: A.type,
            vertexShader: F,
            fragmentShader: B,
            defines: A.defines,
            customVertexShaderID: H,
            customFragmentShaderID: W,
            isRawShaderMaterial: A.isRawShaderMaterial === !0,
            glslVersion: A.glslVersion,
            precision: m,
            instancing: q.isInstancedMesh === !0,
            instancingColor: q.isInstancedMesh === !0 && q.instanceColor !== null,
            supportsVertexTextures: f,
            outputEncoding: U === null ? o.outputEncoding : U.isXRRenderTarget === !0 ? U.texture.encoding : pr,
            map: !!A.map,
            matcap: !!A.matcap,
            envMap: !!R,
            envMapMode: R && R.mapping,
            envMapCubeUVHeight: z,
            lightMap: !!A.lightMap,
            aoMap: !!A.aoMap,
            emissiveMap: !!A.emissiveMap,
            bumpMap: !!A.bumpMap,
            normalMap: !!A.normalMap,
            objectSpaceNormalMap: A.normalMapType === ab,
            tangentSpaceNormalMap: A.normalMapType === fh,
            decodeVideoTexture: !!A.map && A.map.isVideoTexture === !0 && A.map.encoding === it,
            clearcoat: te,
            clearcoatMap: te && !!A.clearcoatMap,
            clearcoatRoughnessMap: te && !!A.clearcoatRoughnessMap,
            clearcoatNormalMap: te && !!A.clearcoatNormalMap,
            iridescence: he,
            iridescenceMap: he && !!A.iridescenceMap,
            iridescenceThicknessMap: he && !!A.iridescenceThicknessMap,
            displacementMap: !!A.displacementMap,
            roughnessMap: !!A.roughnessMap,
            metalnessMap: !!A.metalnessMap,
            specularMap: !!A.specularMap,
            specularIntensityMap: !!A.specularIntensityMap,
            specularColorMap: !!A.specularColorMap,
            opaque: A.transparent === !1 && A.blending === Gs,
            alphaMap: !!A.alphaMap,
            alphaTest: K,
            gradientMap: !!A.gradientMap,
            sheen: A.sheen > 0,
            sheenColorMap: !!A.sheenColorMap,
            sheenRoughnessMap: !!A.sheenRoughnessMap,
            transmission: A.transmission > 0,
            transmissionMap: !!A.transmissionMap,
            thicknessMap: !!A.thicknessMap,
            combine: A.combine,
            vertexTangents: !!A.normalMap && !!w.attributes.tangent,
            vertexColors: A.vertexColors,
            vertexAlphas: A.vertexColors === !0 && !!w.attributes.color && w.attributes.color.itemSize === 4,
            vertexUvs: !!A.map || !!A.bumpMap || !!A.normalMap || !!A.specularMap || !!A.alphaMap || !!A.emissiveMap || !!A.roughnessMap || !!A.metalnessMap || !!A.clearcoatMap || !!A.clearcoatRoughnessMap || !!A.clearcoatNormalMap || !!A.iridescenceMap || !!A.iridescenceThicknessMap || !!A.displacementMap || !!A.transmissionMap || !!A.thicknessMap || !!A.specularIntensityMap || !!A.specularColorMap || !!A.sheenColorMap || !!A.sheenRoughnessMap,
            uvsVertexOnly: !(!!A.map || !!A.bumpMap || !!A.normalMap || !!A.specularMap || !!A.alphaMap || !!A.emissiveMap || !!A.roughnessMap || !!A.metalnessMap || !!A.clearcoatNormalMap || !!A.iridescenceMap || !!A.iridescenceThicknessMap || A.transmission > 0 || !!A.transmissionMap || !!A.thicknessMap || !!A.specularIntensityMap || !!A.specularColorMap || A.sheen > 0 || !!A.sheenColorMap || !!A.sheenRoughnessMap) && !!A.displacementMap,
            fog: !!g,
            useFog: A.fog === !0,
            fogExp2: g && g.isFogExp2,
            flatShading: !!A.flatShading,
            sizeAttenuation: A.sizeAttenuation,
            logarithmicDepthBuffer: h,
            skinning: q.isSkinnedMesh === !0,
            morphTargets: w.morphAttributes.position !== void 0,
            morphNormals: w.morphAttributes.normal !== void 0,
            morphColors: w.morphAttributes.color !== void 0,
            morphTargetsCount: D,
            morphTextureStride: I,
            numDirLights: C.directional.length,
            numPointLights: C.point.length,
            numSpotLights: C.spot.length,
            numSpotLightMaps: C.spotLightMap.length,
            numRectAreaLights: C.rectArea.length,
            numHemiLights: C.hemi.length,
            numDirLightShadows: C.directionalShadowMap.length,
            numPointLightShadows: C.pointShadowMap.length,
            numSpotLightShadows: C.spotShadowMap.length,
            numSpotLightShadowsWithMaps: C.numSpotLightShadowsWithMaps,
            numClippingPlanes: s.numPlanes,
            numClipIntersection: s.numIntersection,
            dithering: A.dithering,
            shadowMapEnabled: o.shadowMap.enabled && N.length > 0,
            shadowMapType: o.shadowMap.type,
            toneMapping: A.toneMapped ? o.toneMapping : Ui,
            physicallyCorrectLights: o.physicallyCorrectLights,
            premultipliedAlpha: A.premultipliedAlpha,
            doubleSided: A.side === Oi,
            flipSided: A.side === Wn,
            useDepthPacking: !!A.depthPacking,
            depthPacking: A.depthPacking || 0,
            index0AttributeName: A.index0AttributeName,
            extensionDerivatives: A.extensions && A.extensions.derivatives,
            extensionFragDepth: A.extensions && A.extensions.fragDepth,
            extensionDrawBuffers: A.extensions && A.extensions.drawBuffers,
            extensionShaderTextureLOD: A.extensions && A.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: c || n.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: c || n.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod: c || n.has("EXT_shader_texture_lod"),
            customProgramCacheKey: A.customProgramCacheKey()
        }
    }
    function p(A) {
        const C = [];
        if (A.shaderID ? C.push(A.shaderID) : (C.push(A.customVertexShaderID),
        C.push(A.customFragmentShaderID)),
        A.defines !== void 0)
            for (const N in A.defines)
                C.push(N),
                C.push(A.defines[N]);
        return A.isRawShaderMaterial === !1 && (v(C, A),
        x(C, A),
        C.push(o.outputEncoding)),
        C.push(A.customProgramCacheKey),
        C.join()
    }
    function v(A, C) {
        A.push(C.precision),
        A.push(C.outputEncoding),
        A.push(C.envMapMode),
        A.push(C.envMapCubeUVHeight),
        A.push(C.combine),
        A.push(C.vertexUvs),
        A.push(C.fogExp2),
        A.push(C.sizeAttenuation),
        A.push(C.morphTargetsCount),
        A.push(C.morphAttributeCount),
        A.push(C.numDirLights),
        A.push(C.numPointLights),
        A.push(C.numSpotLights),
        A.push(C.numSpotLightMaps),
        A.push(C.numHemiLights),
        A.push(C.numRectAreaLights),
        A.push(C.numDirLightShadows),
        A.push(C.numPointLightShadows),
        A.push(C.numSpotLightShadows),
        A.push(C.numSpotLightShadowsWithMaps),
        A.push(C.shadowMapType),
        A.push(C.toneMapping),
        A.push(C.numClippingPlanes),
        A.push(C.numClipIntersection),
        A.push(C.depthPacking)
    }
    function x(A, C) {
        a.disableAll(),
        C.isWebGL2 && a.enable(0),
        C.supportsVertexTextures && a.enable(1),
        C.instancing && a.enable(2),
        C.instancingColor && a.enable(3),
        C.map && a.enable(4),
        C.matcap && a.enable(5),
        C.envMap && a.enable(6),
        C.lightMap && a.enable(7),
        C.aoMap && a.enable(8),
        C.emissiveMap && a.enable(9),
        C.bumpMap && a.enable(10),
        C.normalMap && a.enable(11),
        C.objectSpaceNormalMap && a.enable(12),
        C.tangentSpaceNormalMap && a.enable(13),
        C.clearcoat && a.enable(14),
        C.clearcoatMap && a.enable(15),
        C.clearcoatRoughnessMap && a.enable(16),
        C.clearcoatNormalMap && a.enable(17),
        C.iridescence && a.enable(18),
        C.iridescenceMap && a.enable(19),
        C.iridescenceThicknessMap && a.enable(20),
        C.displacementMap && a.enable(21),
        C.specularMap && a.enable(22),
        C.roughnessMap && a.enable(23),
        C.metalnessMap && a.enable(24),
        C.gradientMap && a.enable(25),
        C.alphaMap && a.enable(26),
        C.alphaTest && a.enable(27),
        C.vertexColors && a.enable(28),
        C.vertexAlphas && a.enable(29),
        C.vertexUvs && a.enable(30),
        C.vertexTangents && a.enable(31),
        C.uvsVertexOnly && a.enable(32),
        A.push(a.mask),
        a.disableAll(),
        C.fog && a.enable(0),
        C.useFog && a.enable(1),
        C.flatShading && a.enable(2),
        C.logarithmicDepthBuffer && a.enable(3),
        C.skinning && a.enable(4),
        C.morphTargets && a.enable(5),
        C.morphNormals && a.enable(6),
        C.morphColors && a.enable(7),
        C.premultipliedAlpha && a.enable(8),
        C.shadowMapEnabled && a.enable(9),
        C.physicallyCorrectLights && a.enable(10),
        C.doubleSided && a.enable(11),
        C.flipSided && a.enable(12),
        C.useDepthPacking && a.enable(13),
        C.dithering && a.enable(14),
        C.specularIntensityMap && a.enable(15),
        C.specularColorMap && a.enable(16),
        C.transmission && a.enable(17),
        C.transmissionMap && a.enable(18),
        C.thicknessMap && a.enable(19),
        C.sheen && a.enable(20),
        C.sheenColorMap && a.enable(21),
        C.sheenRoughnessMap && a.enable(22),
        C.decodeVideoTexture && a.enable(23),
        C.opaque && a.enable(24),
        A.push(a.mask)
    }
    function S(A) {
        const C = _[A.type];
        let N;
        if (C) {
            const G = si[C];
            N = Nb.clone(G.uniforms)
        } else
            N = A.uniforms;
        return N
    }
    function M(A, C) {
        let N;
        for (let G = 0, q = u.length; G < q; G++) {
            const g = u[G];
            if (g.cacheKey === C) {
                N = g,
                ++N.usedTimes;
                break
            }
        }
        return N === void 0 && (N = new W1(o,C,A,r),
        u.push(N)),
        N
    }
    function T(A) {
        if (--A.usedTimes === 0) {
            const C = u.indexOf(A);
            u[C] = u[u.length - 1],
            u.pop(),
            A.destroy()
        }
    }
    function L(A) {
        l.remove(A)
    }
    function P() {
        l.dispose()
    }
    return {
        getParameters: d,
        getProgramCacheKey: p,
        getUniforms: S,
        acquireProgram: M,
        releaseProgram: T,
        releaseShaderCache: L,
        programs: u,
        dispose: P
    }
}
function K1() {
    let o = new WeakMap;
    function e(r) {
        let s = o.get(r);
        return s === void 0 && (s = {},
        o.set(r, s)),
        s
    }
    function t(r) {
        o.delete(r)
    }
    function n(r, s, a) {
        o.get(r)[s] = a
    }
    function i() {
        o = new WeakMap
    }
    return {
        get: e,
        remove: t,
        update: n,
        dispose: i
    }
}
function $1(o, e) {
    return o.groupOrder !== e.groupOrder ? o.groupOrder - e.groupOrder : o.renderOrder !== e.renderOrder ? o.renderOrder - e.renderOrder : o.material.id !== e.material.id ? o.material.id - e.material.id : o.z !== e.z ? o.z - e.z : o.id - e.id
}
function Kd(o, e) {
    return o.groupOrder !== e.groupOrder ? o.groupOrder - e.groupOrder : o.renderOrder !== e.renderOrder ? o.renderOrder - e.renderOrder : o.z !== e.z ? e.z - o.z : o.id - e.id
}
function $d() {
    const o = [];
    let e = 0;
    const t = []
      , n = []
      , i = [];
    function r() {
        e = 0,
        t.length = 0,
        n.length = 0,
        i.length = 0
    }
    function s(h, f, m, _, d, p) {
        let v = o[e];
        return v === void 0 ? (v = {
            id: h.id,
            object: h,
            geometry: f,
            material: m,
            groupOrder: _,
            renderOrder: h.renderOrder,
            z: d,
            group: p
        },
        o[e] = v) : (v.id = h.id,
        v.object = h,
        v.geometry = f,
        v.material = m,
        v.groupOrder = _,
        v.renderOrder = h.renderOrder,
        v.z = d,
        v.group = p),
        e++,
        v
    }
    function a(h, f, m, _, d, p) {
        const v = s(h, f, m, _, d, p);
        m.transmission > 0 ? n.push(v) : m.transparent === !0 ? i.push(v) : t.push(v)
    }
    function l(h, f, m, _, d, p) {
        const v = s(h, f, m, _, d, p);
        m.transmission > 0 ? n.unshift(v) : m.transparent === !0 ? i.unshift(v) : t.unshift(v)
    }
    function u(h, f) {
        t.length > 1 && t.sort(h || $1),
        n.length > 1 && n.sort(f || Kd),
        i.length > 1 && i.sort(f || Kd)
    }
    function c() {
        for (let h = e, f = o.length; h < f; h++) {
            const m = o[h];
            if (m.id === null)
                break;
            m.id = null,
            m.object = null,
            m.geometry = null,
            m.material = null,
            m.group = null
        }
    }
    return {
        opaque: t,
        transmissive: n,
        transparent: i,
        init: r,
        push: a,
        unshift: l,
        finish: c,
        sort: u
    }
}
function Z1() {
    let o = new WeakMap;
    function e(n, i) {
        const r = o.get(n);
        let s;
        return r === void 0 ? (s = new $d,
        o.set(n, [s])) : i >= r.length ? (s = new $d,
        r.push(s)) : s = r[i],
        s
    }
    function t() {
        o = new WeakMap
    }
    return {
        get: e,
        dispose: t
    }
}
function Q1() {
    const o = {};
    return {
        get: function(e) {
            if (o[e.id] !== void 0)
                return o[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    direction: new X,
                    color: new ze
                };
                break;
            case "SpotLight":
                t = {
                    position: new X,
                    direction: new X,
                    color: new ze,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                t = {
                    position: new X,
                    color: new ze,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                t = {
                    direction: new X,
                    skyColor: new ze,
                    groundColor: new ze
                };
                break;
            case "RectAreaLight":
                t = {
                    color: new ze,
                    position: new X,
                    halfWidth: new X,
                    halfHeight: new X
                };
                break
            }
            return o[e.id] = t,
            t
        }
    }
}
function J1() {
    const o = {};
    return {
        get: function(e) {
            if (o[e.id] !== void 0)
                return o[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Ze
                };
                break;
            case "SpotLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Ze
                };
                break;
            case "PointLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Ze,
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                };
                break
            }
            return o[e.id] = t,
            t
        }
    }
}
let eD = 0;
function tD(o, e) {
    return (e.castShadow ? 2 : 0) - (o.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (o.map ? 1 : 0)
}
function nD(o, e) {
    const t = new Q1
      , n = J1()
      , i = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0
    };
    for (let c = 0; c < 9; c++)
        i.probe.push(new X);
    const r = new X
      , s = new Ke
      , a = new Ke;
    function l(c, h) {
        let f = 0
          , m = 0
          , _ = 0;
        for (let G = 0; G < 9; G++)
            i.probe[G].set(0, 0, 0);
        let d = 0
          , p = 0
          , v = 0
          , x = 0
          , S = 0
          , M = 0
          , T = 0
          , L = 0
          , P = 0
          , A = 0;
        c.sort(tD);
        const C = h !== !0 ? Math.PI : 1;
        for (let G = 0, q = c.length; G < q; G++) {
            const g = c[G]
              , w = g.color
              , E = g.intensity
              , R = g.distance
              , z = g.shadow && g.shadow.map ? g.shadow.map.texture : null;
            if (g.isAmbientLight)
                f += w.r * E * C,
                m += w.g * E * C,
                _ += w.b * E * C;
            else if (g.isLightProbe)
                for (let b = 0; b < 9; b++)
                    i.probe[b].addScaledVector(g.sh.coefficients[b], E);
            else if (g.isDirectionalLight) {
                const b = t.get(g);
                if (b.color.copy(g.color).multiplyScalar(g.intensity * C),
                g.castShadow) {
                    const y = g.shadow
                      , D = n.get(g);
                    D.shadowBias = y.bias,
                    D.shadowNormalBias = y.normalBias,
                    D.shadowRadius = y.radius,
                    D.shadowMapSize = y.mapSize,
                    i.directionalShadow[d] = D,
                    i.directionalShadowMap[d] = z,
                    i.directionalShadowMatrix[d] = g.shadow.matrix,
                    M++
                }
                i.directional[d] = b,
                d++
            } else if (g.isSpotLight) {
                const b = t.get(g);
                b.position.setFromMatrixPosition(g.matrixWorld),
                b.color.copy(w).multiplyScalar(E * C),
                b.distance = R,
                b.coneCos = Math.cos(g.angle),
                b.penumbraCos = Math.cos(g.angle * (1 - g.penumbra)),
                b.decay = g.decay,
                i.spot[v] = b;
                const y = g.shadow;
                if (g.map && (i.spotLightMap[P] = g.map,
                P++,
                y.updateMatrices(g),
                g.castShadow && A++),
                i.spotLightMatrix[v] = y.matrix,
                g.castShadow) {
                    const D = n.get(g);
                    D.shadowBias = y.bias,
                    D.shadowNormalBias = y.normalBias,
                    D.shadowRadius = y.radius,
                    D.shadowMapSize = y.mapSize,
                    i.spotShadow[v] = D,
                    i.spotShadowMap[v] = z,
                    L++
                }
                v++
            } else if (g.isRectAreaLight) {
                const b = t.get(g);
                b.color.copy(w).multiplyScalar(E),
                b.halfWidth.set(g.width * .5, 0, 0),
                b.halfHeight.set(0, g.height * .5, 0),
                i.rectArea[x] = b,
                x++
            } else if (g.isPointLight) {
                const b = t.get(g);
                if (b.color.copy(g.color).multiplyScalar(g.intensity * C),
                b.distance = g.distance,
                b.decay = g.decay,
                g.castShadow) {
                    const y = g.shadow
                      , D = n.get(g);
                    D.shadowBias = y.bias,
                    D.shadowNormalBias = y.normalBias,
                    D.shadowRadius = y.radius,
                    D.shadowMapSize = y.mapSize,
                    D.shadowCameraNear = y.camera.near,
                    D.shadowCameraFar = y.camera.far,
                    i.pointShadow[p] = D,
                    i.pointShadowMap[p] = z,
                    i.pointShadowMatrix[p] = g.shadow.matrix,
                    T++
                }
                i.point[p] = b,
                p++
            } else if (g.isHemisphereLight) {
                const b = t.get(g);
                b.skyColor.copy(g.color).multiplyScalar(E * C),
                b.groundColor.copy(g.groundColor).multiplyScalar(E * C),
                i.hemi[S] = b,
                S++
            }
        }
        x > 0 && (e.isWebGL2 || o.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = ge.LTC_FLOAT_1,
        i.rectAreaLTC2 = ge.LTC_FLOAT_2) : o.has("OES_texture_half_float_linear") === !0 ? (i.rectAreaLTC1 = ge.LTC_HALF_1,
        i.rectAreaLTC2 = ge.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
        i.ambient[0] = f,
        i.ambient[1] = m,
        i.ambient[2] = _;
        const N = i.hash;
        (N.directionalLength !== d || N.pointLength !== p || N.spotLength !== v || N.rectAreaLength !== x || N.hemiLength !== S || N.numDirectionalShadows !== M || N.numPointShadows !== T || N.numSpotShadows !== L || N.numSpotMaps !== P) && (i.directional.length = d,
        i.spot.length = v,
        i.rectArea.length = x,
        i.point.length = p,
        i.hemi.length = S,
        i.directionalShadow.length = M,
        i.directionalShadowMap.length = M,
        i.pointShadow.length = T,
        i.pointShadowMap.length = T,
        i.spotShadow.length = L,
        i.spotShadowMap.length = L,
        i.directionalShadowMatrix.length = M,
        i.pointShadowMatrix.length = T,
        i.spotLightMatrix.length = L + P - A,
        i.spotLightMap.length = P,
        i.numSpotLightShadowsWithMaps = A,
        N.directionalLength = d,
        N.pointLength = p,
        N.spotLength = v,
        N.rectAreaLength = x,
        N.hemiLength = S,
        N.numDirectionalShadows = M,
        N.numPointShadows = T,
        N.numSpotShadows = L,
        N.numSpotMaps = P,
        i.version = eD++)
    }
    function u(c, h) {
        let f = 0
          , m = 0
          , _ = 0
          , d = 0
          , p = 0;
        const v = h.matrixWorldInverse;
        for (let x = 0, S = c.length; x < S; x++) {
            const M = c[x];
            if (M.isDirectionalLight) {
                const T = i.directional[f];
                T.direction.setFromMatrixPosition(M.matrixWorld),
                r.setFromMatrixPosition(M.target.matrixWorld),
                T.direction.sub(r),
                T.direction.transformDirection(v),
                f++
            } else if (M.isSpotLight) {
                const T = i.spot[_];
                T.position.setFromMatrixPosition(M.matrixWorld),
                T.position.applyMatrix4(v),
                T.direction.setFromMatrixPosition(M.matrixWorld),
                r.setFromMatrixPosition(M.target.matrixWorld),
                T.direction.sub(r),
                T.direction.transformDirection(v),
                _++
            } else if (M.isRectAreaLight) {
                const T = i.rectArea[d];
                T.position.setFromMatrixPosition(M.matrixWorld),
                T.position.applyMatrix4(v),
                a.identity(),
                s.copy(M.matrixWorld),
                s.premultiply(v),
                a.extractRotation(s),
                T.halfWidth.set(M.width * .5, 0, 0),
                T.halfHeight.set(0, M.height * .5, 0),
                T.halfWidth.applyMatrix4(a),
                T.halfHeight.applyMatrix4(a),
                d++
            } else if (M.isPointLight) {
                const T = i.point[m];
                T.position.setFromMatrixPosition(M.matrixWorld),
                T.position.applyMatrix4(v),
                m++
            } else if (M.isHemisphereLight) {
                const T = i.hemi[p];
                T.direction.setFromMatrixPosition(M.matrixWorld),
                T.direction.transformDirection(v),
                p++
            }
        }
    }
    return {
        setup: l,
        setupView: u,
        state: i
    }
}
function Zd(o, e) {
    const t = new nD(o,e)
      , n = []
      , i = [];
    function r() {
        n.length = 0,
        i.length = 0
    }
    function s(h) {
        n.push(h)
    }
    function a(h) {
        i.push(h)
    }
    function l(h) {
        t.setup(n, h)
    }
    function u(h) {
        t.setupView(n, h)
    }
    return {
        init: r,
        state: {
            lightsArray: n,
            shadowsArray: i,
            lights: t
        },
        setupLights: l,
        setupLightsView: u,
        pushLight: s,
        pushShadow: a
    }
}
function iD(o, e) {
    let t = new WeakMap;
    function n(r, s=0) {
        const a = t.get(r);
        let l;
        return a === void 0 ? (l = new Zd(o,e),
        t.set(r, [l])) : s >= a.length ? (l = new Zd(o,e),
        a.push(l)) : l = a[s],
        l
    }
    function i() {
        t = new WeakMap
    }
    return {
        get: n,
        dispose: i
    }
}
class rD extends fi {
    constructor(e) {
        super(),
        this.isMeshDepthMaterial = !0,
        this.type = "MeshDepthMaterial",
        this.depthPacking = sb,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.setPhilosophy(e)
    }
    copy(e) {
        return super.copy(e),
        this.depthPacking = e.depthPacking,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
}
class sD extends fi {
    constructor(e) {
        super(),
        this.isMeshDistanceMaterial = !0,
        this.type = "MeshDistanceMaterial",
        this.referencePosition = new X,
        this.nearDistance = 1,
        this.farDistance = 1e3,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.setPhilosophy(e)
    }
    copy(e) {
        return super.copy(e),
        this.referencePosition.copy(e.referencePosition),
        this.nearDistance = e.nearDistance,
        this.farDistance = e.farDistance,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
}
const oD = `void main() {
	gl_Position = vec4( position, 1.0 );
}`
  , aD = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function lD(o, e, t) {
    let n = new mh;
    const i = new Ze
      , r = new Ze
      , s = new ct
      , a = new rD({
        depthPacking: ob
    })
      , l = new sD
      , u = {}
      , c = t.maxTextureSize
      , h = {
        0: Wn,
        1: Jr,
        2: Oi
    }
      , f = new mr({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new Ze
            },
            radius: {
                value: 4
            }
        },
        vertexShader: oD,
        fragmentShader: aD
    })
      , m = f.clone();
    m.defines.HORIZONTAL_PASS = 1;
    const _ = new pi;
    _.setAttribute("position", new gn(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
    const d = new Vn(_,f)
      , p = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = Ng,
    this.render = function(M, T, L) {
        if (p.enabled === !1 || p.autoUpdate === !1 && p.needsUpdate === !1 || M.length === 0)
            return;
        const P = o.getRenderTarget()
          , A = o.getActiveCubeFace()
          , C = o.getActiveMipmapLevel()
          , N = o.state;
        N.setBlending(hr),
        N.buffers.color.setClear(1, 1, 1, 1),
        N.buffers.depth.setTest(!0),
        N.setScissorTest(!1);
        for (let G = 0, q = M.length; G < q; G++) {
            const g = M[G]
              , w = g.shadow;
            if (w === void 0) {
                console.warn("THREE.WebGLShadowMap:", g, "has no shadow.");
                continue
            }
            if (w.autoUpdate === !1 && w.needsUpdate === !1)
                continue;
            i.copy(w.mapSize);
            const E = w.getFrameExtents();
            if (i.multiply(E),
            r.copy(w.mapSize),
            (i.x > c || i.y > c) && (i.x > c && (r.x = Math.floor(c / E.x),
            i.x = r.x * E.x,
            w.mapSize.x = r.x),
            i.y > c && (r.y = Math.floor(c / E.y),
            i.y = r.y * E.y,
            w.mapSize.y = r.y)),
            w.map === null) {
                const z = this.type !== Ro ? {
                    minFilter: Vt,
                    magFilter: Vt
                } : {};
                w.map = new ts(i.x,i.y,z),
                w.map.texture.name = g.name + ".shadowMap",
                w.camera.updateProjectionMatrix()
            }
            o.setRenderTarget(w.map),
            o.clear();
            const R = w.getViewportCount();
            for (let z = 0; z < R; z++) {
                const b = w.getViewport(z);
                s.set(r.x * b.x, r.y * b.y, r.x * b.z, r.y * b.w),
                N.viewport(s),
                w.updateMatrices(g, z),
                n = w.getFrustum(),
                S(T, L, w.camera, g, this.type)
            }
            w.isPointLightShadow !== !0 && this.type === Ro && v(w, L),
            w.needsUpdate = !1
        }
        p.needsUpdate = !1,
        o.setRenderTarget(P, A, C)
    }
    ;
    function v(M, T) {
        const L = e.update(d);
        f.defines.VSM_SAMPLES !== M.blurSamples && (f.defines.VSM_SAMPLES = M.blurSamples,
        m.defines.VSM_SAMPLES = M.blurSamples,
        f.needsUpdate = !0,
        m.needsUpdate = !0),
        M.mapPass === null && (M.mapPass = new ts(i.x,i.y)),
        f.uniforms.shadow_pass.value = M.map.texture,
        f.uniforms.resolution.value = M.mapSize,
        f.uniforms.radius.value = M.radius,
        o.setRenderTarget(M.mapPass),
        o.clear(),
        o.renderBufferDirect(T, null, L, f, d, null),
        m.uniforms.shadow_pass.value = M.mapPass.texture,
        m.uniforms.resolution.value = M.mapSize,
        m.uniforms.radius.value = M.radius,
        o.setRenderTarget(M.map),
        o.clear(),
        o.renderBufferDirect(T, null, L, m, d, null)
    }
    function x(M, T, L, P, A, C) {
        let N = null;
        const G = L.isPointLight === !0 ? M.customDistanceMaterial : M.customDepthMaterial;
        if (G !== void 0 ? N = G : N = L.isPointLight === !0 ? l : a,
        o.localClippingEnabled && T.clipShadows === !0 && Array.isArray(T.clippingPlanes) && T.clippingPlanes.length !== 0 || T.displacementMap && T.displacementScale !== 0 || T.alphaMap && T.alphaTest > 0) {
            const q = N.uuid
              , g = T.uuid;
            let w = u[q];
            w === void 0 && (w = {},
            u[q] = w);
            let E = w[g];
            E === void 0 && (E = N.clone(),
            w[g] = E),
            N = E
        }
        return N.visible = T.visible,
        N.wireframe = T.wireframe,
        C === Ro ? N.side = T.shadowSide !== null ? T.shadowSide : T.side : N.side = T.shadowSide !== null ? T.shadowSide : h[T.side],
        N.alphaMap = T.alphaMap,
        N.alphaTest = T.alphaTest,
        N.clipShadows = T.clipShadows,
        N.clippingPlanes = T.clippingPlanes,
        N.clipIntersection = T.clipIntersection,
        N.displacementMap = T.displacementMap,
        N.displacementScale = T.displacementScale,
        N.displacementBias = T.displacementBias,
        N.wireframeLinewidth = T.wireframeLinewidth,
        N.linewidth = T.linewidth,
        L.isPointLight === !0 && N.isMeshDistanceMaterial === !0 && (N.referencePosition.setFromMatrixPosition(L.matrixWorld),
        N.nearDistance = P,
        N.farDistance = A),
        N
    }
    function S(M, T, L, P, A) {
        if (M.visible === !1)
            return;
        if (M.layers.test(T.layers) && (M.isMesh || M.isLine || M.isPoints) && (M.castShadow || M.receiveShadow && A === Ro) && (!M.frustumCulled || n.intersectsObject(M))) {
            M.modelViewMatrix.multiplyMatrices(L.matrixWorldInverse, M.matrixWorld);
            const G = e.update(M)
              , q = M.material;
            if (Array.isArray(q)) {
                const g = G.groups;
                for (let w = 0, E = g.length; w < E; w++) {
                    const R = g[w]
                      , z = q[R.materialIndex];
                    if (z && z.visible) {
                        const b = x(M, z, P, L.near, L.far, A);
                        o.renderBufferDirect(L, null, G, b, M, R)
                    }
                }
            } else if (q.visible) {
                const g = x(M, q, P, L.near, L.far, A);
                o.renderBufferDirect(L, null, G, g, M, null)
            }
        }
        const N = M.children;
        for (let G = 0, q = N.length; G < q; G++)
            S(N[G], T, L, P, A)
    }
}
function uD(o, e, t) {
    const n = t.isWebGL2;
    function i() {
        let j = !1;
        const de = new ct;
        let Q = null;
        const pe = new ct(0,0,0,0);
        return {
            setMask: function(me) {
                Q !== me && !j && (o.colorMask(me, me, me, me),
                Q = me)
            },
            setLocked: function(me) {
                j = me
            },
            setClear: function(me, Be, ht, Je, sn) {
                sn === !0 && (me *= Je,
                Be *= Je,
                ht *= Je),
                de.set(me, Be, ht, Je),
                pe.equals(de) === !1 && (o.clearColor(me, Be, ht, Je),
                pe.copy(de))
            },
            reset: function() {
                j = !1,
                Q = null,
                pe.set(-1, 0, 0, 0)
            }
        }
    }
    function r() {
        let j = !1
          , de = null
          , Q = null
          , pe = null;
        return {
            setTest: function(me) {
                me ? K(2929) : te(2929)
            },
            setMask: function(me) {
                de !== me && !j && (o.depthMask(me),
                de = me)
            },
            setFunc: function(me) {
                if (Q !== me) {
                    if (me)
                        switch (me) {
                        case Ay:
                            o.depthFunc(512);
                            break;
                        case Cy:
                            o.depthFunc(519);
                            break;
                        case Ly:
                            o.depthFunc(513);
                            break;
                        case Dc:
                            o.depthFunc(515);
                            break;
                        case Ry:
                            o.depthFunc(514);
                            break;
                        case Py:
                            o.depthFunc(518);
                            break;
                        case Iy:
                            o.depthFunc(516);
                            break;
                        case Fy:
                            o.depthFunc(517);
                            break;
                        default:
                            o.depthFunc(515)
                        }
                    else
                        o.depthFunc(515);
                    Q = me
                }
            },
            setLocked: function(me) {
                j = me
            },
            setClear: function(me) {
                pe !== me && (o.clearDepth(me),
                pe = me)
            },
            reset: function() {
                j = !1,
                de = null,
                Q = null,
                pe = null
            }
        }
    }
    function s() {
        let j = !1
          , de = null
          , Q = null
          , pe = null
          , me = null
          , Be = null
          , ht = null
          , Je = null
          , sn = null;
        return {
            setTest: function(st) {
                j || (st ? K(2960) : te(2960))
            },
            setMask: function(st) {
                de !== st && !j && (o.stencilMask(st),
                de = st)
            },
            setFunc: function(st, Ne, se) {
                (Q !== st || pe !== Ne || me !== se) && (o.stencilFunc(st, Ne, se),
                Q = st,
                pe = Ne,
                me = se)
            },
            setOp: function(st, Ne, se) {
                (Be !== st || ht !== Ne || Je !== se) && (o.stencilOp(st, Ne, se),
                Be = st,
                ht = Ne,
                Je = se)
            },
            setLocked: function(st) {
                j = st
            },
            setClear: function(st) {
                sn !== st && (o.clearStencil(st),
                sn = st)
            },
            reset: function() {
                j = !1,
                de = null,
                Q = null,
                pe = null,
                me = null,
                Be = null,
                ht = null,
                Je = null,
                sn = null
            }
        }
    }
    const a = new i
      , l = new r
      , u = new s
      , c = new WeakMap
      , h = new WeakMap;
    let f = {}
      , m = {}
      , _ = new WeakMap
      , d = []
      , p = null
      , v = !1
      , x = null
      , S = null
      , M = null
      , T = null
      , L = null
      , P = null
      , A = null
      , C = !1
      , N = null
      , G = null
      , q = null
      , g = null
      , w = null;
    const E = o.getParameter(35661);
    let R = !1
      , z = 0;
    const b = o.getParameter(7938);
    b.indexOf("WebGL") !== -1 ? (z = parseFloat(/^WebGL (\d)/.exec(b)[1]),
    R = z >= 1) : b.indexOf("OpenGL ES") !== -1 && (z = parseFloat(/^OpenGL ES (\d)/.exec(b)[1]),
    R = z >= 2);
    let y = null
      , D = {};
    const I = o.getParameter(3088)
      , F = o.getParameter(2978)
      , B = new ct().fromArray(I)
      , H = new ct().fromArray(F);
    function W(j, de, Q) {
        const pe = new Uint8Array(4)
          , me = o.createTexture();
        o.bindTexture(j, me),
        o.texParameteri(j, 10241, 9728),
        o.texParameteri(j, 10240, 9728);
        for (let Be = 0; Be < Q; Be++)
            o.texImage2D(de + Be, 0, 6408, 1, 1, 0, 6408, 5121, pe);
        return me
    }
    const U = {};
    U[3553] = W(3553, 3553, 1),
    U[34067] = W(34067, 34069, 6),
    a.setClear(0, 0, 0, 1),
    l.setClear(1),
    u.setClear(0),
    K(2929),
    l.setFunc(Dc),
    Ue(!1),
    J(Vf),
    K(2884),
    Oe(hr);
    function K(j) {
        f[j] !== !0 && (o.enable(j),
        f[j] = !0)
    }
    function te(j) {
        f[j] !== !1 && (o.disable(j),
        f[j] = !1)
    }
    function he(j, de) {
        return m[j] !== de ? (o.bindFramebuffer(j, de),
        m[j] = de,
        n && (j === 36009 && (m[36160] = de),
        j === 36160 && (m[36009] = de)),
        !0) : !1
    }
    function ne(j, de) {
        let Q = d
          , pe = !1;
        if (j)
            if (Q = _.get(de),
            Q === void 0 && (Q = [],
            _.set(de, Q)),
            j.isWebGLMultipleRenderTargets) {
                const me = j.texture;
                if (Q.length !== me.length || Q[0] !== 36064) {
                    for (let Be = 0, ht = me.length; Be < ht; Be++)
                        Q[Be] = 36064 + Be;
                    Q.length = me.length,
                    pe = !0
                }
            } else
                Q[0] !== 36064 && (Q[0] = 36064,
                pe = !0);
        else
            Q[0] !== 1029 && (Q[0] = 1029,
            pe = !0);
        pe && (t.isWebGL2 ? o.drawBuffers(Q) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Q))
    }
    function ce(j) {
        return p !== j ? (o.useProgram(j),
        p = j,
        !0) : !1
    }
    const oe = {
        [Ls]: 32774,
        [_y]: 32778,
        [vy]: 32779
    };
    if (n)
        oe[jf] = 32775,
        oe[qf] = 32776;
    else {
        const j = e.get("EXT_blend_minmax");
        j !== null && (oe[jf] = j.MIN_EXT,
        oe[qf] = j.MAX_EXT)
    }
    const ue = {
        [xy]: 0,
        [yy]: 1,
        [by]: 768,
        [kg]: 770,
        [Ey]: 776,
        [Dy]: 774,
        [My]: 772,
        [wy]: 769,
        [zg]: 771,
        [Ty]: 775,
        [Sy]: 773
    };
    function Oe(j, de, Q, pe, me, Be, ht, Je) {
        if (j === hr) {
            v === !0 && (te(3042),
            v = !1);
            return
        }
        if (v === !1 && (K(3042),
        v = !0),
        j !== gy) {
            if (j !== x || Je !== C) {
                if ((S !== Ls || L !== Ls) && (o.blendEquation(32774),
                S = Ls,
                L = Ls),
                Je)
                    switch (j) {
                    case Gs:
                        o.blendFuncSeparate(1, 771, 1, 771);
                        break;
                    case Gf:
                        o.blendFunc(1, 1);
                        break;
                    case Hf:
                        o.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case Wf:
                        o.blendFuncSeparate(0, 768, 0, 770);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", j);
                        break
                    }
                else
                    switch (j) {
                    case Gs:
                        o.blendFuncSeparate(770, 771, 1, 771);
                        break;
                    case Gf:
                        o.blendFunc(770, 1);
                        break;
                    case Hf:
                        o.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case Wf:
                        o.blendFunc(0, 768);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", j);
                        break
                    }
                M = null,
                T = null,
                P = null,
                A = null,
                x = j,
                C = Je
            }
            return
        }
        me = me || de,
        Be = Be || Q,
        ht = ht || pe,
        (de !== S || me !== L) && (o.blendEquationSeparate(oe[de], oe[me]),
        S = de,
        L = me),
        (Q !== M || pe !== T || Be !== P || ht !== A) && (o.blendFuncSeparate(ue[Q], ue[pe], ue[Be], ue[ht]),
        M = Q,
        T = pe,
        P = Be,
        A = ht),
        x = j,
        C = null
    }
    function qe(j, de) {
        j.side === Oi ? te(2884) : K(2884);
        let Q = j.side === Wn;
        de && (Q = !Q),
        Ue(Q),
        j.blending === Gs && j.transparent === !1 ? Oe(hr) : Oe(j.blending, j.blendEquation, j.blendSrc, j.blendDst, j.blendEquationAlpha, j.blendSrcAlpha, j.blendDstAlpha, j.premultipliedAlpha),
        l.setFunc(j.depthFunc),
        l.setTest(j.depthTest),
        l.setMask(j.depthWrite),
        a.setMask(j.colorWrite);
        const pe = j.stencilWrite;
        u.setTest(pe),
        pe && (u.setMask(j.stencilWriteMask),
        u.setFunc(j.stencilFunc, j.stencilRef, j.stencilFuncMask),
        u.setOp(j.stencilFail, j.stencilZFail, j.stencilZPass)),
        ye(j.polygonOffset, j.polygonOffsetFactor, j.polygonOffsetUnits),
        j.alphaToCoverage === !0 ? K(32926) : te(32926)
    }
    function Ue(j) {
        N !== j && (j ? o.frontFace(2304) : o.frontFace(2305),
        N = j)
    }
    function J(j) {
        j !== dy ? (K(2884),
        j !== G && (j === Vf ? o.cullFace(1029) : j === py ? o.cullFace(1028) : o.cullFace(1032))) : te(2884),
        G = j
    }
    function Ve(j) {
        j !== q && (R && o.lineWidth(j),
        q = j)
    }
    function ye(j, de, Q) {
        j ? (K(32823),
        (g !== de || w !== Q) && (o.polygonOffset(de, Q),
        g = de,
        w = Q)) : te(32823)
    }
    function Ft(j) {
        j ? K(3089) : te(3089)
    }
    function Ct(j) {
        j === void 0 && (j = 33984 + E - 1),
        y !== j && (o.activeTexture(j),
        y = j)
    }
    function V(j, de) {
        y === null && Ct();
        let Q = D[y];
        Q === void 0 && (Q = {
            type: void 0,
            texture: void 0
        },
        D[y] = Q),
        (Q.type !== j || Q.texture !== de) && (o.bindTexture(j, de || U[j]),
        Q.type = j,
        Q.texture = de)
    }
    function O() {
        const j = D[y];
        j !== void 0 && j.type !== void 0 && (o.bindTexture(j.type, null),
        j.type = void 0,
        j.texture = void 0)
    }
    function re() {
        try {
            o.compressedTexImage2D.apply(o, arguments)
        } catch (j) {
            console.error("THREE.WebGLState:", j)
        }
    }
    function le() {
        try {
            o.texSubImage2D.apply(o, arguments)
        } catch (j) {
            console.error("THREE.WebGLState:", j)
        }
    }
    function ae() {
        try {
            o.texSubImage3D.apply(o, arguments)
        } catch (j) {
            console.error("THREE.WebGLState:", j)
        }
    }
    function fe() {
        try {
            o.compressedTexSubImage2D.apply(o, arguments)
        } catch (j) {
            console.error("THREE.WebGLState:", j)
        }
    }
    function Se() {
        try {
            o.texStorage2D.apply(o, arguments)
        } catch (j) {
            console.error("THREE.WebGLState:", j)
        }
    }
    function ee() {
        try {
            o.texStorage3D.apply(o, arguments)
        } catch (j) {
            console.error("THREE.WebGLState:", j)
        }
    }
    function we() {
        try {
            o.texImage2D.apply(o, arguments)
        } catch (j) {
            console.error("THREE.WebGLState:", j)
        }
    }
    function ve() {
        try {
            o.texImage3D.apply(o, arguments)
        } catch (j) {
            console.error("THREE.WebGLState:", j)
        }
    }
    function De(j) {
        B.equals(j) === !1 && (o.scissor(j.x, j.y, j.z, j.w),
        B.copy(j))
    }
    function xe(j) {
        H.equals(j) === !1 && (o.viewport(j.x, j.y, j.z, j.w),
        H.copy(j))
    }
    function Fe(j, de) {
        let Q = h.get(de);
        Q === void 0 && (Q = new WeakMap,
        h.set(de, Q));
        let pe = Q.get(j);
        pe === void 0 && (pe = o.getUniformBlockIndex(de, j.name),
        Q.set(j, pe))
    }
    function Ge(j, de) {
        const pe = h.get(de).get(j);
        c.get(j) !== pe && (o.uniformBlockBinding(de, pe, j.__bindingPointIndex),
        c.set(j, pe))
    }
    function Re() {
        o.disable(3042),
        o.disable(2884),
        o.disable(2929),
        o.disable(32823),
        o.disable(3089),
        o.disable(2960),
        o.disable(32926),
        o.blendEquation(32774),
        o.blendFunc(1, 0),
        o.blendFuncSeparate(1, 0, 1, 0),
        o.colorMask(!0, !0, !0, !0),
        o.clearColor(0, 0, 0, 0),
        o.depthMask(!0),
        o.depthFunc(513),
        o.clearDepth(1),
        o.stencilMask(4294967295),
        o.stencilFunc(519, 0, 4294967295),
        o.stencilOp(7680, 7680, 7680),
        o.clearStencil(0),
        o.cullFace(1029),
        o.frontFace(2305),
        o.polygonOffset(0, 0),
        o.activeTexture(33984),
        o.bindFramebuffer(36160, null),
        n === !0 && (o.bindFramebuffer(36009, null),
        o.bindFramebuffer(36008, null)),
        o.useProgram(null),
        o.lineWidth(1),
        o.scissor(0, 0, o.canvas.width, o.canvas.height),
        o.viewport(0, 0, o.canvas.width, o.canvas.height),
        f = {},
        y = null,
        D = {},
        m = {},
        _ = new WeakMap,
        d = [],
        p = null,
        v = !1,
        x = null,
        S = null,
        M = null,
        T = null,
        L = null,
        P = null,
        A = null,
        C = !1,
        N = null,
        G = null,
        q = null,
        g = null,
        w = null,
        B.set(0, 0, o.canvas.width, o.canvas.height),
        H.set(0, 0, o.canvas.width, o.canvas.height),
        a.reset(),
        l.reset(),
        u.reset()
    }
    return {
        buffers: {
            color: a,
            depth: l,
            stencil: u
        },
        enable: K,
        disable: te,
        bindFramebuffer: he,
        drawBuffers: ne,
        useProgram: ce,
        setBlending: Oe,
        setMaterial: qe,
        setFlipSided: Ue,
        setCullFace: J,
        setLineWidth: Ve,
        setPolygonOffset: ye,
        setScissorTest: Ft,
        activeTexture: Ct,
        bindTexture: V,
        unbindTexture: O,
        compressedTexImage2D: re,
        texImage2D: we,
        texImage3D: ve,
        updateUBOMapping: Fe,
        uniformBlockBinding: Ge,
        texStorage2D: Se,
        texStorage3D: ee,
        texSubImage2D: le,
        texSubImage3D: ae,
        compressedTexSubImage2D: fe,
        scissor: De,
        viewport: xe,
        reset: Re
    }
}
function cD(o, e, t, n, i, r, s) {
    const a = i.isWebGL2
      , l = i.maxTextures
      , u = i.maxCubemapSize
      , c = i.maxTextureSize
      , h = i.maxSamples
      , f = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null
      , m = /OculusBrowser/g.test(navigator.userAgent)
      , _ = new WeakMap;
    let d;
    const p = new WeakMap;
    let v = !1;
    try {
        v = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
    } catch {}
    function x(V, O) {
        return v ? new OffscreenCanvas(V,O) : la("canvas")
    }
    function S(V, O, re, le) {
        let ae = 1;
        if ((V.width > le || V.height > le) && (ae = le / Math.max(V.width, V.height)),
        ae < 1 || O === !0)
            if (typeof HTMLImageElement < "u" && V instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && V instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && V instanceof ImageBitmap) {
                const fe = O ? kl : Math.floor
                  , Se = fe(ae * V.width)
                  , ee = fe(ae * V.height);
                d === void 0 && (d = x(Se, ee));
                const we = re ? x(Se, ee) : d;
                return we.width = Se,
                we.height = ee,
                we.getContext("2d").drawImage(V, 0, 0, Se, ee),
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + V.width + "x" + V.height + ") to (" + Se + "x" + ee + ")."),
                we
            } else
                return "data"in V && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + V.width + "x" + V.height + ")."),
                V;
        return V
    }
    function M(V) {
        return Pc(V.width) && Pc(V.height)
    }
    function T(V) {
        return a ? !1 : V.wrapS !== fn || V.wrapT !== fn || V.minFilter !== Vt && V.minFilter !== It
    }
    function L(V, O) {
        return V.generateMipmaps && O && V.minFilter !== Vt && V.minFilter !== It
    }
    function P(V) {
        o.generateMipmap(V)
    }
    function A(V, O, re, le, ae=!1) {
        if (a === !1)
            return O;
        if (V !== null) {
            if (o[V] !== void 0)
                return o[V];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + V + "'")
        }
        let fe = O;
        return O === 6403 && (re === 5126 && (fe = 33326),
        re === 5131 && (fe = 33325),
        re === 5121 && (fe = 33321)),
        O === 33319 && (re === 5126 && (fe = 33328),
        re === 5131 && (fe = 33327),
        re === 5121 && (fe = 33323)),
        O === 6408 && (re === 5126 && (fe = 34836),
        re === 5131 && (fe = 34842),
        re === 5121 && (fe = le === it && ae === !1 ? 35907 : 32856),
        re === 32819 && (fe = 32854),
        re === 32820 && (fe = 32855)),
        (fe === 33325 || fe === 33326 || fe === 33327 || fe === 33328 || fe === 34842 || fe === 34836) && e.get("EXT_color_buffer_float"),
        fe
    }
    function C(V, O, re) {
        return L(V, re) === !0 || V.isFramebufferTexture && V.minFilter !== Vt && V.minFilter !== It ? Math.log2(Math.max(O.width, O.height)) + 1 : V.mipmaps !== void 0 && V.mipmaps.length > 0 ? V.mipmaps.length : V.isCompressedTexture && Array.isArray(V.image) ? O.mipmaps.length : 1
    }
    function N(V) {
        return V === Vt || V === Ac || V === Cc ? 9728 : 9729
    }
    function G(V) {
        const O = V.target;
        O.removeEventListener("dispose", G),
        g(O),
        O.isVideoTexture && _.delete(O)
    }
    function q(V) {
        const O = V.target;
        O.removeEventListener("dispose", q),
        E(O)
    }
    function g(V) {
        const O = n.get(V);
        if (O.__webglInit === void 0)
            return;
        const re = V.source
          , le = p.get(re);
        if (le) {
            const ae = le[O.__cacheKey];
            ae.usedTimes--,
            ae.usedTimes === 0 && w(V),
            Object.keys(le).length === 0 && p.delete(re)
        }
        n.remove(V)
    }
    function w(V) {
        const O = n.get(V);
        o.deleteTexture(O.__webglTexture);
        const re = V.source
          , le = p.get(re);
        delete le[O.__cacheKey],
        s.memory.textures--
    }
    function E(V) {
        const O = V.texture
          , re = n.get(V)
          , le = n.get(O);
        if (le.__webglTexture !== void 0 && (o.deleteTexture(le.__webglTexture),
        s.memory.textures--),
        V.depthTexture && V.depthTexture.dispose(),
        V.isWebGLCubeRenderTarget)
            for (let ae = 0; ae < 6; ae++)
                o.deleteFramebuffer(re.__webglFramebuffer[ae]),
                re.__webglDepthbuffer && o.deleteRenderbuffer(re.__webglDepthbuffer[ae]);
        else {
            if (o.deleteFramebuffer(re.__webglFramebuffer),
            re.__webglDepthbuffer && o.deleteRenderbuffer(re.__webglDepthbuffer),
            re.__webglMultisampledFramebuffer && o.deleteFramebuffer(re.__webglMultisampledFramebuffer),
            re.__webglColorRenderbuffer)
                for (let ae = 0; ae < re.__webglColorRenderbuffer.length; ae++)
                    re.__webglColorRenderbuffer[ae] && o.deleteRenderbuffer(re.__webglColorRenderbuffer[ae]);
            re.__webglDepthRenderbuffer && o.deleteRenderbuffer(re.__webglDepthRenderbuffer)
        }
        if (V.isWebGLMultipleRenderTargets)
            for (let ae = 0, fe = O.length; ae < fe; ae++) {
                const Se = n.get(O[ae]);
                Se.__webglTexture && (o.deleteTexture(Se.__webglTexture),
                s.memory.textures--),
                n.remove(O[ae])
            }
        n.remove(O),
        n.remove(V)
    }
    let R = 0;
    function z() {
        R = 0
    }
    function b() {
        const V = R;
        return V >= l && console.warn("THREE.WebGLTextures: Trying to use " + V + " texture units while this GPU supports only " + l),
        R += 1,
        V
    }
    function y(V) {
        const O = [];
        return O.push(V.wrapS),
        O.push(V.wrapT),
        O.push(V.magFilter),
        O.push(V.minFilter),
        O.push(V.anisotropy),
        O.push(V.internalFormat),
        O.push(V.format),
        O.push(V.type),
        O.push(V.generateMipmaps),
        O.push(V.premultiplyAlpha),
        O.push(V.flipY),
        O.push(V.unpackAlignment),
        O.push(V.encoding),
        O.join()
    }
    function D(V, O) {
        const re = n.get(V);
        if (V.isVideoTexture && Ft(V),
        V.isRenderTargetTexture === !1 && V.version > 0 && re.__version !== V.version) {
            const le = V.image;
            if (le === null)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (le.complete === !1)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                te(re, V, O);
                return
            }
        }
        t.activeTexture(33984 + O),
        t.bindTexture(3553, re.__webglTexture)
    }
    function I(V, O) {
        const re = n.get(V);
        if (V.version > 0 && re.__version !== V.version) {
            te(re, V, O);
            return
        }
        t.activeTexture(33984 + O),
        t.bindTexture(35866, re.__webglTexture)
    }
    function F(V, O) {
        const re = n.get(V);
        if (V.version > 0 && re.__version !== V.version) {
            te(re, V, O);
            return
        }
        t.activeTexture(33984 + O),
        t.bindTexture(32879, re.__webglTexture)
    }
    function B(V, O) {
        const re = n.get(V);
        if (V.version > 0 && re.__version !== V.version) {
            he(re, V, O);
            return
        }
        t.activeTexture(33984 + O),
        t.bindTexture(34067, re.__webglTexture)
    }
    const H = {
        [to]: 10497,
        [fn]: 33071,
        [Nl]: 33648
    }
      , W = {
        [Vt]: 9728,
        [Ac]: 9984,
        [Cc]: 9986,
        [It]: 9729,
        [Vg]: 9985,
        [ss]: 9987
    };
    function U(V, O, re) {
        if (re ? (o.texParameteri(V, 10242, H[O.wrapS]),
        o.texParameteri(V, 10243, H[O.wrapT]),
        (V === 32879 || V === 35866) && o.texParameteri(V, 32882, H[O.wrapR]),
        o.texParameteri(V, 10240, W[O.magFilter]),
        o.texParameteri(V, 10241, W[O.minFilter])) : (o.texParameteri(V, 10242, 33071),
        o.texParameteri(V, 10243, 33071),
        (V === 32879 || V === 35866) && o.texParameteri(V, 32882, 33071),
        (O.wrapS !== fn || O.wrapT !== fn) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
        o.texParameteri(V, 10240, N(O.magFilter)),
        o.texParameteri(V, 10241, N(O.minFilter)),
        O.minFilter !== Vt && O.minFilter !== It && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
        e.has("EXT_texture_filter_anisotropic") === !0) {
            const le = e.get("EXT_texture_filter_anisotropic");
            if (O.type === Qn && e.has("OES_texture_float_linear") === !1 || a === !1 && O.type === Ni && e.has("OES_texture_half_float_linear") === !1)
                return;
            (O.anisotropy > 1 || n.get(O).__currentAnisotropy) && (o.texParameterf(V, le.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(O.anisotropy, i.getMaxAnisotropy())),
            n.get(O).__currentAnisotropy = O.anisotropy)
        }
    }
    function K(V, O) {
        let re = !1;
        V.__webglInit === void 0 && (V.__webglInit = !0,
        O.addEventListener("dispose", G));
        const le = O.source;
        let ae = p.get(le);
        ae === void 0 && (ae = {},
        p.set(le, ae));
        const fe = y(O);
        if (fe !== V.__cacheKey) {
            ae[fe] === void 0 && (ae[fe] = {
                texture: o.createTexture(),
                usedTimes: 0
            },
            s.memory.textures++,
            re = !0),
            ae[fe].usedTimes++;
            const Se = ae[V.__cacheKey];
            Se !== void 0 && (ae[V.__cacheKey].usedTimes--,
            Se.usedTimes === 0 && w(O)),
            V.__cacheKey = fe,
            V.__webglTexture = ae[fe].texture
        }
        return re
    }
    function te(V, O, re) {
        let le = 3553;
        O.isDataArrayTexture && (le = 35866),
        O.isData3DTexture && (le = 32879);
        const ae = K(V, O)
          , fe = O.source;
        if (t.activeTexture(33984 + re),
        t.bindTexture(le, V.__webglTexture),
        fe.version !== fe.__currentVersion || ae === !0) {
            o.pixelStorei(37440, O.flipY),
            o.pixelStorei(37441, O.premultiplyAlpha),
            o.pixelStorei(3317, O.unpackAlignment),
            o.pixelStorei(37443, 0);
            const Se = T(O) && M(O.image) === !1;
            let ee = S(O.image, Se, !1, c);
            ee = Ct(O, ee);
            const we = M(ee) || a
              , ve = r.convert(O.format, O.encoding);
            let De = r.convert(O.type)
              , xe = A(O.internalFormat, ve, De, O.encoding, O.isVideoTexture);
            U(le, O, we);
            let Fe;
            const Ge = O.mipmaps
              , Re = a && O.isVideoTexture !== !0
              , j = fe.__currentVersion === void 0 || ae === !0
              , de = C(O, ee, we);
            if (O.isDepthTexture)
                xe = 6402,
                a ? O.type === Qn ? xe = 36012 : O.type === kr ? xe = 33190 : O.type === Hs ? xe = 35056 : xe = 33189 : O.type === Qn && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                O.format === qr && xe === 6402 && O.type !== Gg && O.type !== kr && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                O.type = kr,
                De = r.convert(O.type)),
                O.format === no && xe === 6402 && (xe = 34041,
                O.type !== Hs && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                O.type = Hs,
                De = r.convert(O.type))),
                j && (Re ? t.texStorage2D(3553, 1, xe, ee.width, ee.height) : t.texImage2D(3553, 0, xe, ee.width, ee.height, 0, ve, De, null));
            else if (O.isDataTexture)
                if (Ge.length > 0 && we) {
                    Re && j && t.texStorage2D(3553, de, xe, Ge[0].width, Ge[0].height);
                    for (let Q = 0, pe = Ge.length; Q < pe; Q++)
                        Fe = Ge[Q],
                        Re ? t.texSubImage2D(3553, Q, 0, 0, Fe.width, Fe.height, ve, De, Fe.data) : t.texImage2D(3553, Q, xe, Fe.width, Fe.height, 0, ve, De, Fe.data);
                    O.generateMipmaps = !1
                } else
                    Re ? (j && t.texStorage2D(3553, de, xe, ee.width, ee.height),
                    t.texSubImage2D(3553, 0, 0, 0, ee.width, ee.height, ve, De, ee.data)) : t.texImage2D(3553, 0, xe, ee.width, ee.height, 0, ve, De, ee.data);
            else if (O.isCompressedTexture) {
                Re && j && t.texStorage2D(3553, de, xe, Ge[0].width, Ge[0].height);
                for (let Q = 0, pe = Ge.length; Q < pe; Q++)
                    Fe = Ge[Q],
                    O.format !== Jn ? ve !== null ? Re ? t.compressedTexSubImage2D(3553, Q, 0, 0, Fe.width, Fe.height, ve, Fe.data) : t.compressedTexImage2D(3553, Q, xe, Fe.width, Fe.height, 0, Fe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Re ? t.texSubImage2D(3553, Q, 0, 0, Fe.width, Fe.height, ve, De, Fe.data) : t.texImage2D(3553, Q, xe, Fe.width, Fe.height, 0, ve, De, Fe.data)
            } else if (O.isDataArrayTexture)
                Re ? (j && t.texStorage3D(35866, de, xe, ee.width, ee.height, ee.depth),
                t.texSubImage3D(35866, 0, 0, 0, 0, ee.width, ee.height, ee.depth, ve, De, ee.data)) : t.texImage3D(35866, 0, xe, ee.width, ee.height, ee.depth, 0, ve, De, ee.data);
            else if (O.isData3DTexture)
                Re ? (j && t.texStorage3D(32879, de, xe, ee.width, ee.height, ee.depth),
                t.texSubImage3D(32879, 0, 0, 0, 0, ee.width, ee.height, ee.depth, ve, De, ee.data)) : t.texImage3D(32879, 0, xe, ee.width, ee.height, ee.depth, 0, ve, De, ee.data);
            else if (O.isFramebufferTexture) {
                if (j)
                    if (Re)
                        t.texStorage2D(3553, de, xe, ee.width, ee.height);
                    else {
                        let Q = ee.width
                          , pe = ee.height;
                        for (let me = 0; me < de; me++)
                            t.texImage2D(3553, me, xe, Q, pe, 0, ve, De, null),
                            Q >>= 1,
                            pe >>= 1
                    }
            } else if (Ge.length > 0 && we) {
                Re && j && t.texStorage2D(3553, de, xe, Ge[0].width, Ge[0].height);
                for (let Q = 0, pe = Ge.length; Q < pe; Q++)
                    Fe = Ge[Q],
                    Re ? t.texSubImage2D(3553, Q, 0, 0, ve, De, Fe) : t.texImage2D(3553, Q, xe, ve, De, Fe);
                O.generateMipmaps = !1
            } else
                Re ? (j && t.texStorage2D(3553, de, xe, ee.width, ee.height),
                t.texSubImage2D(3553, 0, 0, 0, ve, De, ee)) : t.texImage2D(3553, 0, xe, ve, De, ee);
            L(O, we) && P(le),
            fe.__currentVersion = fe.version,
            O.onUpdate && O.onUpdate(O)
        }
        V.__version = O.version
    }
    function he(V, O, re) {
        if (O.image.length !== 6)
            return;
        const le = K(V, O)
          , ae = O.source;
        if (t.activeTexture(33984 + re),
        t.bindTexture(34067, V.__webglTexture),
        ae.version !== ae.__currentVersion || le === !0) {
            o.pixelStorei(37440, O.flipY),
            o.pixelStorei(37441, O.premultiplyAlpha),
            o.pixelStorei(3317, O.unpackAlignment),
            o.pixelStorei(37443, 0);
            const fe = O.isCompressedTexture || O.image[0].isCompressedTexture
              , Se = O.image[0] && O.image[0].isDataTexture
              , ee = [];
            for (let Q = 0; Q < 6; Q++)
                !fe && !Se ? ee[Q] = S(O.image[Q], !1, !0, u) : ee[Q] = Se ? O.image[Q].image : O.image[Q],
                ee[Q] = Ct(O, ee[Q]);
            const we = ee[0]
              , ve = M(we) || a
              , De = r.convert(O.format, O.encoding)
              , xe = r.convert(O.type)
              , Fe = A(O.internalFormat, De, xe, O.encoding)
              , Ge = a && O.isVideoTexture !== !0
              , Re = ae.__currentVersion === void 0 || le === !0;
            let j = C(O, we, ve);
            U(34067, O, ve);
            let de;
            if (fe) {
                Ge && Re && t.texStorage2D(34067, j, Fe, we.width, we.height);
                for (let Q = 0; Q < 6; Q++) {
                    de = ee[Q].mipmaps;
                    for (let pe = 0; pe < de.length; pe++) {
                        const me = de[pe];
                        O.format !== Jn ? De !== null ? Ge ? t.compressedTexSubImage2D(34069 + Q, pe, 0, 0, me.width, me.height, De, me.data) : t.compressedTexImage2D(34069 + Q, pe, Fe, me.width, me.height, 0, me.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Ge ? t.texSubImage2D(34069 + Q, pe, 0, 0, me.width, me.height, De, xe, me.data) : t.texImage2D(34069 + Q, pe, Fe, me.width, me.height, 0, De, xe, me.data)
                    }
                }
            } else {
                de = O.mipmaps,
                Ge && Re && (de.length > 0 && j++,
                t.texStorage2D(34067, j, Fe, ee[0].width, ee[0].height));
                for (let Q = 0; Q < 6; Q++)
                    if (Se) {
                        Ge ? t.texSubImage2D(34069 + Q, 0, 0, 0, ee[Q].width, ee[Q].height, De, xe, ee[Q].data) : t.texImage2D(34069 + Q, 0, Fe, ee[Q].width, ee[Q].height, 0, De, xe, ee[Q].data);
                        for (let pe = 0; pe < de.length; pe++) {
                            const Be = de[pe].image[Q].image;
                            Ge ? t.texSubImage2D(34069 + Q, pe + 1, 0, 0, Be.width, Be.height, De, xe, Be.data) : t.texImage2D(34069 + Q, pe + 1, Fe, Be.width, Be.height, 0, De, xe, Be.data)
                        }
                    } else {
                        Ge ? t.texSubImage2D(34069 + Q, 0, 0, 0, De, xe, ee[Q]) : t.texImage2D(34069 + Q, 0, Fe, De, xe, ee[Q]);
                        for (let pe = 0; pe < de.length; pe++) {
                            const me = de[pe];
                            Ge ? t.texSubImage2D(34069 + Q, pe + 1, 0, 0, De, xe, me.image[Q]) : t.texImage2D(34069 + Q, pe + 1, Fe, De, xe, me.image[Q])
                        }
                    }
            }
            L(O, ve) && P(34067),
            ae.__currentVersion = ae.version,
            O.onUpdate && O.onUpdate(O)
        }
        V.__version = O.version
    }
    function ne(V, O, re, le, ae) {
        const fe = r.convert(re.format, re.encoding)
          , Se = r.convert(re.type)
          , ee = A(re.internalFormat, fe, Se, re.encoding);
        n.get(O).__hasExternalTextures || (ae === 32879 || ae === 35866 ? t.texImage3D(ae, 0, ee, O.width, O.height, O.depth, 0, fe, Se, null) : t.texImage2D(ae, 0, ee, O.width, O.height, 0, fe, Se, null)),
        t.bindFramebuffer(36160, V),
        ye(O) ? f.framebufferTexture2DMultisampleEXT(36160, le, ae, n.get(re).__webglTexture, 0, Ve(O)) : o.framebufferTexture2D(36160, le, ae, n.get(re).__webglTexture, 0),
        t.bindFramebuffer(36160, null)
    }
    function ce(V, O, re) {
        if (o.bindRenderbuffer(36161, V),
        O.depthBuffer && !O.stencilBuffer) {
            let le = 33189;
            if (re || ye(O)) {
                const ae = O.depthTexture;
                ae && ae.isDepthTexture && (ae.type === Qn ? le = 36012 : ae.type === kr && (le = 33190));
                const fe = Ve(O);
                ye(O) ? f.renderbufferStorageMultisampleEXT(36161, fe, le, O.width, O.height) : o.renderbufferStorageMultisample(36161, fe, le, O.width, O.height)
            } else
                o.renderbufferStorage(36161, le, O.width, O.height);
            o.framebufferRenderbuffer(36160, 36096, 36161, V)
        } else if (O.depthBuffer && O.stencilBuffer) {
            const le = Ve(O);
            re && ye(O) === !1 ? o.renderbufferStorageMultisample(36161, le, 35056, O.width, O.height) : ye(O) ? f.renderbufferStorageMultisampleEXT(36161, le, 35056, O.width, O.height) : o.renderbufferStorage(36161, 34041, O.width, O.height),
            o.framebufferRenderbuffer(36160, 33306, 36161, V)
        } else {
            const le = O.isWebGLMultipleRenderTargets === !0 ? O.texture : [O.texture];
            for (let ae = 0; ae < le.length; ae++) {
                const fe = le[ae]
                  , Se = r.convert(fe.format, fe.encoding)
                  , ee = r.convert(fe.type)
                  , we = A(fe.internalFormat, Se, ee, fe.encoding)
                  , ve = Ve(O);
                re && ye(O) === !1 ? o.renderbufferStorageMultisample(36161, ve, we, O.width, O.height) : ye(O) ? f.renderbufferStorageMultisampleEXT(36161, ve, we, O.width, O.height) : o.renderbufferStorage(36161, we, O.width, O.height)
            }
        }
        o.bindRenderbuffer(36161, null)
    }
    function oe(V, O) {
        if (O && O.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(36160, V),
        !(O.depthTexture && O.depthTexture.isDepthTexture))
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        (!n.get(O.depthTexture).__webglTexture || O.depthTexture.image.width !== O.width || O.depthTexture.image.height !== O.height) && (O.depthTexture.image.width = O.width,
        O.depthTexture.image.height = O.height,
        O.depthTexture.needsUpdate = !0),
        D(O.depthTexture, 0);
        const le = n.get(O.depthTexture).__webglTexture
          , ae = Ve(O);
        if (O.depthTexture.format === qr)
            ye(O) ? f.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, le, 0, ae) : o.framebufferTexture2D(36160, 36096, 3553, le, 0);
        else if (O.depthTexture.format === no)
            ye(O) ? f.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, le, 0, ae) : o.framebufferTexture2D(36160, 33306, 3553, le, 0);
        else
            throw new Error("Unknown depthTexture format")
    }
    function ue(V) {
        const O = n.get(V)
          , re = V.isWebGLCubeRenderTarget === !0;
        if (V.depthTexture && !O.__autoAllocateDepthBuffer) {
            if (re)
                throw new Error("target.depthTexture not supported in Cube render targets");
            oe(O.__webglFramebuffer, V)
        } else if (re) {
            O.__webglDepthbuffer = [];
            for (let le = 0; le < 6; le++)
                t.bindFramebuffer(36160, O.__webglFramebuffer[le]),
                O.__webglDepthbuffer[le] = o.createRenderbuffer(),
                ce(O.__webglDepthbuffer[le], V, !1)
        } else
            t.bindFramebuffer(36160, O.__webglFramebuffer),
            O.__webglDepthbuffer = o.createRenderbuffer(),
            ce(O.__webglDepthbuffer, V, !1);
        t.bindFramebuffer(36160, null)
    }
    function Oe(V, O, re) {
        const le = n.get(V);
        O !== void 0 && ne(le.__webglFramebuffer, V, V.texture, 36064, 3553),
        re !== void 0 && ue(V)
    }
    function qe(V) {
        const O = V.texture
          , re = n.get(V)
          , le = n.get(O);
        V.addEventListener("dispose", q),
        V.isWebGLMultipleRenderTargets !== !0 && (le.__webglTexture === void 0 && (le.__webglTexture = o.createTexture()),
        le.__version = O.version,
        s.memory.textures++);
        const ae = V.isWebGLCubeRenderTarget === !0
          , fe = V.isWebGLMultipleRenderTargets === !0
          , Se = M(V) || a;
        if (ae) {
            re.__webglFramebuffer = [];
            for (let ee = 0; ee < 6; ee++)
                re.__webglFramebuffer[ee] = o.createFramebuffer()
        } else {
            if (re.__webglFramebuffer = o.createFramebuffer(),
            fe)
                if (i.drawBuffers) {
                    const ee = V.texture;
                    for (let we = 0, ve = ee.length; we < ve; we++) {
                        const De = n.get(ee[we]);
                        De.__webglTexture === void 0 && (De.__webglTexture = o.createTexture(),
                        s.memory.textures++)
                    }
                } else
                    console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
            if (a && V.samples > 0 && ye(V) === !1) {
                const ee = fe ? O : [O];
                re.__webglMultisampledFramebuffer = o.createFramebuffer(),
                re.__webglColorRenderbuffer = [],
                t.bindFramebuffer(36160, re.__webglMultisampledFramebuffer);
                for (let we = 0; we < ee.length; we++) {
                    const ve = ee[we];
                    re.__webglColorRenderbuffer[we] = o.createRenderbuffer(),
                    o.bindRenderbuffer(36161, re.__webglColorRenderbuffer[we]);
                    const De = r.convert(ve.format, ve.encoding)
                      , xe = r.convert(ve.type)
                      , Fe = A(ve.internalFormat, De, xe, ve.encoding)
                      , Ge = Ve(V);
                    o.renderbufferStorageMultisample(36161, Ge, Fe, V.width, V.height),
                    o.framebufferRenderbuffer(36160, 36064 + we, 36161, re.__webglColorRenderbuffer[we])
                }
                o.bindRenderbuffer(36161, null),
                V.depthBuffer && (re.__webglDepthRenderbuffer = o.createRenderbuffer(),
                ce(re.__webglDepthRenderbuffer, V, !0)),
                t.bindFramebuffer(36160, null)
            }
        }
        if (ae) {
            t.bindTexture(34067, le.__webglTexture),
            U(34067, O, Se);
            for (let ee = 0; ee < 6; ee++)
                ne(re.__webglFramebuffer[ee], V, O, 36064, 34069 + ee);
            L(O, Se) && P(34067),
            t.unbindTexture()
        } else if (fe) {
            const ee = V.texture;
            for (let we = 0, ve = ee.length; we < ve; we++) {
                const De = ee[we]
                  , xe = n.get(De);
                t.bindTexture(3553, xe.__webglTexture),
                U(3553, De, Se),
                ne(re.__webglFramebuffer, V, De, 36064 + we, 3553),
                L(De, Se) && P(3553)
            }
            t.unbindTexture()
        } else {
            let ee = 3553;
            (V.isWebGL3DRenderTarget || V.isWebGLArrayRenderTarget) && (a ? ee = V.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),
            t.bindTexture(ee, le.__webglTexture),
            U(ee, O, Se),
            ne(re.__webglFramebuffer, V, O, 36064, ee),
            L(O, Se) && P(ee),
            t.unbindTexture()
        }
        V.depthBuffer && ue(V)
    }
    function Ue(V) {
        const O = M(V) || a
          , re = V.isWebGLMultipleRenderTargets === !0 ? V.texture : [V.texture];
        for (let le = 0, ae = re.length; le < ae; le++) {
            const fe = re[le];
            if (L(fe, O)) {
                const Se = V.isWebGLCubeRenderTarget ? 34067 : 3553
                  , ee = n.get(fe).__webglTexture;
                t.bindTexture(Se, ee),
                P(Se),
                t.unbindTexture()
            }
        }
    }
    function J(V) {
        if (a && V.samples > 0 && ye(V) === !1) {
            const O = V.isWebGLMultipleRenderTargets ? V.texture : [V.texture]
              , re = V.width
              , le = V.height;
            let ae = 16384;
            const fe = []
              , Se = V.stencilBuffer ? 33306 : 36096
              , ee = n.get(V)
              , we = V.isWebGLMultipleRenderTargets === !0;
            if (we)
                for (let ve = 0; ve < O.length; ve++)
                    t.bindFramebuffer(36160, ee.__webglMultisampledFramebuffer),
                    o.framebufferRenderbuffer(36160, 36064 + ve, 36161, null),
                    t.bindFramebuffer(36160, ee.__webglFramebuffer),
                    o.framebufferTexture2D(36009, 36064 + ve, 3553, null, 0);
            t.bindFramebuffer(36008, ee.__webglMultisampledFramebuffer),
            t.bindFramebuffer(36009, ee.__webglFramebuffer);
            for (let ve = 0; ve < O.length; ve++) {
                fe.push(36064 + ve),
                V.depthBuffer && fe.push(Se);
                const De = ee.__ignoreDepthPhilosophy !== void 0 ? ee.__ignoreDepthPhilosophy : !1;
                if (De === !1 && (V.depthBuffer && (ae |= 256),
                V.stencilBuffer && (ae |= 1024)),
                we && o.framebufferRenderbuffer(36008, 36064, 36161, ee.__webglColorRenderbuffer[ve]),
                De === !0 && (o.invalidateFramebuffer(36008, [Se]),
                o.invalidateFramebuffer(36009, [Se])),
                we) {
                    const xe = n.get(O[ve]).__webglTexture;
                    o.framebufferTexture2D(36009, 36064, 3553, xe, 0)
                }
                o.blitFramebuffer(0, 0, re, le, 0, 0, re, le, ae, 9728),
                m && o.invalidateFramebuffer(36008, fe)
            }
            if (t.bindFramebuffer(36008, null),
            t.bindFramebuffer(36009, null),
            we)
                for (let ve = 0; ve < O.length; ve++) {
                    t.bindFramebuffer(36160, ee.__webglMultisampledFramebuffer),
                    o.framebufferRenderbuffer(36160, 36064 + ve, 36161, ee.__webglColorRenderbuffer[ve]);
                    const De = n.get(O[ve]).__webglTexture;
                    t.bindFramebuffer(36160, ee.__webglFramebuffer),
                    o.framebufferTexture2D(36009, 36064 + ve, 3553, De, 0)
                }
            t.bindFramebuffer(36009, ee.__webglMultisampledFramebuffer)
        }
    }
    function Ve(V) {
        return Math.min(h, V.samples)
    }
    function ye(V) {
        const O = n.get(V);
        return a && V.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && O.__useRenderToTexture !== !1
    }
    function Ft(V) {
        const O = s.render.frame;
        _.get(V) !== O && (_.set(V, O),
        V.update())
    }
    function Ct(V, O) {
        const re = V.encoding
          , le = V.format
          , ae = V.type;
        return V.isCompressedTexture === !0 || V.isVideoTexture === !0 || V.format === Rc || re !== pr && (re === it ? a === !1 ? e.has("EXT_sRGB") === !0 && le === Jn ? (V.format = Rc,
        V.minFilter = It,
        V.generateMipmaps = !1) : O = Xg.sRGBToLinear(O) : (le !== Jn || ae !== es) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", re)),
        O
    }
    this.allocateTextureUnit = b,
    this.resetTextureUnits = z,
    this.setTexture2D = D,
    this.setTexture2DArray = I,
    this.setTexture3D = F,
    this.setTextureCube = B,
    this.rebindTextures = Oe,
    this.setupRenderTarget = qe,
    this.updateRenderTargetMipmap = Ue,
    this.updateMultisampleRenderTarget = J,
    this.setupDepthRenderbuffer = ue,
    this.setupFrameBufferTexture = ne,
    this.useMultisampledRTT = ye
}
function hD(o, e, t) {
    const n = t.isWebGL2;
    function i(r, s=null) {
        let a;
        if (r === es)
            return 5121;
        if (r === jy)
            return 32819;
        if (r === qy)
            return 32820;
        if (r === Gy)
            return 5120;
        if (r === Hy)
            return 5122;
        if (r === Gg)
            return 5123;
        if (r === Wy)
            return 5124;
        if (r === kr)
            return 5125;
        if (r === Qn)
            return 5126;
        if (r === Ni)
            return n ? 5131 : (a = e.get("OES_texture_half_float"),
            a !== null ? a.HALF_FLOAT_OES : null);
        if (r === Xy)
            return 6406;
        if (r === Jn)
            return 6408;
        if (r === Ky)
            return 6409;
        if (r === $y)
            return 6410;
        if (r === qr)
            return 6402;
        if (r === no)
            return 34041;
        if (r === Zy)
            return 6403;
        if (r === Yy)
            return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),
            6408;
        if (r === Rc)
            return a = e.get("EXT_sRGB"),
            a !== null ? a.SRGB_ALPHA_EXT : null;
        if (r === Qy)
            return 36244;
        if (r === Jy)
            return 33319;
        if (r === eb)
            return 33320;
        if (r === tb)
            return 36249;
        if (r === vu || r === xu || r === yu || r === bu)
            if (s === it)
                if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                a !== null) {
                    if (r === vu)
                        return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (r === xu)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (r === yu)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (r === bu)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else
                    return null;
            else if (a = e.get("WEBGL_compressed_texture_s3tc"),
            a !== null) {
                if (r === vu)
                    return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (r === xu)
                    return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (r === yu)
                    return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (r === bu)
                    return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else
                return null;
        if (r === Xf || r === Yf || r === Kf || r === $f)
            if (a = e.get("WEBGL_compressed_texture_pvrtc"),
            a !== null) {
                if (r === Xf)
                    return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (r === Yf)
                    return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (r === Kf)
                    return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (r === $f)
                    return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else
                return null;
        if (r === nb)
            return a = e.get("WEBGL_compressed_texture_etc1"),
            a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
        if (r === Zf || r === Qf)
            if (a = e.get("WEBGL_compressed_texture_etc"),
            a !== null) {
                if (r === Zf)
                    return s === it ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
                if (r === Qf)
                    return s === it ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC
            } else
                return null;
        if (r === Jf || r === ed || r === td || r === nd || r === id || r === rd || r === sd || r === od || r === ad || r === ld || r === ud || r === cd || r === hd || r === fd)
            if (a = e.get("WEBGL_compressed_texture_astc"),
            a !== null) {
                if (r === Jf)
                    return s === it ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (r === ed)
                    return s === it ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (r === td)
                    return s === it ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (r === nd)
                    return s === it ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (r === id)
                    return s === it ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (r === rd)
                    return s === it ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (r === sd)
                    return s === it ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (r === od)
                    return s === it ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (r === ad)
                    return s === it ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (r === ld)
                    return s === it ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (r === ud)
                    return s === it ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (r === cd)
                    return s === it ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (r === hd)
                    return s === it ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (r === fd)
                    return s === it ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else
                return null;
        if (r === dd)
            if (a = e.get("EXT_texture_compression_bptc"),
            a !== null) {
                if (r === dd)
                    return s === it ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT
            } else
                return null;
        return r === Hs ? n ? 34042 : (a = e.get("WEBGL_depth_texture"),
        a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : o[r] !== void 0 ? o[r] : null
    }
    return {
        convert: i
    }
}
class fD extends un {
    constructor(e=[]) {
        super(),
        this.isArrayCamera = !0,
        this.cameras = e
    }
}
class Br extends yt {
    constructor() {
        super(),
        this.isGroup = !0,
        this.type = "Group"
    }
}
const dD = {
    type: "move"
};
class Yu {
    constructor() {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new Br,
        this._hand.matrixAutoUpdate = !1,
        this._hand.visible = !1,
        this._hand.joints = {},
        this._hand.inputState = {
            pinching: !1
        }),
        this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new Br,
        this._targetRay.matrixAutoUpdate = !1,
        this._targetRay.visible = !1,
        this._targetRay.hasLinearVelocity = !1,
        this._targetRay.linearVelocity = new X,
        this._targetRay.hasAngularVelocity = !1,
        this._targetRay.angularVelocity = new X),
        this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new Br,
        this._grip.matrixAutoUpdate = !1,
        this._grip.visible = !1,
        this._grip.hasLinearVelocity = !1,
        this._grip.linearVelocity = new X,
        this._grip.hasAngularVelocity = !1,
        this._grip.angularVelocity = new X),
        this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e),
        this._grip !== null && this._grip.dispatchEvent(e),
        this._hand !== null && this._hand.dispatchEvent(e),
        this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }),
        this._targetRay !== null && (this._targetRay.visible = !1),
        this._grip !== null && (this._grip.visible = !1),
        this._hand !== null && (this._hand.visible = !1),
        this
    }
    update(e, t, n) {
        let i = null
          , r = null
          , s = null;
        const a = this._targetRay
          , l = this._grip
          , u = this._hand;
        if (e && t.session.visibilityState !== "visible-blurred") {
            if (u && e.hand) {
                s = !0;
                for (const d of e.hand.values()) {
                    const p = t.getJointPose(d, n);
                    if (u.joints[d.jointName] === void 0) {
                        const x = new Br;
                        x.matrixAutoUpdate = !1,
                        x.visible = !1,
                        u.joints[d.jointName] = x,
                        u.add(x)
                    }
                    const v = u.joints[d.jointName];
                    p !== null && (v.matrix.fromArray(p.transform.matrix),
                    v.matrix.decompose(v.position, v.rotation, v.scale),
                    v.jointRadius = p.radius),
                    v.visible = p !== null
                }
                const c = u.joints["index-finger-tip"]
                  , h = u.joints["thumb-tip"]
                  , f = c.position.distanceTo(h.position)
                  , m = .02
                  , _ = .005;
                u.inputState.pinching && f > m + _ ? (u.inputState.pinching = !1,
                this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !u.inputState.pinching && f <= m - _ && (u.inputState.pinching = !0,
                this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else
                l !== null && e.gripSpace && (r = t.getPose(e.gripSpace, n),
                r !== null && (l.matrix.fromArray(r.transform.matrix),
                l.matrix.decompose(l.position, l.rotation, l.scale),
                r.linearVelocity ? (l.hasLinearVelocity = !0,
                l.linearVelocity.copy(r.linearVelocity)) : l.hasLinearVelocity = !1,
                r.angularVelocity ? (l.hasAngularVelocity = !0,
                l.angularVelocity.copy(r.angularVelocity)) : l.hasAngularVelocity = !1));
            a !== null && (i = t.getPose(e.targetRaySpace, n),
            i === null && r !== null && (i = r),
            i !== null && (a.matrix.fromArray(i.transform.matrix),
            a.matrix.decompose(a.position, a.rotation, a.scale),
            i.linearVelocity ? (a.hasLinearVelocity = !0,
            a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1,
            i.angularVelocity ? (a.hasAngularVelocity = !0,
            a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1,
            this.dispatchEvent(dD)))
        }
        return a !== null && (a.visible = i !== null),
        l !== null && (l.visible = r !== null),
        u !== null && (u.visible = s !== null),
        this
    }
}
class pD extends tn {
    constructor(e, t, n, i, r, s, a, l, u, c) {
        if (c = c !== void 0 ? c : qr,
        c !== qr && c !== no)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        n === void 0 && c === qr && (n = kr),
        n === void 0 && c === no && (n = Hs),
        super(null, i, r, s, a, l, c, n, u),
        this.isDepthTexture = !0,
        this.image = {
            width: e,
            height: t
        },
        this.magFilter = a !== void 0 ? a : Vt,
        this.minFilter = l !== void 0 ? l : Vt,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
}
class mD extends oo {
    constructor(e, t) {
        super();
        const n = this;
        let i = null
          , r = 1
          , s = null
          , a = "local-floor"
          , l = null
          , u = null
          , c = null
          , h = null
          , f = null
          , m = null;
        const _ = t.getContextAttributes();
        let d = null
          , p = null;
        const v = []
          , x = []
          , S = new un;
        S.layers.enable(1),
        S.viewport = new ct;
        const M = new un;
        M.layers.enable(2),
        M.viewport = new ct;
        const T = [S, M]
          , L = new fD;
        L.layers.enable(1),
        L.layers.enable(2);
        let P = null
          , A = null;
        this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(y) {
            let D = v[y];
            return D === void 0 && (D = new Yu,
            v[y] = D),
            D.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(y) {
            let D = v[y];
            return D === void 0 && (D = new Yu,
            v[y] = D),
            D.getGripSpace()
        }
        ,
        this.getHand = function(y) {
            let D = v[y];
            return D === void 0 && (D = new Yu,
            v[y] = D),
            D.getHandSpace()
        }
        ;
        function C(y) {
            const D = x.indexOf(y.inputSource);
            if (D === -1)
                return;
            const I = v[D];
            I !== void 0 && I.dispatchEvent({
                type: y.type,
                data: y.inputSource
            })
        }
        function N() {
            i.removeEventListener("select", C),
            i.removeEventListener("selectstart", C),
            i.removeEventListener("selectend", C),
            i.removeEventListener("squeeze", C),
            i.removeEventListener("squeezestart", C),
            i.removeEventListener("squeezeend", C),
            i.removeEventListener("end", N),
            i.removeEventListener("inputsourceschange", G);
            for (let y = 0; y < v.length; y++) {
                const D = x[y];
                D !== null && (x[y] = null,
                v[y].disconnect(D))
            }
            P = null,
            A = null,
            e.setRenderTarget(d),
            f = null,
            h = null,
            c = null,
            i = null,
            p = null,
            b.stop(),
            n.isPresenting = !1,
            n.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(y) {
            r = y,
            n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(y) {
            a = y,
            n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return l || s
        }
        ,
        this.setReferenceSpace = function(y) {
            l = y
        }
        ,
        this.getBaseLayer = function() {
            return h !== null ? h : f
        }
        ,
        this.getBinding = function() {
            return c
        }
        ,
        this.getFrame = function() {
            return m
        }
        ,
        this.getSession = function() {
            return i
        }
        ,
        this.setSession = async function(y) {
            if (i = y,
            i !== null) {
                if (d = e.getRenderTarget(),
                i.addEventListener("select", C),
                i.addEventListener("selectstart", C),
                i.addEventListener("selectend", C),
                i.addEventListener("squeeze", C),
                i.addEventListener("squeezestart", C),
                i.addEventListener("squeezeend", C),
                i.addEventListener("end", N),
                i.addEventListener("inputsourceschange", G),
                _.xrCompatible !== !0 && await t.makeXRCompatible(),
                i.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
                    const D = {
                        antialias: i.renderState.layers === void 0 ? _.antialias : !0,
                        alpha: _.alpha,
                        depth: _.depth,
                        stencil: _.stencil,
                        framebufferScaleFactor: r
                    };
                    f = new XRWebGLLayer(i,t,D),
                    i.updateRenderState({
                        baseLayer: f
                    }),
                    p = new ts(f.framebufferWidth,f.framebufferHeight,{
                        format: Jn,
                        type: es,
                        encoding: e.outputEncoding,
                        stencilBuffer: _.stencil
                    })
                } else {
                    let D = null
                      , I = null
                      , F = null;
                    _.depth && (F = _.stencil ? 35056 : 33190,
                    D = _.stencil ? no : qr,
                    I = _.stencil ? Hs : kr);
                    const B = {
                        colorFormat: 32856,
                        depthFormat: F,
                        scaleFactor: r
                    };
                    c = new XRWebGLBinding(i,t),
                    h = c.createProjectionLayer(B),
                    i.updateRenderState({
                        layers: [h]
                    }),
                    p = new ts(h.textureWidth,h.textureHeight,{
                        format: Jn,
                        type: es,
                        depthTexture: new pD(h.textureWidth,h.textureHeight,I,void 0,void 0,void 0,void 0,void 0,void 0,D),
                        stencilBuffer: _.stencil,
                        encoding: e.outputEncoding,
                        samples: _.antialias ? 4 : 0
                    });
                    const H = e.properties.get(p);
                    H.__ignoreDepthPhilosophy = h.ignoreDepthPhilosophy
                }
                p.isXRRenderTarget = !0,
                this.setFoveation(1),
                l = null,
                s = await i.requestReferenceSpace(a),
                b.setContext(i),
                b.start(),
                n.isPresenting = !0,
                n.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }
        ;
        function G(y) {
            for (let D = 0; D < y.removed.length; D++) {
                const I = y.removed[D]
                  , F = x.indexOf(I);
                F >= 0 && (x[F] = null,
                v[F].dispatchEvent({
                    type: "disconnected",
                    data: I
                }))
            }
            for (let D = 0; D < y.added.length; D++) {
                const I = y.added[D];
                let F = x.indexOf(I);
                if (F === -1) {
                    for (let H = 0; H < v.length; H++)
                        if (H >= x.length) {
                            x.push(I),
                            F = H;
                            break
                        } else if (x[H] === null) {
                            x[H] = I,
                            F = H;
                            break
                        }
                    if (F === -1)
                        break
                }
                const B = v[F];
                B && B.dispatchEvent({
                    type: "connected",
                    data: I
                })
            }
        }
        const q = new X
          , g = new X;
        function w(y, D, I) {
            q.setFromMatrixPosition(D.matrixWorld),
            g.setFromMatrixPosition(I.matrixWorld);
            const F = q.distanceTo(g)
              , B = D.projectionMatrix.elements
              , H = I.projectionMatrix.elements
              , W = B[14] / (B[10] - 1)
              , U = B[14] / (B[10] + 1)
              , K = (B[9] + 1) / B[5]
              , te = (B[9] - 1) / B[5]
              , he = (B[8] - 1) / B[0]
              , ne = (H[8] + 1) / H[0]
              , ce = W * he
              , oe = W * ne
              , ue = F / (-he + ne)
              , Oe = ue * -he;
            D.matrixWorld.decompose(y.position, y.quaternion, y.scale),
            y.translateX(Oe),
            y.translateZ(ue),
            y.matrixWorld.compose(y.position, y.quaternion, y.scale),
            y.matrixWorldInverse.copy(y.matrixWorld).invert();
            const qe = W + ue
              , Ue = U + ue
              , J = ce - Oe
              , Ve = oe + (F - Oe)
              , ye = K * U / Ue * qe
              , Ft = te * U / Ue * qe;
            y.projectionMatrix.makePerspective(J, Ve, ye, Ft, qe, Ue)
        }
        function E(y, D) {
            D === null ? y.matrixWorld.copy(y.matrix) : y.matrixWorld.multiplyMatrices(D.matrixWorld, y.matrix),
            y.matrixWorldInverse.copy(y.matrixWorld).invert()
        }
        this.updateCamera = function(y) {
            if (i === null)
                return;
            L.near = M.near = S.near = y.near,
            L.far = M.far = S.far = y.far,
            (P !== L.near || A !== L.far) && (i.updateRenderState({
                depthNear: L.near,
                depthFar: L.far
            }),
            P = L.near,
            A = L.far);
            const D = y.parent
              , I = L.cameras;
            E(L, D);
            for (let B = 0; B < I.length; B++)
                E(I[B], D);
            L.matrixWorld.decompose(L.position, L.quaternion, L.scale),
            y.matrix.copy(L.matrix),
            y.matrix.decompose(y.position, y.quaternion, y.scale);
            const F = y.children;
            for (let B = 0, H = F.length; B < H; B++)
                F[B].updateMatrixWorld(!0);
            I.length === 2 ? w(L, S, M) : L.projectionMatrix.copy(S.projectionMatrix)
        }
        ,
        this.getCamera = function() {
            return L
        }
        ,
        this.getFoveation = function() {
            if (h !== null)
                return h.fixedFoveation;
            if (f !== null)
                return f.fixedFoveation
        }
        ,
        this.setFoveation = function(y) {
            h !== null && (h.fixedFoveation = y),
            f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = y)
        }
        ;
        let R = null;
        function z(y, D) {
            if (u = D.getViewerPose(l || s),
            m = D,
            u !== null) {
                const I = u.views;
                f !== null && (e.setRenderTargetFramebuffer(p, f.framebuffer),
                e.setRenderTarget(p));
                let F = !1;
                I.length !== L.cameras.length && (L.cameras.length = 0,
                F = !0);
                for (let B = 0; B < I.length; B++) {
                    const H = I[B];
                    let W = null;
                    if (f !== null)
                        W = f.getViewport(H);
                    else {
                        const K = c.getViewSubImage(h, H);
                        W = K.viewport,
                        B === 0 && (e.setRenderTargetTextures(p, K.colorTexture, h.ignoreDepthPhilosophy ? void 0 : K.depthStencilTexture),
                        e.setRenderTarget(p))
                    }
                    let U = T[B];
                    U === void 0 && (U = new un,
                    U.layers.enable(B),
                    U.viewport = new ct,
                    T[B] = U),
                    U.matrix.fromArray(H.transform.matrix),
                    U.projectionMatrix.fromArray(H.projectionMatrix),
                    U.viewport.set(W.x, W.y, W.width, W.height),
                    B === 0 && L.matrix.copy(U.matrix),
                    F === !0 && L.cameras.push(U)
                }
            }
            for (let I = 0; I < v.length; I++) {
                const F = x[I]
                  , B = v[I];
                F !== null && B !== void 0 && B.update(F, D, l || s)
            }
            R && R(y, D),
            m = null
        }
        const b = new t_;
        b.setAnimationLoop(z),
        this.setAnimationLoop = function(y) {
            R = y
        }
        ,
        this.dispose = function() {}
    }
}
function gD(o, e) {
    function t(d, p) {
        d.fogColor.value.copy(p.color),
        p.isFog ? (d.fogNear.value = p.near,
        d.fogFar.value = p.far) : p.isFogExp2 && (d.fogDensity.value = p.density)
    }
    function n(d, p, v, x, S) {
        p.isMeshBasicMaterial || p.isMeshLambertMaterial ? i(d, p) : p.isMeshToonMaterial ? (i(d, p),
        c(d, p)) : p.isMeshPhongMaterial ? (i(d, p),
        u(d, p)) : p.isMeshStandardMaterial ? (i(d, p),
        h(d, p),
        p.isMeshPhysicalMaterial && f(d, p, S)) : p.isMeshMatcapMaterial ? (i(d, p),
        m(d, p)) : p.isMeshDepthMaterial ? i(d, p) : p.isMeshDistanceMaterial ? (i(d, p),
        _(d, p)) : p.isMeshNormalMaterial ? i(d, p) : p.isLineBasicMaterial ? (r(d, p),
        p.isLineDashedMaterial && s(d, p)) : p.isPointsMaterial ? a(d, p, v, x) : p.isSpriteMaterial ? l(d, p) : p.isShadowMaterial ? (d.color.value.copy(p.color),
        d.opacity.value = p.opacity) : p.isShaderMaterial && (p.uniformsNeedUpdate = !1)
    }
    function i(d, p) {
        d.opacity.value = p.opacity,
        p.color && d.diffuse.value.copy(p.color),
        p.emissive && d.emissive.value.copy(p.emissive).multiplyScalar(p.emissiveIntensity),
        p.map && (d.map.value = p.map),
        p.alphaMap && (d.alphaMap.value = p.alphaMap),
        p.bumpMap && (d.bumpMap.value = p.bumpMap,
        d.bumpScale.value = p.bumpScale,
        p.side === Wn && (d.bumpScale.value *= -1)),
        p.displacementMap && (d.displacementMap.value = p.displacementMap,
        d.displacementScale.value = p.displacementScale,
        d.displacementBias.value = p.displacementBias),
        p.emissiveMap && (d.emissiveMap.value = p.emissiveMap),
        p.normalMap && (d.normalMap.value = p.normalMap,
        d.normalScale.value.copy(p.normalScale),
        p.side === Wn && d.normalScale.value.negate()),
        p.specularMap && (d.specularMap.value = p.specularMap),
        p.alphaTest > 0 && (d.alphaTest.value = p.alphaTest);
        const v = e.get(p).envMap;
        if (v && (d.envMap.value = v,
        d.flipEnvMap.value = v.isCubeTexture && v.isRenderTargetTexture === !1 ? -1 : 1,
        d.reflectivity.value = p.reflectivity,
        d.ior.value = p.ior,
        d.refractionRatio.value = p.refractionRatio),
        p.lightMap) {
            d.lightMap.value = p.lightMap;
            const M = o.physicallyCorrectLights !== !0 ? Math.PI : 1;
            d.lightMapIntensity.value = p.lightMapIntensity * M
        }
        p.aoMap && (d.aoMap.value = p.aoMap,
        d.aoMapIntensity.value = p.aoMapIntensity);
        let x;
        p.map ? x = p.map : p.specularMap ? x = p.specularMap : p.displacementMap ? x = p.displacementMap : p.normalMap ? x = p.normalMap : p.bumpMap ? x = p.bumpMap : p.roughnessMap ? x = p.roughnessMap : p.metalnessMap ? x = p.metalnessMap : p.alphaMap ? x = p.alphaMap : p.emissiveMap ? x = p.emissiveMap : p.clearcoatMap ? x = p.clearcoatMap : p.clearcoatNormalMap ? x = p.clearcoatNormalMap : p.clearcoatRoughnessMap ? x = p.clearcoatRoughnessMap : p.iridescenceMap ? x = p.iridescenceMap : p.iridescenceThicknessMap ? x = p.iridescenceThicknessMap : p.specularIntensityMap ? x = p.specularIntensityMap : p.specularColorMap ? x = p.specularColorMap : p.transmissionMap ? x = p.transmissionMap : p.thicknessMap ? x = p.thicknessMap : p.sheenColorMap ? x = p.sheenColorMap : p.sheenRoughnessMap && (x = p.sheenRoughnessMap),
        x !== void 0 && (x.isWebGLRenderTarget && (x = x.texture),
        x.matrixAutoUpdate === !0 && x.updateMatrix(),
        d.uvTransform.value.copy(x.matrix));
        let S;
        p.aoMap ? S = p.aoMap : p.lightMap && (S = p.lightMap),
        S !== void 0 && (S.isWebGLRenderTarget && (S = S.texture),
        S.matrixAutoUpdate === !0 && S.updateMatrix(),
        d.uv2Transform.value.copy(S.matrix))
    }
    function r(d, p) {
        d.diffuse.value.copy(p.color),
        d.opacity.value = p.opacity
    }
    function s(d, p) {
        d.dashSize.value = p.dashSize,
        d.totalSize.value = p.dashSize + p.gapSize,
        d.scale.value = p.scale
    }
    function a(d, p, v, x) {
        d.diffuse.value.copy(p.color),
        d.opacity.value = p.opacity,
        d.size.value = p.size * v,
        d.scale.value = x * .5,
        p.map && (d.map.value = p.map),
        p.alphaMap && (d.alphaMap.value = p.alphaMap),
        p.alphaTest > 0 && (d.alphaTest.value = p.alphaTest);
        let S;
        p.map ? S = p.map : p.alphaMap && (S = p.alphaMap),
        S !== void 0 && (S.matrixAutoUpdate === !0 && S.updateMatrix(),
        d.uvTransform.value.copy(S.matrix))
    }
    function l(d, p) {
        d.diffuse.value.copy(p.color),
        d.opacity.value = p.opacity,
        d.rotation.value = p.rotation,
        p.map && (d.map.value = p.map),
        p.alphaMap && (d.alphaMap.value = p.alphaMap),
        p.alphaTest > 0 && (d.alphaTest.value = p.alphaTest);
        let v;
        p.map ? v = p.map : p.alphaMap && (v = p.alphaMap),
        v !== void 0 && (v.matrixAutoUpdate === !0 && v.updateMatrix(),
        d.uvTransform.value.copy(v.matrix))
    }
    function u(d, p) {
        d.specular.value.copy(p.specular),
        d.shininess.value = Math.max(p.shininess, 1e-4)
    }
    function c(d, p) {
        p.gradientMap && (d.gradientMap.value = p.gradientMap)
    }
    function h(d, p) {
        d.roughness.value = p.roughness,
        d.metalness.value = p.metalness,
        p.roughnessMap && (d.roughnessMap.value = p.roughnessMap),
        p.metalnessMap && (d.metalnessMap.value = p.metalnessMap),
        e.get(p).envMap && (d.envMapIntensity.value = p.envMapIntensity)
    }
    function f(d, p, v) {
        d.ior.value = p.ior,
        p.sheen > 0 && (d.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen),
        d.sheenRoughness.value = p.sheenRoughness,
        p.sheenColorMap && (d.sheenColorMap.value = p.sheenColorMap),
        p.sheenRoughnessMap && (d.sheenRoughnessMap.value = p.sheenRoughnessMap)),
        p.clearcoat > 0 && (d.clearcoat.value = p.clearcoat,
        d.clearcoatRoughness.value = p.clearcoatRoughness,
        p.clearcoatMap && (d.clearcoatMap.value = p.clearcoatMap),
        p.clearcoatRoughnessMap && (d.clearcoatRoughnessMap.value = p.clearcoatRoughnessMap),
        p.clearcoatNormalMap && (d.clearcoatNormalScale.value.copy(p.clearcoatNormalScale),
        d.clearcoatNormalMap.value = p.clearcoatNormalMap,
        p.side === Wn && d.clearcoatNormalScale.value.negate())),
        p.iridescence > 0 && (d.iridescence.value = p.iridescence,
        d.iridescenceIOR.value = p.iridescenceIOR,
        d.iridescenceThicknessMinimum.value = p.iridescenceThicknessRange[0],
        d.iridescenceThicknessMaximum.value = p.iridescenceThicknessRange[1],
        p.iridescenceMap && (d.iridescenceMap.value = p.iridescenceMap),
        p.iridescenceThicknessMap && (d.iridescenceThicknessMap.value = p.iridescenceThicknessMap)),
        p.transmission > 0 && (d.transmission.value = p.transmission,
        d.transmissionSamplerMap.value = v.texture,
        d.transmissionSamplerSize.value.set(v.width, v.height),
        p.transmissionMap && (d.transmissionMap.value = p.transmissionMap),
        d.thickness.value = p.thickness,
        p.thicknessMap && (d.thicknessMap.value = p.thicknessMap),
        d.attenuationDistance.value = p.attenuationDistance,
        d.attenuationColor.value.copy(p.attenuationColor)),
        d.specularIntensity.value = p.specularIntensity,
        d.specularColor.value.copy(p.specularColor),
        p.specularIntensityMap && (d.specularIntensityMap.value = p.specularIntensityMap),
        p.specularColorMap && (d.specularColorMap.value = p.specularColorMap)
    }
    function m(d, p) {
        p.matcap && (d.matcap.value = p.matcap)
    }
    function _(d, p) {
        d.referencePosition.value.copy(p.referencePosition),
        d.nearDistance.value = p.nearDistance,
        d.farDistance.value = p.farDistance
    }
    return {
        refreshFogUniforms: t,
        refreshMaterialUniforms: n
    }
}
function _D(o, e, t, n) {
    let i = {}
      , r = {}
      , s = [];
    const a = t.isWebGL2 ? o.getParameter(35375) : 0;
    function l(x, S) {
        const M = S.program;
        n.uniformBlockBinding(x, M)
    }
    function u(x, S) {
        let M = i[x.id];
        M === void 0 && (_(x),
        M = c(x),
        i[x.id] = M,
        x.addEventListener("dispose", p));
        const T = S.program;
        n.updateUBOMapping(x, T);
        const L = e.render.frame;
        r[x.id] !== L && (f(x),
        r[x.id] = L)
    }
    function c(x) {
        const S = h();
        x.__bindingPointIndex = S;
        const M = o.createBuffer()
          , T = x.__size
          , L = x.usage;
        return o.bindBuffer(35345, M),
        o.bufferData(35345, T, L),
        o.bindBuffer(35345, null),
        o.bindBufferBase(35345, S, M),
        M
    }
    function h() {
        for (let x = 0; x < a; x++)
            if (s.indexOf(x) === -1)
                return s.push(x),
                x;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
        0
    }
    function f(x) {
        const S = i[x.id]
          , M = x.uniforms
          , T = x.__cache;
        o.bindBuffer(35345, S);
        for (let L = 0, P = M.length; L < P; L++) {
            const A = M[L];
            if (m(A, L, T) === !0) {
                const C = A.value
                  , N = A.__offset;
                typeof C == "number" ? (A.__data[0] = C,
                o.bufferSubData(35345, N, A.__data)) : (A.value.isMatrix3 ? (A.__data[0] = A.value.elements[0],
                A.__data[1] = A.value.elements[1],
                A.__data[2] = A.value.elements[2],
                A.__data[3] = A.value.elements[0],
                A.__data[4] = A.value.elements[3],
                A.__data[5] = A.value.elements[4],
                A.__data[6] = A.value.elements[5],
                A.__data[7] = A.value.elements[0],
                A.__data[8] = A.value.elements[6],
                A.__data[9] = A.value.elements[7],
                A.__data[10] = A.value.elements[8],
                A.__data[11] = A.value.elements[0]) : C.toArray(A.__data),
                o.bufferSubData(35345, N, A.__data))
            }
        }
        o.bindBuffer(35345, null)
    }
    function m(x, S, M) {
        const T = x.value;
        if (M[S] === void 0)
            return typeof T == "number" ? M[S] = T : M[S] = T.clone(),
            !0;
        if (typeof T == "number") {
            if (M[S] !== T)
                return M[S] = T,
                !0
        } else {
            const L = M[S];
            if (L.equals(T) === !1)
                return L.copy(T),
                !0
        }
        return !1
    }
    function _(x) {
        const S = x.uniforms;
        let M = 0;
        const T = 16;
        let L = 0;
        for (let P = 0, A = S.length; P < A; P++) {
            const C = S[P]
              , N = d(C);
            if (C.__data = new Float32Array(N.storage / Float32Array.BYTES_PER_ELEMENT),
            C.__offset = M,
            P > 0) {
                L = M % T;
                const G = T - L;
                L !== 0 && G - N.boundary < 0 && (M += T - L,
                C.__offset = M)
            }
            M += N.storage
        }
        return L = M % T,
        L > 0 && (M += T - L),
        x.__size = M,
        x.__cache = {},
        this
    }
    function d(x) {
        const S = x.value
          , M = {
            boundary: 0,
            storage: 0
        };
        return typeof S == "number" ? (M.boundary = 4,
        M.storage = 4) : S.isVector2 ? (M.boundary = 8,
        M.storage = 8) : S.isVector3 || S.isColor ? (M.boundary = 16,
        M.storage = 12) : S.isVector4 ? (M.boundary = 16,
        M.storage = 16) : S.isMatrix3 ? (M.boundary = 48,
        M.storage = 48) : S.isMatrix4 ? (M.boundary = 64,
        M.storage = 64) : S.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", S),
        M
    }
    function p(x) {
        const S = x.target;
        S.removeEventListener("dispose", p);
        const M = s.indexOf(S.__bindingPointIndex);
        s.splice(M, 1),
        o.deleteBuffer(i[S.id]),
        delete i[S.id],
        delete r[S.id]
    }
    function v() {
        for (const x in i)
            o.deleteBuffer(i[x]);
        s = [],
        i = {},
        r = {}
    }
    return {
        bind: l,
        update: u,
        dispose: v
    }
}
function vD() {
    const o = la("canvas");
    return o.style.display = "block",
    o
}
function xD(o={}) {
    this.isWebGLRenderer = !0;
    const e = o.canvas !== void 0 ? o.canvas : vD()
      , t = o.context !== void 0 ? o.context : null
      , n = o.depth !== void 0 ? o.depth : !0
      , i = o.stencil !== void 0 ? o.stencil : !0
      , r = o.antialias !== void 0 ? o.antialias : !1
      , s = o.premultipliedAlpha !== void 0 ? o.premultipliedAlpha : !0
      , a = o.preserveDrawingBuffer !== void 0 ? o.preserveDrawingBuffer : !1
      , l = o.powerPreference !== void 0 ? o.powerPreference : "default"
      , u = o.failIfMajorPerformanceCaveat !== void 0 ? o.failIfMajorPerformanceCaveat : !1;
    let c;
    t !== null ? c = t.getContextAttributes().alpha : c = o.alpha !== void 0 ? o.alpha : !1;
    let h = null
      , f = null;
    const m = []
      , _ = [];
    this.domElement = e,
    this.debug = {
        checkShaderErrors: !0
    },
    this.autoClear = !0,
    this.autoClearColor = !0,
    this.autoClearDepth = !0,
    this.autoClearStencil = !0,
    this.sortObjects = !0,
    this.clippingPlanes = [],
    this.localClippingEnabled = !1,
    this.outputEncoding = pr,
    this.physicallyCorrectLights = !1,
    this.toneMapping = Ui,
    this.toneMappingExposure = 1,
    Object.defineProperties(this, {
        gammaFactor: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),
                2
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")
            }
        }
    });
    const d = this;
    let p = !1
      , v = 0
      , x = 0
      , S = null
      , M = -1
      , T = null;
    const L = new ct
      , P = new ct;
    let A = null
      , C = e.width
      , N = e.height
      , G = 1
      , q = null
      , g = null;
    const w = new ct(0,0,C,N)
      , E = new ct(0,0,C,N);
    let R = !1;
    const z = new mh;
    let b = !1
      , y = !1
      , D = null;
    const I = new Ke
      , F = new Ze
      , B = new X
      , H = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0
    };
    function W() {
        return S === null ? G : 1
    }
    let U = t;
    function K(k, $) {
        for (let Z = 0; Z < k.length; Z++) {
            const Y = k[Z]
              , ie = e.getContext(Y, $);
            if (ie !== null)
                return ie
        }
        return null
    }
    try {
        const k = {
            alpha: !0,
            depth: n,
            stencil: i,
            antialias: r,
            premultipliedAlpha: s,
            preserveDrawingBuffer: a,
            powerPreference: l,
            failIfMajorPerformanceCaveat: u
        };
        if ("setAttribute"in e && e.setAttribute("data-engine", `three.js r${hh}`),
        e.addEventListener("webglcontextlost", Fe, !1),
        e.addEventListener("webglcontextrestored", Ge, !1),
        e.addEventListener("webglcontextcreationerror", Re, !1),
        U === null) {
            const $ = ["webgl2", "webgl", "experimental-webgl"];
            if (d.isWebGL1Renderer === !0 && $.shift(),
            U = K($, k),
            U === null)
                throw K($) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
        }
        U.getShaderPrecisionFormat === void 0 && (U.getShaderPrecisionFormat = function() {
            return {
                rangeMin: 1,
                rangeMax: 1,
                precision: 1
            }
        }
        )
    } catch (k) {
        throw console.error("THREE.WebGLRenderer: " + k.message),
        k
    }
    let te, he, ne, ce, oe, ue, Oe, qe, Ue, J, Ve, ye, Ft, Ct, V, O, re, le, ae, fe, Se, ee, we, ve;
    function De() {
        te = new CS(U),
        he = new MS(U,te,o),
        te.init(he),
        ee = new hD(U,te,he),
        ne = new uD(U,te,he),
        ce = new PS,
        oe = new K1,
        ue = new cD(U,te,ne,oe,he,ee,ce),
        Oe = new DS(d),
        qe = new AS(d),
        Ue = new Hb(U,he),
        we = new bS(U,te,Ue,he),
        J = new LS(U,Ue,ce,we),
        Ve = new NS(U,J,Ue,ce),
        ae = new OS(U,he,ue),
        O = new SS(oe),
        ye = new Y1(d,Oe,qe,te,he,we,O),
        Ft = new gD(d,oe),
        Ct = new Z1,
        V = new iD(te,he),
        le = new yS(d,Oe,ne,Ve,c,s),
        re = new lD(d,Ve,he),
        ve = new _D(U,ce,he,ne),
        fe = new wS(U,te,ce,he),
        Se = new RS(U,te,ce,he),
        ce.programs = ye.programs,
        d.capabilities = he,
        d.extensions = te,
        d.properties = oe,
        d.renderLists = Ct,
        d.shadowMap = re,
        d.state = ne,
        d.info = ce
    }
    De();
    const xe = new mD(d,U);
    this.xr = xe,
    this.getContext = function() {
        return U
    }
    ,
    this.getContextAttributes = function() {
        return U.getContextAttributes()
    }
    ,
    this.forceContextLoss = function() {
        const k = te.get("WEBGL_lose_context");
        k && k.loseContext()
    }
    ,
    this.forceContextRestore = function() {
        const k = te.get("WEBGL_lose_context");
        k && k.restoreContext()
    }
    ,
    this.getPixelRatio = function() {
        return G
    }
    ,
    this.setPixelRatio = function(k) {
        k !== void 0 && (G = k,
        this.setSize(C, N, !1))
    }
    ,
    this.getSize = function(k) {
        return k.set(C, N)
    }
    ,
    this.setSize = function(k, $, Z) {
        if (xe.isPresenting) {
            console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
            return
        }
        C = k,
        N = $,
        e.width = Math.floor(k * G),
        e.height = Math.floor($ * G),
        Z !== !1 && (e.style.width = k + "px",
        e.style.height = $ + "px"),
        this.setViewport(0, 0, k, $)
    }
    ,
    this.getDrawingBufferSize = function(k) {
        return k.set(C * G, N * G).floor()
    }
    ,
    this.setDrawingBufferSize = function(k, $, Z) {
        C = k,
        N = $,
        G = Z,
        e.width = Math.floor(k * Z),
        e.height = Math.floor($ * Z),
        this.setViewport(0, 0, k, $)
    }
    ,
    this.getCurrentViewport = function(k) {
        return k.copy(L)
    }
    ,
    this.getViewport = function(k) {
        return k.copy(w)
    }
    ,
    this.setViewport = function(k, $, Z, Y) {
        k.isVector4 ? w.set(k.x, k.y, k.z, k.w) : w.set(k, $, Z, Y),
        ne.viewport(L.copy(w).multiplyScalar(G).floor())
    }
    ,
    this.getScissor = function(k) {
        return k.copy(E)
    }
    ,
    this.setScissor = function(k, $, Z, Y) {
        k.isVector4 ? E.set(k.x, k.y, k.z, k.w) : E.set(k, $, Z, Y),
        ne.scissor(P.copy(E).multiplyScalar(G).floor())
    }
    ,
    this.getScissorTest = function() {
        return R
    }
    ,
    this.setScissorTest = function(k) {
        ne.setScissorTest(R = k)
    }
    ,
    this.setOpaqueSort = function(k) {
        q = k
    }
    ,
    this.setTransparentSort = function(k) {
        g = k
    }
    ,
    this.getClearColor = function(k) {
        return k.copy(le.getClearColor())
    }
    ,
    this.setClearColor = function() {
        le.setClearColor.apply(le, arguments)
    }
    ,
    this.getClearAlpha = function() {
        return le.getClearAlpha()
    }
    ,
    this.setClearAlpha = function() {
        le.setClearAlpha.apply(le, arguments)
    }
    ,
    this.clear = function(k=!0, $=!0, Z=!0) {
        let Y = 0;
        k && (Y |= 16384),
        $ && (Y |= 256),
        Z && (Y |= 1024),
        U.clear(Y)
    }
    ,
    this.clearColor = function() {
        this.clear(!0, !1, !1)
    }
    ,
    this.clearDepth = function() {
        this.clear(!1, !0, !1)
    }
    ,
    this.clearStencil = function() {
        this.clear(!1, !1, !0)
    }
    ,
    this.dispose = function() {
        e.removeEventListener("webglcontextlost", Fe, !1),
        e.removeEventListener("webglcontextrestored", Ge, !1),
        e.removeEventListener("webglcontextcreationerror", Re, !1),
        Ct.dispose(),
        V.dispose(),
        oe.dispose(),
        Oe.dispose(),
        qe.dispose(),
        Ve.dispose(),
        we.dispose(),
        ve.dispose(),
        ye.dispose(),
        xe.dispose(),
        xe.removeEventListener("sessionstart", Be),
        xe.removeEventListener("sessionend", ht),
        D && (D.dispose(),
        D = null),
        Je.stop()
    }
    ;
    function Fe(k) {
        k.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        p = !0
    }
    function Ge() {
        console.log("THREE.WebGLRenderer: Context Restored."),
        p = !1;
        const k = ce.autoReset
          , $ = re.enabled
          , Z = re.autoUpdate
          , Y = re.needsUpdate
          , ie = re.type;
        De(),
        ce.autoReset = k,
        re.enabled = $,
        re.autoUpdate = Z,
        re.needsUpdate = Y,
        re.type = ie
    }
    function Re(k) {
        console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", k.statusMessage)
    }
    function j(k) {
        const $ = k.target;
        $.removeEventListener("dispose", j),
        de($)
    }
    function de(k) {
        Q(k),
        oe.remove(k)
    }
    function Q(k) {
        const $ = oe.get(k).programs;
        $ !== void 0 && ($.forEach(function(Z) {
            ye.releaseProgram(Z)
        }),
        k.isShaderMaterial && ye.releaseShaderCache(k))
    }
    this.renderBufferDirect = function(k, $, Z, Y, ie, _e) {
        $ === null && ($ = H);
        const be = ie.isMesh && ie.matrixWorld.determinant() < 0
          , Te = bt(k, $, Z, Y, ie);
        ne.setMaterial(Y, be);
        let Pe = Z.index;
        const He = Z.attributes.position;
        if (Pe === null) {
            if (He === void 0 || He.count === 0)
                return
        } else if (Pe.count === 0)
            return;
        let Le = 1;
        Y.wireframe === !0 && (Pe = J.getWireframeAttribute(Z),
        Le = 2),
        we.setup(ie, Y, Te, Z, Pe);
        let Ce, Qe = fe;
        Pe !== null && (Ce = Ue.get(Pe),
        Qe = Se,
        Qe.setIndex(Ce));
        const qn = Pe !== null ? Pe.count : He.count
          , gi = Z.drawRange.start * Le
          , En = Z.drawRange.count * Le
          , An = _e !== null ? _e.start * Le : 0
          , tt = _e !== null ? _e.count * Le : 1 / 0
          , ls = Math.max(gi, An)
          , Mt = Math.min(qn, gi + En, An + tt) - 1
          , Cn = Math.max(0, Mt - ls + 1);
        if (Cn !== 0) {
            if (ie.isMesh)
                Y.wireframe === !0 ? (ne.setLineWidth(Y.wireframeLinewidth * W()),
                Qe.setMode(1)) : Qe.setMode(4);
            else if (ie.isLine) {
                let ji = Y.linewidth;
                ji === void 0 && (ji = 1),
                ne.setLineWidth(ji * W()),
                ie.isLineSegments ? Qe.setMode(1) : ie.isLineLoop ? Qe.setMode(2) : Qe.setMode(3)
            } else
                ie.isPoints ? Qe.setMode(0) : ie.isSprite && Qe.setMode(4);
            if (ie.isInstancedMesh)
                Qe.renderInstances(ls, Cn, ie.count);
            else if (Z.isInstancedBufferGeometry) {
                const ji = Math.min(Z.instanceCount, Z._maxInstanceCount);
                Qe.renderInstances(ls, Cn, ji)
            } else
                Qe.render(ls, Cn)
        }
    }
    ,
    this.compile = function(k, $) {
        function Z(Y, ie, _e) {
            Y.transparent === !0 && Y.side === Oi ? (Y.side = Wn,
            Y.needsUpdate = !0,
            Me(Y, ie, _e),
            Y.side = Jr,
            Y.needsUpdate = !0,
            Me(Y, ie, _e),
            Y.side = Oi) : Me(Y, ie, _e)
        }
        f = V.get(k),
        f.init(),
        _.push(f),
        k.traverseVisible(function(Y) {
            Y.isLight && Y.layers.test($.layers) && (f.pushLight(Y),
            Y.castShadow && f.pushShadow(Y))
        }),
        f.setupLights(d.physicallyCorrectLights),
        k.traverse(function(Y) {
            const ie = Y.material;
            if (ie)
                if (Array.isArray(ie))
                    for (let _e = 0; _e < ie.length; _e++) {
                        const be = ie[_e];
                        Z(be, k, Y)
                    }
                else
                    Z(ie, k, Y)
        }),
        _.pop(),
        f = null
    }
    ;
    let pe = null;
    function me(k) {
        pe && pe(k)
    }
    function Be() {
        Je.stop()
    }
    function ht() {
        Je.start()
    }
    const Je = new t_;
    Je.setAnimationLoop(me),
    typeof self < "u" && Je.setContext(self),
    this.setAnimationLoop = function(k) {
        pe = k,
        xe.setAnimationLoop(k),
        k === null ? Je.stop() : Je.start()
    }
    ,
    xe.addEventListener("sessionstart", Be),
    xe.addEventListener("sessionend", ht),
    this.render = function(k, $) {
        if ($ !== void 0 && $.isCamera !== !0) {
            console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            return
        }
        if (p === !0)
            return;
        k.matrixWorldAutoUpdate === !0 && k.updateMatrixWorld(),
        $.parent === null && $.matrixWorldAutoUpdate === !0 && $.updateMatrixWorld(),
        xe.enabled === !0 && xe.isPresenting === !0 && (xe.cameraAutoUpdate === !0 && xe.updateCamera($),
        $ = xe.getCamera()),
        k.isScene === !0 && k.onBeforeRender(d, k, $, S),
        f = V.get(k, _.length),
        f.init(),
        _.push(f),
        I.multiplyMatrices($.projectionMatrix, $.matrixWorldInverse),
        z.setFromProjectionMatrix(I),
        y = this.localClippingEnabled,
        b = O.init(this.clippingPlanes, y, $),
        h = Ct.get(k, m.length),
        h.init(),
        m.push(h),
        sn(k, $, 0, d.sortObjects),
        h.finish(),
        d.sortObjects === !0 && h.sort(q, g),
        b === !0 && O.beginShadows();
        const Z = f.state.shadowsArray;
        if (re.render(Z, k, $),
        b === !0 && O.endShadows(),
        this.info.autoReset === !0 && this.info.reset(),
        le.render(h, k),
        f.setupLights(d.physicallyCorrectLights),
        $.isArrayCamera) {
            const Y = $.cameras;
            for (let ie = 0, _e = Y.length; ie < _e; ie++) {
                const be = Y[ie];
                st(h, k, be, be.viewport)
            }
        } else
            st(h, k, $);
        S !== null && (ue.updateMultisampleRenderTarget(S),
        ue.updateRenderTargetMipmap(S)),
        k.isScene === !0 && k.onAfterRender(d, k, $),
        we.resetDefaultState(),
        M = -1,
        T = null,
        _.pop(),
        _.length > 0 ? f = _[_.length - 1] : f = null,
        m.pop(),
        m.length > 0 ? h = m[m.length - 1] : h = null
    }
    ;
    function sn(k, $, Z, Y) {
        if (k.visible === !1)
            return;
        if (k.layers.test($.layers)) {
            if (k.isGroup)
                Z = k.renderOrder;
            else if (k.isLOD)
                k.autoUpdate === !0 && k.update($);
            else if (k.isLight)
                f.pushLight(k),
                k.castShadow && f.pushShadow(k);
            else if (k.isSprite) {
                if (!k.frustumCulled || z.intersectsSprite(k)) {
                    Y && B.setFromMatrixPosition(k.matrixWorld).applyMatrix4(I);
                    const be = Ve.update(k)
                      , Te = k.material;
                    Te.visible && h.push(k, be, Te, Z, B.z, null)
                }
            } else if ((k.isMesh || k.isLine || k.isPoints) && (k.isSkinnedMesh && k.skeleton.frame !== ce.render.frame && (k.skeleton.update(),
            k.skeleton.frame = ce.render.frame),
            !k.frustumCulled || z.intersectsObject(k))) {
                Y && B.setFromMatrixPosition(k.matrixWorld).applyMatrix4(I);
                const be = Ve.update(k)
                  , Te = k.material;
                if (Array.isArray(Te)) {
                    const Pe = be.groups;
                    for (let He = 0, Le = Pe.length; He < Le; He++) {
                        const Ce = Pe[He]
                          , Qe = Te[Ce.materialIndex];
                        Qe && Qe.visible && h.push(k, be, Qe, Z, B.z, Ce)
                    }
                } else
                    Te.visible && h.push(k, be, Te, Z, B.z, null)
            }
        }
        const _e = k.children;
        for (let be = 0, Te = _e.length; be < Te; be++)
            sn(_e[be], $, Z, Y)
    }
    function st(k, $, Z, Y) {
        const ie = k.opaque
          , _e = k.transmissive
          , be = k.transparent;
        f.setupLightsView(Z),
        _e.length > 0 && Ne(ie, $, Z),
        Y && ne.viewport(L.copy(Y)),
        ie.length > 0 && se(ie, $, Z),
        _e.length > 0 && se(_e, $, Z),
        be.length > 0 && se(be, $, Z),
        ne.buffers.depth.setTest(!0),
        ne.buffers.depth.setMask(!0),
        ne.buffers.color.setMask(!0),
        ne.setPolygonOffset(!1)
    }
    function Ne(k, $, Z) {
        const Y = he.isWebGL2;
        D === null && (D = new ts(1,1,{
            generateMipmaps: !0,
            type: te.has("EXT_color_buffer_half_float") ? Ni : es,
            minFilter: ss,
            samples: Y && r === !0 ? 4 : 0
        })),
        d.getDrawingBufferSize(F),
        Y ? D.setSize(F.x, F.y) : D.setSize(kl(F.x), kl(F.y));
        const ie = d.getRenderTarget();
        d.setRenderTarget(D),
        d.clear();
        const _e = d.toneMapping;
        d.toneMapping = Ui,
        se(k, $, Z),
        d.toneMapping = _e,
        ue.updateMultisampleRenderTarget(D),
        ue.updateRenderTargetMipmap(D),
        d.setRenderTarget(ie)
    }
    function se(k, $, Z) {
        const Y = $.isScene === !0 ? $.overrideMaterial : null;
        for (let ie = 0, _e = k.length; ie < _e; ie++) {
            const be = k[ie]
              , Te = be.object
              , Pe = be.geometry
              , He = Y === null ? be.material : Y
              , Le = be.group;
            Te.layers.test(Z.layers) && Ee(Te, $, Z, Pe, He, Le)
        }
    }
    function Ee(k, $, Z, Y, ie, _e) {
        k.onBeforeRender(d, $, Z, Y, ie, _e),
        k.modelViewMatrix.multiplyMatrices(Z.matrixWorldInverse, k.matrixWorld),
        k.normalMatrix.getNormalMatrix(k.modelViewMatrix),
        ie.onBeforeRender(d, $, Z, Y, k, _e),
        ie.transparent === !0 && ie.side === Oi ? (ie.side = Wn,
        ie.needsUpdate = !0,
        d.renderBufferDirect(Z, $, Y, ie, k, _e),
        ie.side = Jr,
        ie.needsUpdate = !0,
        d.renderBufferDirect(Z, $, Y, ie, k, _e),
        ie.side = Oi) : d.renderBufferDirect(Z, $, Y, ie, k, _e),
        k.onAfterRender(d, $, Z, Y, ie, _e)
    }
    function Me(k, $, Z) {
        $.isScene !== !0 && ($ = H);
        const Y = oe.get(k)
          , ie = f.state.lights
          , _e = f.state.shadowsArray
          , be = ie.state.version
          , Te = ye.getParameters(k, ie.state, _e, $, Z)
          , Pe = ye.getProgramCacheKey(Te);
        let He = Y.programs;
        Y.environment = k.isMeshStandardMaterial ? $.environment : null,
        Y.fog = $.fog,
        Y.envMap = (k.isMeshStandardMaterial ? qe : Oe).get(k.envMap || Y.environment),
        He === void 0 && (k.addEventListener("dispose", j),
        He = new Map,
        Y.programs = He);
        let Le = He.get(Pe);
        if (Le !== void 0) {
            if (Y.currentProgram === Le && Y.lightsStateVersion === be)
                return Ie(k, Te),
                Le
        } else
            Te.uniforms = ye.getUniforms(k),
            k.onBuild(Z, Te, d),
            k.onBeforeCompile(Te, d),
            Le = ye.acquireProgram(Te, Pe),
            He.set(Pe, Le),
            Y.uniforms = Te.uniforms;
        const Ce = Y.uniforms;
        (!k.isShaderMaterial && !k.isRawShaderMaterial || k.clipping === !0) && (Ce.clippingPlanes = O.uniform),
        Ie(k, Te),
        Y.needsLights = mt(k),
        Y.lightsStateVersion = be,
        Y.needsLights && (Ce.ambientLightColor.value = ie.state.ambient,
        Ce.lightProbe.value = ie.state.probe,
        Ce.directionalLights.value = ie.state.directional,
        Ce.directionalLightShadows.value = ie.state.directionalShadow,
        Ce.spotLights.value = ie.state.spot,
        Ce.spotLightShadows.value = ie.state.spotShadow,
        Ce.rectAreaLights.value = ie.state.rectArea,
        Ce.ltc_1.value = ie.state.rectAreaLTC1,
        Ce.ltc_2.value = ie.state.rectAreaLTC2,
        Ce.pointLights.value = ie.state.point,
        Ce.pointLightShadows.value = ie.state.pointShadow,
        Ce.hemisphereLights.value = ie.state.hemi,
        Ce.directionalShadowMap.value = ie.state.directionalShadowMap,
        Ce.directionalShadowMatrix.value = ie.state.directionalShadowMatrix,
        Ce.spotShadowMap.value = ie.state.spotShadowMap,
        Ce.spotLightMatrix.value = ie.state.spotLightMatrix,
        Ce.spotLightMap.value = ie.state.spotLightMap,
        Ce.pointShadowMap.value = ie.state.pointShadowMap,
        Ce.pointShadowMatrix.value = ie.state.pointShadowMatrix);
        const Qe = Le.getUniforms()
          , qn = wl.seqWithValue(Qe.seq, Ce);
        return Y.currentProgram = Le,
        Y.uniformsList = qn,
        Le
    }
    function Ie(k, $) {
        const Z = oe.get(k);
        Z.outputEncoding = $.outputEncoding,
        Z.instancing = $.instancing,
        Z.skinning = $.skinning,
        Z.morphTargets = $.morphTargets,
        Z.morphNormals = $.morphNormals,
        Z.morphColors = $.morphColors,
        Z.morphTargetsCount = $.morphTargetsCount,
        Z.numClippingPlanes = $.numClippingPlanes,
        Z.numIntersection = $.numClipIntersection,
        Z.vertexAlphas = $.vertexAlphas,
        Z.vertexTangents = $.vertexTangents,
        Z.toneMapping = $.toneMapping
    }
    function bt(k, $, Z, Y, ie) {
        $.isScene !== !0 && ($ = H),
        ue.resetTextureUnits();
        const _e = $.fog
          , be = Y.isMeshStandardMaterial ? $.environment : null
          , Te = S === null ? d.outputEncoding : S.isXRRenderTarget === !0 ? S.texture.encoding : pr
          , Pe = (Y.isMeshStandardMaterial ? qe : Oe).get(Y.envMap || be)
          , He = Y.vertexColors === !0 && !!Z.attributes.color && Z.attributes.color.itemSize === 4
          , Le = !!Y.normalMap && !!Z.attributes.tangent
          , Ce = !!Z.morphAttributes.position
          , Qe = !!Z.morphAttributes.normal
          , qn = !!Z.morphAttributes.color
          , gi = Y.toneMapped ? d.toneMapping : Ui
          , En = Z.morphAttributes.position || Z.morphAttributes.normal || Z.morphAttributes.color
          , An = En !== void 0 ? En.length : 0
          , tt = oe.get(Y)
          , ls = f.state.lights;
        if (b === !0 && (y === !0 || k !== T)) {
            const _n = k === T && Y.id === M;
            O.setState(Y, k, _n)
        }
        let Mt = !1;
        Y.version === tt.__version ? (tt.needsLights && tt.lightsStateVersion !== ls.state.version || tt.outputEncoding !== Te || ie.isInstancedMesh && tt.instancing === !1 || !ie.isInstancedMesh && tt.instancing === !0 || ie.isSkinnedMesh && tt.skinning === !1 || !ie.isSkinnedMesh && tt.skinning === !0 || tt.envMap !== Pe || Y.fog === !0 && tt.fog !== _e || tt.numClippingPlanes !== void 0 && (tt.numClippingPlanes !== O.numPlanes || tt.numIntersection !== O.numIntersection) || tt.vertexAlphas !== He || tt.vertexTangents !== Le || tt.morphTargets !== Ce || tt.morphNormals !== Qe || tt.morphColors !== qn || tt.toneMapping !== gi || he.isWebGL2 === !0 && tt.morphTargetsCount !== An) && (Mt = !0) : (Mt = !0,
        tt.__version = Y.version);
        let Cn = tt.currentProgram;
        Mt === !0 && (Cn = Me(Y, $, ie));
        let ji = !1
          , po = !1
          , Kl = !1;
        const Xt = Cn.getUniforms()
          , xr = tt.uniforms;
        if (ne.useProgram(Cn.program) && (ji = !0,
        po = !0,
        Kl = !0),
        Y.id !== M && (M = Y.id,
        po = !0),
        ji || T !== k) {
            if (Xt.setValue(U, "projectionMatrix", k.projectionMatrix),
            he.logarithmicDepthBuffer && Xt.setValue(U, "logDepthBufFC", 2 / (Math.log(k.far + 1) / Math.LN2)),
            T !== k && (T = k,
            po = !0,
            Kl = !0),
            Y.isShaderMaterial || Y.isMeshPhongMaterial || Y.isMeshToonMaterial || Y.isMeshStandardMaterial || Y.envMap) {
                const _n = Xt.map.cameraPosition;
                _n !== void 0 && _n.setValue(U, B.setFromMatrixPosition(k.matrixWorld))
            }
            (Y.isMeshPhongMaterial || Y.isMeshToonMaterial || Y.isMeshLambertMaterial || Y.isMeshBasicMaterial || Y.isMeshStandardMaterial || Y.isShaderMaterial) && Xt.setValue(U, "isOrthographic", k.isOrthographicCamera === !0),
            (Y.isMeshPhongMaterial || Y.isMeshToonMaterial || Y.isMeshLambertMaterial || Y.isMeshBasicMaterial || Y.isMeshStandardMaterial || Y.isShaderMaterial || Y.isShadowMaterial || ie.isSkinnedMesh) && Xt.setValue(U, "viewMatrix", k.matrixWorldInverse)
        }
        if (ie.isSkinnedMesh) {
            Xt.setOptional(U, ie, "bindMatrix"),
            Xt.setOptional(U, ie, "bindMatrixInverse");
            const _n = ie.skeleton;
            _n && (he.floatVertexTextures ? (_n.boneTexture === null && _n.computeBoneTexture(),
            Xt.setValue(U, "boneTexture", _n.boneTexture, ue),
            Xt.setValue(U, "boneTextureSize", _n.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
        }
        const $l = Z.morphAttributes;
        if (($l.position !== void 0 || $l.normal !== void 0 || $l.color !== void 0 && he.isWebGL2 === !0) && ae.update(ie, Z, Y, Cn),
        (po || tt.receiveShadow !== ie.receiveShadow) && (tt.receiveShadow = ie.receiveShadow,
        Xt.setValue(U, "receiveShadow", ie.receiveShadow)),
        Y.isMeshGouraudMaterial && Y.envMap !== null && (xr.envMap.value = Pe,
        xr.flipEnvMap.value = Pe.isCubeTexture && Pe.isRenderTargetTexture === !1 ? -1 : 1),
        po && (Xt.setValue(U, "toneMappingExposure", d.toneMappingExposure),
        tt.needsLights && ke(xr, Kl),
        _e && Y.fog === !0 && Ft.refreshFogUniforms(xr, _e),
        Ft.refreshMaterialUniforms(xr, Y, G, N, D),
        wl.upload(U, tt.uniformsList, xr, ue)),
        Y.isShaderMaterial && Y.uniformsNeedUpdate === !0 && (wl.upload(U, tt.uniformsList, xr, ue),
        Y.uniformsNeedUpdate = !1),
        Y.isSpriteMaterial && Xt.setValue(U, "center", ie.center),
        Xt.setValue(U, "modelViewMatrix", ie.modelViewMatrix),
        Xt.setValue(U, "normalMatrix", ie.normalMatrix),
        Xt.setValue(U, "modelMatrix", ie.matrixWorld),
        Y.isShaderMaterial || Y.isRawShaderMaterial) {
            const _n = Y.uniformsGroups;
            for (let Zl = 0, x_ = _n.length; Zl < x_; Zl++)
                if (he.isWebGL2) {
                    const Eh = _n[Zl];
                    ve.update(Eh, Cn),
                    ve.bind(Eh, Cn)
                } else
                    console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
        }
        return Cn
    }
    function ke(k, $) {
        k.ambientLightColor.needsUpdate = $,
        k.lightProbe.needsUpdate = $,
        k.directionalLights.needsUpdate = $,
        k.directionalLightShadows.needsUpdate = $,
        k.pointLights.needsUpdate = $,
        k.pointLightShadows.needsUpdate = $,
        k.spotLights.needsUpdate = $,
        k.spotLightShadows.needsUpdate = $,
        k.rectAreaLights.needsUpdate = $,
        k.hemisphereLights.needsUpdate = $
    }
    function mt(k) {
        return k.isMeshLambertMaterial || k.isMeshToonMaterial || k.isMeshPhongMaterial || k.isMeshStandardMaterial || k.isShadowMaterial || k.isShaderMaterial && k.lights === !0
    }
    this.getActiveCubeFace = function() {
        return v
    }
    ,
    this.getActiveMipmapLevel = function() {
        return x
    }
    ,
    this.getRenderTarget = function() {
        return S
    }
    ,
    this.setRenderTargetTextures = function(k, $, Z) {
        oe.get(k.texture).__webglTexture = $,
        oe.get(k.depthTexture).__webglTexture = Z;
        const Y = oe.get(k);
        Y.__hasExternalTextures = !0,
        Y.__hasExternalTextures && (Y.__autoAllocateDepthBuffer = Z === void 0,
        Y.__autoAllocateDepthBuffer || te.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
        Y.__useRenderToTexture = !1))
    }
    ,
    this.setRenderTargetFramebuffer = function(k, $) {
        const Z = oe.get(k);
        Z.__webglFramebuffer = $,
        Z.__useDefaultFramebuffer = $ === void 0
    }
    ,
    this.setRenderTarget = function(k, $=0, Z=0) {
        S = k,
        v = $,
        x = Z;
        let Y = !0;
        if (k) {
            const Pe = oe.get(k);
            Pe.__useDefaultFramebuffer !== void 0 ? (ne.bindFramebuffer(36160, null),
            Y = !1) : Pe.__webglFramebuffer === void 0 ? ue.setupRenderTarget(k) : Pe.__hasExternalTextures && ue.rebindTextures(k, oe.get(k.texture).__webglTexture, oe.get(k.depthTexture).__webglTexture)
        }
        let ie = null
          , _e = !1
          , be = !1;
        if (k) {
            const Pe = k.texture;
            (Pe.isData3DTexture || Pe.isDataArrayTexture) && (be = !0);
            const He = oe.get(k).__webglFramebuffer;
            k.isWebGLCubeRenderTarget ? (ie = He[$],
            _e = !0) : he.isWebGL2 && k.samples > 0 && ue.useMultisampledRTT(k) === !1 ? ie = oe.get(k).__webglMultisampledFramebuffer : ie = He,
            L.copy(k.viewport),
            P.copy(k.scissor),
            A = k.scissorTest
        } else
            L.copy(w).multiplyScalar(G).floor(),
            P.copy(E).multiplyScalar(G).floor(),
            A = R;
        if (ne.bindFramebuffer(36160, ie) && he.drawBuffers && Y && ne.drawBuffers(k, ie),
        ne.viewport(L),
        ne.scissor(P),
        ne.setScissorTest(A),
        _e) {
            const Pe = oe.get(k.texture);
            U.framebufferTexture2D(36160, 36064, 34069 + $, Pe.__webglTexture, Z)
        } else if (be) {
            const Pe = oe.get(k.texture)
              , He = $ || 0;
            U.framebufferTextureLayer(36160, 36064, Pe.__webglTexture, Z || 0, He)
        }
        M = -1
    }
    ,
    this.readRenderTargetPixels = function(k, $, Z, Y, ie, _e, be) {
        if (!(k && k.isWebGLRenderTarget)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            return
        }
        let Te = oe.get(k).__webglFramebuffer;
        if (k.isWebGLCubeRenderTarget && be !== void 0 && (Te = Te[be]),
        Te) {
            ne.bindFramebuffer(36160, Te);
            try {
                const Pe = k.texture
                  , He = Pe.format
                  , Le = Pe.type;
                if (He !== Jn && ee.convert(He) !== U.getParameter(35739)) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    return
                }
                const Ce = Le === Ni && (te.has("EXT_color_buffer_half_float") || he.isWebGL2 && te.has("EXT_color_buffer_float"));
                if (Le !== es && ee.convert(Le) !== U.getParameter(35738) && !(Le === Qn && (he.isWebGL2 || te.has("OES_texture_float") || te.has("WEBGL_color_buffer_float"))) && !Ce) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    return
                }
                $ >= 0 && $ <= k.width - Y && Z >= 0 && Z <= k.height - ie && U.readPixels($, Z, Y, ie, ee.convert(He), ee.convert(Le), _e)
            } finally {
                const Pe = S !== null ? oe.get(S).__webglFramebuffer : null;
                ne.bindFramebuffer(36160, Pe)
            }
        }
    }
    ,
    this.copyFramebufferToTexture = function(k, $, Z=0) {
        const Y = Math.pow(2, -Z)
          , ie = Math.floor($.image.width * Y)
          , _e = Math.floor($.image.height * Y);
        ue.setTexture2D($, 0),
        U.copyTexSubImage2D(3553, Z, 0, 0, k.x, k.y, ie, _e),
        ne.unbindTexture()
    }
    ,
    this.copyTextureToTexture = function(k, $, Z, Y=0) {
        const ie = $.image.width
          , _e = $.image.height
          , be = ee.convert(Z.format)
          , Te = ee.convert(Z.type);
        ue.setTexture2D(Z, 0),
        U.pixelStorei(37440, Z.flipY),
        U.pixelStorei(37441, Z.premultiplyAlpha),
        U.pixelStorei(3317, Z.unpackAlignment),
        $.isDataTexture ? U.texSubImage2D(3553, Y, k.x, k.y, ie, _e, be, Te, $.image.data) : $.isCompressedTexture ? U.compressedTexSubImage2D(3553, Y, k.x, k.y, $.mipmaps[0].width, $.mipmaps[0].height, be, $.mipmaps[0].data) : U.texSubImage2D(3553, Y, k.x, k.y, be, Te, $.image),
        Y === 0 && Z.generateMipmaps && U.generateMipmap(3553),
        ne.unbindTexture()
    }
    ,
    this.copyTextureToTexture3D = function(k, $, Z, Y, ie=0) {
        if (d.isWebGL1Renderer) {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
            return
        }
        const _e = k.max.x - k.min.x + 1
          , be = k.max.y - k.min.y + 1
          , Te = k.max.z - k.min.z + 1
          , Pe = ee.convert(Y.format)
          , He = ee.convert(Y.type);
        let Le;
        if (Y.isData3DTexture)
            ue.setTexture3D(Y, 0),
            Le = 32879;
        else if (Y.isDataArrayTexture)
            ue.setTexture2DArray(Y, 0),
            Le = 35866;
        else {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
            return
        }
        U.pixelStorei(37440, Y.flipY),
        U.pixelStorei(37441, Y.premultiplyAlpha),
        U.pixelStorei(3317, Y.unpackAlignment);
        const Ce = U.getParameter(3314)
          , Qe = U.getParameter(32878)
          , qn = U.getParameter(3316)
          , gi = U.getParameter(3315)
          , En = U.getParameter(32877)
          , An = Z.isCompressedTexture ? Z.mipmaps[0] : Z.image;
        U.pixelStorei(3314, An.width),
        U.pixelStorei(32878, An.height),
        U.pixelStorei(3316, k.min.x),
        U.pixelStorei(3315, k.min.y),
        U.pixelStorei(32877, k.min.z),
        Z.isDataTexture || Z.isData3DTexture ? U.texSubImage3D(Le, ie, $.x, $.y, $.z, _e, be, Te, Pe, He, An.data) : Z.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),
        U.compressedTexSubImage3D(Le, ie, $.x, $.y, $.z, _e, be, Te, Pe, An.data)) : U.texSubImage3D(Le, ie, $.x, $.y, $.z, _e, be, Te, Pe, He, An),
        U.pixelStorei(3314, Ce),
        U.pixelStorei(32878, Qe),
        U.pixelStorei(3316, qn),
        U.pixelStorei(3315, gi),
        U.pixelStorei(32877, En),
        ie === 0 && Y.generateMipmaps && U.generateMipmap(Le),
        ne.unbindTexture()
    }
    ,
    this.initTexture = function(k) {
        k.isCubeTexture ? ue.setTextureCube(k, 0) : k.isData3DTexture ? ue.setTexture3D(k, 0) : k.isDataArrayTexture ? ue.setTexture2DArray(k, 0) : ue.setTexture2D(k, 0),
        ne.unbindTexture()
    }
    ,
    this.resetState = function() {
        v = 0,
        x = 0,
        S = null,
        ne.reset(),
        we.reset()
    }
    ,
    typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
        detail: this
    }))
}
class yD extends xD {
}
yD.prototype.isWebGL1Renderer = !0;
class KT extends yt {
    constructor() {
        super(),
        this.isScene = !0,
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.overrideMaterial = null,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    copy(e, t) {
        return super.copy(e, t),
        e.background !== null && (this.background = e.background.clone()),
        e.environment !== null && (this.environment = e.environment.clone()),
        e.fog !== null && (this.fog = e.fog.clone()),
        e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.fog !== null && (t.object.fog = this.fog.toJSON()),
        t
    }
    get autoUpdate() {
        return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),
        this.matrixWorldAutoUpdate
    }
    set autoUpdate(e) {
        console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),
        this.matrixWorldAutoUpdate = e
    }
}
class bD {
    constructor(e, t) {
        this.isInterleavedBuffer = !0,
        this.array = e,
        this.stride = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.usage = Lc,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0,
        this.uuid = ti()
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    copy(e) {
        return this.array = new e.array.constructor(e.array),
        this.count = e.count,
        this.stride = e.stride,
        this.usage = e.usage,
        this
    }
    copyAt(e, t, n) {
        e *= this.stride,
        n *= t.stride;
        for (let i = 0, r = this.stride; i < r; i++)
            this.array[e + i] = t.array[n + i];
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    clone(e) {
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ti()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
          , n = new this.constructor(t,this.stride);
        return n.setUsage(this.usage),
        n
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    toJSON(e) {
        return e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ti()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
        {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
const Kt = new X;
class xh {
    constructor(e, t, n, i=!1) {
        this.isInterleavedBufferAttribute = !0,
        this.name = "",
        this.data = e,
        this.itemSize = t,
        this.offset = n,
        this.normalized = i === !0
    }
    get count() {
        return this.data.count
    }
    get array() {
        return this.data.array
    }
    set needsUpdate(e) {
        this.data.needsUpdate = e
    }
    applyMatrix4(e) {
        for (let t = 0, n = this.data.count; t < n; t++)
            Kt.fromBufferAttribute(this, t),
            Kt.applyMatrix4(e),
            this.setXYZ(t, Kt.x, Kt.y, Kt.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, n = this.count; t < n; t++)
            Kt.fromBufferAttribute(this, t),
            Kt.applyNormalMatrix(e),
            this.setXYZ(t, Kt.x, Kt.y, Kt.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, n = this.count; t < n; t++)
            Kt.fromBufferAttribute(this, t),
            Kt.transformDirection(e),
            this.setXYZ(t, Kt.x, Kt.y, Kt.z);
        return this
    }
    setX(e, t) {
        return this.normalized && (t = lt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset] = t,
        this
    }
    setY(e, t) {
        return this.normalized && (t = lt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 1] = t,
        this
    }
    setZ(e, t) {
        return this.normalized && (t = lt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 2] = t,
        this
    }
    setW(e, t) {
        return this.normalized && (t = lt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 3] = t,
        this
    }
    getX(e) {
        let t = this.data.array[e * this.data.stride + this.offset];
        return this.normalized && (t = ki(t, this.array)),
        t
    }
    getY(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 1];
        return this.normalized && (t = ki(t, this.array)),
        t
    }
    getZ(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 2];
        return this.normalized && (t = ki(t, this.array)),
        t
    }
    getW(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 3];
        return this.normalized && (t = ki(t, this.array)),
        t
    }
    setXY(e, t, n) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = lt(t, this.array),
        n = lt(n, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = n,
        this
    }
    setXYZ(e, t, n, i) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = lt(t, this.array),
        n = lt(n, this.array),
        i = lt(i, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = n,
        this.data.array[e + 2] = i,
        this
    }
    setXYZW(e, t, n, i, r) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = lt(t, this.array),
        n = lt(n, this.array),
        i = lt(i, this.array),
        r = lt(r, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = n,
        this.data.array[e + 2] = i,
        this.data.array[e + 3] = r,
        this
    }
    clone(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.");
            const t = [];
            for (let n = 0; n < this.count; n++) {
                const i = n * this.data.stride + this.offset;
                for (let r = 0; r < this.itemSize; r++)
                    t.push(this.data.array[i + r])
            }
            return new gn(new this.array.constructor(t),this.itemSize,this.normalized)
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
            new xh(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
    }
    toJSON(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.");
            const t = [];
            for (let n = 0; n < this.count; n++) {
                const i = n * this.data.stride + this.offset;
                for (let r = 0; r < this.itemSize; r++)
                    t.push(this.data.array[i + r])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized
            }
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
            {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
    }
}
const Qd = new X
  , Jd = new ct
  , ep = new ct
  , wD = new X
  , tp = new Ke;
class MD extends Vn {
    constructor(e, t) {
        super(e, t),
        this.isSkinnedMesh = !0,
        this.type = "SkinnedMesh",
        this.bindMode = "attached",
        this.bindMatrix = new Ke,
        this.bindMatrixInverse = new Ke
    }
    copy(e, t) {
        return super.copy(e, t),
        this.bindMode = e.bindMode,
        this.bindMatrix.copy(e.bindMatrix),
        this.bindMatrixInverse.copy(e.bindMatrixInverse),
        this.skeleton = e.skeleton,
        this
    }
    bind(e, t) {
        this.skeleton = e,
        t === void 0 && (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        t = this.matrixWorld),
        this.bindMatrix.copy(t),
        this.bindMatrixInverse.copy(t).invert()
    }
    pose() {
        this.skeleton.pose()
    }
    normalizeSkinWeights() {
        const e = new ct
          , t = this.geometry.attributes.skinWeight;
        for (let n = 0, i = t.count; n < i; n++) {
            e.fromBufferAttribute(t, n);
            const r = 1 / e.manhattanLength();
            r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0),
            t.setXYZW(n, e.x, e.y, e.z, e.w)
        }
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }
    boneTransform(e, t) {
        const n = this.skeleton
          , i = this.geometry;
        Jd.fromBufferAttribute(i.attributes.skinIndex, e),
        ep.fromBufferAttribute(i.attributes.skinWeight, e),
        Qd.copy(t).applyMatrix4(this.bindMatrix),
        t.set(0, 0, 0);
        for (let r = 0; r < 4; r++) {
            const s = ep.getComponent(r);
            if (s !== 0) {
                const a = Jd.getComponent(r);
                tp.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]),
                t.addScaledVector(wD.copy(Qd).applyMatrix4(tp), s)
            }
        }
        return t.applyMatrix4(this.bindMatrixInverse)
    }
}
class o_ extends yt {
    constructor() {
        super(),
        this.isBone = !0,
        this.type = "Bone"
    }
}
class a_ extends tn {
    constructor(e=null, t=1, n=1, i, r, s, a, l, u=Vt, c=Vt, h, f) {
        super(null, s, a, l, u, c, i, r, h, f),
        this.isDataTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: n
        },
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
const np = new Ke
  , SD = new Ke;
class yh {
    constructor(e=[], t=[]) {
        this.uuid = ti(),
        this.bones = e.slice(0),
        this.boneInverses = t,
        this.boneMatrices = null,
        this.boneTexture = null,
        this.boneTextureSize = 0,
        this.frame = -1,
        this.init()
    }
    init() {
        const e = this.bones
          , t = this.boneInverses;
        if (this.boneMatrices = new Float32Array(e.length * 16),
        t.length === 0)
            this.calculateInverses();
        else if (e.length !== t.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
            this.boneInverses = [];
            for (let n = 0, i = this.bones.length; n < i; n++)
                this.boneInverses.push(new Ke)
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = new Ke;
            this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(),
            this.boneInverses.push(n)
        }
    }
    pose() {
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = this.bones[e];
            n && n.matrixWorld.copy(this.boneInverses[e]).invert()
        }
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = this.bones[e];
            n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(),
            n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld),
            n.matrix.decompose(n.position, n.quaternion, n.scale))
        }
    }
    update() {
        const e = this.bones
          , t = this.boneInverses
          , n = this.boneMatrices
          , i = this.boneTexture;
        for (let r = 0, s = e.length; r < s; r++) {
            const a = e[r] ? e[r].matrixWorld : SD;
            np.multiplyMatrices(a, t[r]),
            np.toArray(n, r * 16)
        }
        i !== null && (i.needsUpdate = !0)
    }
    clone() {
        return new yh(this.bones,this.boneInverses)
    }
    computeBoneTexture() {
        let e = Math.sqrt(this.bones.length * 4);
        e = Wg(e),
        e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4);
        t.set(this.boneMatrices);
        const n = new a_(t,e,e,Jn,Qn);
        return n.needsUpdate = !0,
        this.boneMatrices = t,
        this.boneTexture = n,
        this.boneTextureSize = e,
        this
    }
    getBoneByName(e) {
        for (let t = 0, n = this.bones.length; t < n; t++) {
            const i = this.bones[t];
            if (i.name === e)
                return i
        }
    }
    dispose() {
        this.boneTexture !== null && (this.boneTexture.dispose(),
        this.boneTexture = null)
    }
    fromJSON(e, t) {
        this.uuid = e.uuid;
        for (let n = 0, i = e.bones.length; n < i; n++) {
            const r = e.bones[n];
            let s = t[r];
            s === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", r),
            s = new o_),
            this.bones.push(s),
            this.boneInverses.push(new Ke().fromArray(e.boneInverses[n]))
        }
        return this.init(),
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.5,
                type: "Skeleton",
                generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
        };
        e.uuid = this.uuid;
        const t = this.bones
          , n = this.boneInverses;
        for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i];
            e.bones.push(s.uuid);
            const a = n[i];
            e.boneInverses.push(a.toArray())
        }
        return e
    }
}
class ip extends gn {
    constructor(e, t, n, i=1) {
        super(e, t, n),
        this.isInstancedBufferAttribute = !0,
        this.meshPerAttribute = i
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.meshPerAttribute = this.meshPerAttribute,
        e.isInstancedBufferAttribute = !0,
        e
    }
}
const rp = new Ke
  , sp = new Ke
  , nl = []
  , wo = new Vn;
class $T extends Vn {
    constructor(e, t, n) {
        super(e, t),
        this.isInstancedMesh = !0,
        this.instanceMatrix = new ip(new Float32Array(n * 16),16),
        this.instanceColor = null,
        this.count = n,
        this.frustumCulled = !1
    }
    copy(e, t) {
        return super.copy(e, t),
        this.instanceMatrix.copy(e.instanceMatrix),
        e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()),
        this.count = e.count,
        this
    }
    getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, e * 3)
    }
    getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, e * 16)
    }
    raycast(e, t) {
        const n = this.matrixWorld
          , i = this.count;
        if (wo.geometry = this.geometry,
        wo.material = this.material,
        wo.material !== void 0)
            for (let r = 0; r < i; r++) {
                this.getMatrixAt(r, rp),
                sp.multiplyMatrices(n, rp),
                wo.matrixWorld = sp,
                wo.raycast(e, nl);
                for (let s = 0, a = nl.length; s < a; s++) {
                    const l = nl[s];
                    l.instanceId = r,
                    l.object = this,
                    t.push(l)
                }
                nl.length = 0
            }
    }
    setColorAt(e, t) {
        this.instanceColor === null && (this.instanceColor = new ip(new Float32Array(this.instanceMatrix.count * 3),3)),
        t.toArray(this.instanceColor.array, e * 3)
    }
    setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, e * 16)
    }
    updateMorphTargets() {}
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class l_ extends fi {
    constructor(e) {
        super(),
        this.isLineBasicMaterial = !0,
        this.type = "LineBasicMaterial",
        this.color = new ze(16777215),
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.fog = !0,
        this.setPhilosophy(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.linewidth = e.linewidth,
        this.linecap = e.linecap,
        this.linejoin = e.linejoin,
        this.fog = e.fog,
        this
    }
}
const op = new X
  , ap = new X
  , lp = new Ke
  , Ku = new ph
  , il = new lo;
class bh extends yt {
    constructor(e=new pi, t=new l_) {
        super(),
        this.isLine = !0,
        this.type = "Line",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = e.material,
        this.geometry = e.geometry,
        this
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , n = [0];
            for (let i = 1, r = t.count; i < r; i++)
                op.fromBufferAttribute(t, i - 1),
                ap.fromBufferAttribute(t, i),
                n[i] = n[i - 1],
                n[i] += op.distanceTo(ap);
            e.setAttribute("lineDistance", new Bi(n,1))
        } else
            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
    raycast(e, t) {
        const n = this.geometry
          , i = this.matrixWorld
          , r = e.params.Line.threshold
          , s = n.drawRange;
        if (n.boundingSphere === null && n.computeBoundingSphere(),
        il.copy(n.boundingSphere),
        il.applyMatrix4(i),
        il.radius += r,
        e.ray.intersectsSphere(il) === !1)
            return;
        lp.copy(i).invert(),
        Ku.copy(e.ray).applyMatrix4(lp);
        const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , l = a * a
          , u = new X
          , c = new X
          , h = new X
          , f = new X
          , m = this.isLineSegments ? 2 : 1
          , _ = n.index
          , p = n.attributes.position;
        if (_ !== null) {
            const v = Math.max(0, s.start)
              , x = Math.min(_.count, s.start + s.count);
            for (let S = v, M = x - 1; S < M; S += m) {
                const T = _.getX(S)
                  , L = _.getX(S + 1);
                if (u.fromBufferAttribute(p, T),
                c.fromBufferAttribute(p, L),
                Ku.distanceSqToSegment(u, c, f, h) > l)
                    continue;
                f.applyMatrix4(this.matrixWorld);
                const A = e.ray.origin.distanceTo(f);
                A < e.near || A > e.far || t.push({
                    distance: A,
                    point: h.clone().applyMatrix4(this.matrixWorld),
                    index: S,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        } else {
            const v = Math.max(0, s.start)
              , x = Math.min(p.count, s.start + s.count);
            for (let S = v, M = x - 1; S < M; S += m) {
                if (u.fromBufferAttribute(p, S),
                c.fromBufferAttribute(p, S + 1),
                Ku.distanceSqToSegment(u, c, f, h) > l)
                    continue;
                f.applyMatrix4(this.matrixWorld);
                const L = e.ray.origin.distanceTo(f);
                L < e.near || L > e.far || t.push({
                    distance: L,
                    point: h.clone().applyMatrix4(this.matrixWorld),
                    index: S,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , n = Object.keys(t);
        if (n.length > 0) {
            const i = t[n[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let r = 0, s = i.length; r < s; r++) {
                    const a = i[r].name || String(r);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = r
                }
            }
        }
    }
}
const up = new X
  , cp = new X;
class DD extends bh {
    constructor(e, t) {
        super(e, t),
        this.isLineSegments = !0,
        this.type = "LineSegments"
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , n = [];
            for (let i = 0, r = t.count; i < r; i += 2)
                up.fromBufferAttribute(t, i),
                cp.fromBufferAttribute(t, i + 1),
                n[i] = i === 0 ? 0 : n[i - 1],
                n[i + 1] = n[i] + up.distanceTo(cp);
            e.setAttribute("lineDistance", new Bi(n,1))
        } else
            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
}
class TD extends bh {
    constructor(e, t) {
        super(e, t),
        this.isLineLoop = !0,
        this.type = "LineLoop"
    }
}
class u_ extends fi {
    constructor(e) {
        super(),
        this.isPointsMaterial = !0,
        this.type = "PointsMaterial",
        this.color = new ze(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.fog = !0,
        this.setPhilosophy(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.size = e.size,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
const hp = new Ke
  , Fc = new ph
  , rl = new lo
  , sl = new X;
class ED extends yt {
    constructor(e=new pi, t=new u_) {
        super(),
        this.isPoints = !0,
        this.type = "Points",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = e.material,
        this.geometry = e.geometry,
        this
    }
    raycast(e, t) {
        const n = this.geometry
          , i = this.matrixWorld
          , r = e.params.Points.threshold
          , s = n.drawRange;
        if (n.boundingSphere === null && n.computeBoundingSphere(),
        rl.copy(n.boundingSphere),
        rl.applyMatrix4(i),
        rl.radius += r,
        e.ray.intersectsSphere(rl) === !1)
            return;
        hp.copy(i).invert(),
        Fc.copy(e.ray).applyMatrix4(hp);
        const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , l = a * a
          , u = n.index
          , h = n.attributes.position;
        if (u !== null) {
            const f = Math.max(0, s.start)
              , m = Math.min(u.count, s.start + s.count);
            for (let _ = f, d = m; _ < d; _++) {
                const p = u.getX(_);
                sl.fromBufferAttribute(h, p),
                fp(sl, p, l, i, e, t, this)
            }
        } else {
            const f = Math.max(0, s.start)
              , m = Math.min(h.count, s.start + s.count);
            for (let _ = f, d = m; _ < d; _++)
                sl.fromBufferAttribute(h, _),
                fp(sl, _, l, i, e, t, this)
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , n = Object.keys(t);
        if (n.length > 0) {
            const i = t[n[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let r = 0, s = i.length; r < s; r++) {
                    const a = i[r].name || String(r);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = r
                }
            }
        }
    }
}
function fp(o, e, t, n, i, r, s) {
    const a = Fc.distanceSqToPoint(o);
    if (a < t) {
        const l = new X;
        Fc.closestPointToPoint(o, l),
        l.applyMatrix4(n);
        const u = i.ray.origin.distanceTo(l);
        if (u < i.near || u > i.far)
            return;
        r.push({
            distance: u,
            distanceToRay: Math.sqrt(a),
            point: l,
            index: e,
            face: null,
            object: s
        })
    }
}
class ZT extends mr {
    constructor(e) {
        super(e),
        this.isRawShaderMaterial = !0,
        this.type = "RawShaderMaterial"
    }
}
class Xl extends fi {
    constructor(e) {
        super(),
        this.isMeshStandardMaterial = !0,
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new ze(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new ze(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = fh,
        this.normalScale = new Ze(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapIntensity = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setPhilosophy(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(e.color),
        this.roughness = e.roughness,
        this.metalness = e.metalness,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.roughnessMap = e.roughnessMap,
        this.metalnessMap = e.metalnessMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapIntensity = e.envMapIntensity,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class as extends Xl {
    constructor(e) {
        super(),
        this.isMeshPhysicalMaterial = !0,
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.clearcoatMap = null,
        this.clearcoatRoughness = 0,
        this.clearcoatRoughnessMap = null,
        this.clearcoatNormalScale = new Ze(1,1),
        this.clearcoatNormalMap = null,
        this.ior = 1.5,
        Object.defineProperty(this, "reflectivity", {
            get: function() {
                return Wt(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function(t) {
                this.ior = (1 + .4 * t) / (1 - .4 * t)
            }
        }),
        this.iridescenceMap = null,
        this.iridescenceIOR = 1.3,
        this.iridescenceThicknessRange = [100, 400],
        this.iridescenceThicknessMap = null,
        this.sheenColor = new ze(0),
        this.sheenColorMap = null,
        this.sheenRoughness = 1,
        this.sheenRoughnessMap = null,
        this.transmissionMap = null,
        this.thickness = 0,
        this.thicknessMap = null,
        this.attenuationDistance = 0,
        this.attenuationColor = new ze(1,1,1),
        this.specularIntensity = 1,
        this.specularIntensityMap = null,
        this.specularColor = new ze(1,1,1),
        this.specularColorMap = null,
        this._sheen = 0,
        this._clearcoat = 0,
        this._iridescence = 0,
        this._transmission = 0,
        this.setPhilosophy(e)
    }
    get sheen() {
        return this._sheen
    }
    set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++,
        this._sheen = e
    }
    get clearcoat() {
        return this._clearcoat
    }
    set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++,
        this._clearcoat = e
    }
    get iridescence() {
        return this._iridescence
    }
    set iridescence(e) {
        this._iridescence > 0 != e > 0 && this.version++,
        this._iridescence = e
    }
    get transmission() {
        return this._transmission
    }
    set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++,
        this._transmission = e
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.clearcoat = e.clearcoat,
        this.clearcoatMap = e.clearcoatMap,
        this.clearcoatRoughness = e.clearcoatRoughness,
        this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
        this.clearcoatNormalMap = e.clearcoatNormalMap,
        this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
        this.ior = e.ior,
        this.iridescence = e.iridescence,
        this.iridescenceMap = e.iridescenceMap,
        this.iridescenceIOR = e.iridescenceIOR,
        this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
        this.iridescenceThicknessMap = e.iridescenceThicknessMap,
        this.sheen = e.sheen,
        this.sheenColor.copy(e.sheenColor),
        this.sheenColorMap = e.sheenColorMap,
        this.sheenRoughness = e.sheenRoughness,
        this.sheenRoughnessMap = e.sheenRoughnessMap,
        this.transmission = e.transmission,
        this.transmissionMap = e.transmissionMap,
        this.thickness = e.thickness,
        this.thicknessMap = e.thicknessMap,
        this.attenuationDistance = e.attenuationDistance,
        this.attenuationColor.copy(e.attenuationColor),
        this.specularIntensity = e.specularIntensity,
        this.specularIntensityMap = e.specularIntensityMap,
        this.specularColor.copy(e.specularColor),
        this.specularColorMap = e.specularColorMap,
        this
    }
}
function er(o, e, t) {
    return c_(o) ? new o.constructor(o.subarray(e, t !== void 0 ? t : o.length)) : o.slice(e, t)
}
function ol(o, e, t) {
    return !o || !t && o.constructor === e ? o : typeof e.BYTES_PER_ELEMENT == "number" ? new e(o) : Array.prototype.slice.call(o)
}
function c_(o) {
    return ArrayBuffer.isView(o) && !(o instanceof DataView)
}
function AD(o) {
    function e(i, r) {
        return o[i] - o[r]
    }
    const t = o.length
      , n = new Array(t);
    for (let i = 0; i !== t; ++i)
        n[i] = i;
    return n.sort(e),
    n
}
function dp(o, e, t) {
    const n = o.length
      , i = new o.constructor(n);
    for (let r = 0, s = 0; s !== n; ++r) {
        const a = t[r] * e;
        for (let l = 0; l !== e; ++l)
            i[s++] = o[a + l]
    }
    return i
}
function h_(o, e, t, n) {
    let i = 1
      , r = o[0];
    for (; r !== void 0 && r[n] === void 0; )
        r = o[i++];
    if (r === void 0)
        return;
    let s = r[n];
    if (s !== void 0)
        if (Array.isArray(s))
            do
                s = r[n],
                s !== void 0 && (e.push(r.time),
                t.push.apply(t, s)),
                r = o[i++];
            while (r !== void 0);
        else if (s.toArray !== void 0)
            do
                s = r[n],
                s !== void 0 && (e.push(r.time),
                s.toArray(t, t.length)),
                r = o[i++];
            while (r !== void 0);
        else
            do
                s = r[n],
                s !== void 0 && (e.push(r.time),
                t.push(s)),
                r = o[i++];
            while (r !== void 0)
}
class _a {
    constructor(e, t, n, i) {
        this.parameterPositions = e,
        this._cachedIndex = 0,
        this.resultBuffer = i !== void 0 ? i : new t.constructor(n),
        this.samplePhilosophy = t,
        this.valueSize = n,
        this.settings = null,
        this.DefaultSettings_ = {}
    }
    evaluate(e) {
        const t = this.parameterPositions;
        let n = this._cachedIndex
          , i = t[n]
          , r = t[n - 1];
        n: {
            e: {
                let s;
                t: {
                    i: if (!(e < i)) {
                        for (let a = n + 2; ; ) {
                            if (i === void 0) {
                                if (e < r)
                                    break i;
                                return n = t.length,
                                this._cachedIndex = n,
                                this.copySampleValue_(n - 1)
                            }
                            if (n === a)
                                break;
                            if (r = i,
                            i = t[++n],
                            e < i)
                                break e
                        }
                        s = t.length;
                        break t
                    }
                    if (!(e >= r)) {
                        const a = t[1];
                        e < a && (n = 2,
                        r = a);
                        for (let l = n - 2; ; ) {
                            if (r === void 0)
                                return this._cachedIndex = 0,
                                this.copySampleValue_(0);
                            if (n === l)
                                break;
                            if (i = r,
                            r = t[--n - 1],
                            e >= r)
                                break e
                        }
                        s = n,
                        n = 0;
                        break t
                    }
                    break n
                }
                for (; n < s; ) {
                    const a = n + s >>> 1;
                    e < t[a] ? s = a : n = a + 1
                }
                if (i = t[n],
                r = t[n - 1],
                r === void 0)
                    return this._cachedIndex = 0,
                    this.copySampleValue_(0);
                if (i === void 0)
                    return n = t.length,
                    this._cachedIndex = n,
                    this.copySampleValue_(n - 1)
            }
            this._cachedIndex = n,
            this.intervalChanged_(n, r, i)
        }
        return this.interpolate_(n, r, e, i)
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_
    }
    copySampleValue_(e) {
        const t = this.resultBuffer
          , n = this.samplePhilosophy
          , i = this.valueSize
          , r = e * i;
        for (let s = 0; s !== i; ++s)
            t[s] = n[r + s];
        return t
    }
    interpolate_() {
        throw new Error("call to abstract method")
    }
    intervalChanged_() {}
}
class CD extends _a {
    constructor(e, t, n, i) {
        super(e, t, n, i),
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0,
        this.DefaultSettings_ = {
            endingStart: pd,
            endingEnd: pd
        }
    }
    intervalChanged_(e, t, n) {
        const i = this.parameterPositions;
        let r = e - 2
          , s = e + 1
          , a = i[r]
          , l = i[s];
        if (a === void 0)
            switch (this.getSettings_().endingStart) {
            case md:
                r = e,
                a = 2 * t - n;
                break;
            case gd:
                r = i.length - 2,
                a = t + i[r] - i[r + 1];
                break;
            default:
                r = e,
                a = n
            }
        if (l === void 0)
            switch (this.getSettings_().endingEnd) {
            case md:
                s = e,
                l = 2 * n - t;
                break;
            case gd:
                s = 1,
                l = n + i[1] - i[0];
                break;
            default:
                s = e - 1,
                l = t
            }
        const u = (n - t) * .5
          , c = this.valueSize;
        this._weightPrev = u / (t - a),
        this._weightNext = u / (l - n),
        this._offsetPrev = r * c,
        this._offsetNext = s * c
    }
    interpolate_(e, t, n, i) {
        const r = this.resultBuffer
          , s = this.samplePhilosophy
          , a = this.valueSize
          , l = e * a
          , u = l - a
          , c = this._offsetPrev
          , h = this._offsetNext
          , f = this._weightPrev
          , m = this._weightNext
          , _ = (n - t) / (i - t)
          , d = _ * _
          , p = d * _
          , v = -f * p + 2 * f * d - f * _
          , x = (1 + f) * p + (-1.5 - 2 * f) * d + (-.5 + f) * _ + 1
          , S = (-1 - m) * p + (1.5 + m) * d + .5 * _
          , M = m * p - m * d;
        for (let T = 0; T !== a; ++T)
            r[T] = v * s[c + T] + x * s[u + T] + S * s[l + T] + M * s[h + T];
        return r
    }
}
class LD extends _a {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    interpolate_(e, t, n, i) {
        const r = this.resultBuffer
          , s = this.samplePhilosophy
          , a = this.valueSize
          , l = e * a
          , u = l - a
          , c = (n - t) / (i - t)
          , h = 1 - c;
        for (let f = 0; f !== a; ++f)
            r[f] = s[u + f] * h + s[l + f] * c;
        return r
    }
}
class RD extends _a {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    interpolate_(e) {
        return this.copySampleValue_(e - 1)
    }
}
class mi {
    constructor(e, t, n, i) {
        if (e === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (t === void 0 || t.length === 0)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e,
        this.times = ol(t, this.TimeBufferType),
        this.values = ol(n, this.ValueBufferType),
        this.setInterpolation(i || this.DefaultInterpolation)
    }
    static toJSON(e) {
        const t = e.constructor;
        let n;
        if (t.toJSON !== this.toJSON)
            n = t.toJSON(e);
        else {
            n = {
                name: e.name,
                times: ol(e.times, Array),
                values: ol(e.values, Array)
            };
            const i = e.getInterpolation();
            i !== e.DefaultInterpolation && (n.interpolation = i)
        }
        return n.type = e.ValueTypeName,
        n
    }
    InterpolantFactoryMethodDiscrete(e) {
        return new RD(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodLinear(e) {
        return new LD(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodSmooth(e) {
        return new CD(this.times,this.values,this.getValueSize(),e)
    }
    setInterpolation(e) {
        let t;
        switch (e) {
        case oa:
            t = this.InterpolantFactoryMethodDiscrete;
            break;
        case io:
            t = this.InterpolantFactoryMethodLinear;
            break;
        case wu:
            t = this.InterpolantFactoryMethodSmooth;
            break
        }
        if (t === void 0) {
            const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0)
                if (e !== this.DefaultInterpolation)
                    this.setInterpolation(this.DefaultInterpolation);
                else
                    throw new Error(n);
            return console.warn("THREE.KeyframeTrack:", n),
            this
        }
        return this.createInterpolant = t,
        this
    }
    getInterpolation() {
        switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
            return oa;
        case this.InterpolantFactoryMethodLinear:
            return io;
        case this.InterpolantFactoryMethodSmooth:
            return wu
        }
    }
    getValueSize() {
        return this.values.length / this.times.length
    }
    shift(e) {
        if (e !== 0) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n)
                t[n] += e
        }
        return this
    }
    scale(e) {
        if (e !== 1) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n)
                t[n] *= e
        }
        return this
    }
    trim(e, t) {
        const n = this.times
          , i = n.length;
        let r = 0
          , s = i - 1;
        for (; r !== i && n[r] < e; )
            ++r;
        for (; s !== -1 && n[s] > t; )
            --s;
        if (++s,
        r !== 0 || s !== i) {
            r >= s && (s = Math.max(s, 1),
            r = s - 1);
            const a = this.getValueSize();
            this.times = er(n, r, s),
            this.values = er(this.values, r * a, s * a)
        }
        return this
    }
    validate() {
        let e = !0;
        const t = this.getValueSize();
        t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
        e = !1);
        const n = this.times
          , i = this.values
          , r = n.length;
        r === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this),
        e = !1);
        let s = null;
        for (let a = 0; a !== r; a++) {
            const l = n[a];
            if (typeof l == "number" && isNaN(l)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l),
                e = !1;
                break
            }
            if (s !== null && s > l) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, s),
                e = !1;
                break
            }
            s = l
        }
        if (i !== void 0 && c_(i))
            for (let a = 0, l = i.length; a !== l; ++a) {
                const u = i[a];
                if (isNaN(u)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, u),
                    e = !1;
                    break
                }
            }
        return e
    }
    optimize() {
        const e = er(this.times)
          , t = er(this.values)
          , n = this.getValueSize()
          , i = this.getInterpolation() === wu
          , r = e.length - 1;
        let s = 1;
        for (let a = 1; a < r; ++a) {
            let l = !1;
            const u = e[a]
              , c = e[a + 1];
            if (u !== c && (a !== 1 || u !== e[0]))
                if (i)
                    l = !0;
                else {
                    const h = a * n
                      , f = h - n
                      , m = h + n;
                    for (let _ = 0; _ !== n; ++_) {
                        const d = t[h + _];
                        if (d !== t[f + _] || d !== t[m + _]) {
                            l = !0;
                            break
                        }
                    }
                }
            if (l) {
                if (a !== s) {
                    e[s] = e[a];
                    const h = a * n
                      , f = s * n;
                    for (let m = 0; m !== n; ++m)
                        t[f + m] = t[h + m]
                }
                ++s
            }
        }
        if (r > 0) {
            e[s] = e[r];
            for (let a = r * n, l = s * n, u = 0; u !== n; ++u)
                t[l + u] = t[a + u];
            ++s
        }
        return s !== e.length ? (this.times = er(e, 0, s),
        this.values = er(t, 0, s * n)) : (this.times = e,
        this.values = t),
        this
    }
    clone() {
        const e = er(this.times, 0)
          , t = er(this.values, 0)
          , n = this.constructor
          , i = new n(this.name,e,t);
        return i.createInterpolant = this.createInterpolant,
        i
    }
}
mi.prototype.TimeBufferType = Float32Array;
mi.prototype.ValueBufferType = Float32Array;
mi.prototype.DefaultInterpolation = io;
class co extends mi {
}
co.prototype.ValueTypeName = "bool";
co.prototype.ValueBufferType = Array;
co.prototype.DefaultInterpolation = oa;
co.prototype.InterpolantFactoryMethodLinear = void 0;
co.prototype.InterpolantFactoryMethodSmooth = void 0;
class f_ extends mi {
}
f_.prototype.ValueTypeName = "color";
class ua extends mi {
}
ua.prototype.ValueTypeName = "number";
class PD extends _a {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    interpolate_(e, t, n, i) {
        const r = this.resultBuffer
          , s = this.samplePhilosophy
          , a = this.valueSize
          , l = (n - t) / (i - t);
        let u = e * a;
        for (let c = u + a; u !== c; u += 4)
            os.slerpFlat(r, 0, s, u - a, s, u, l);
        return r
    }
}
class ns extends mi {
    InterpolantFactoryMethodLinear(e) {
        return new PD(this.times,this.values,this.getValueSize(),e)
    }
}
ns.prototype.ValueTypeName = "quaternion";
ns.prototype.DefaultInterpolation = io;
ns.prototype.InterpolantFactoryMethodSmooth = void 0;
class ho extends mi {
}
ho.prototype.ValueTypeName = "string";
ho.prototype.ValueBufferType = Array;
ho.prototype.DefaultInterpolation = oa;
ho.prototype.InterpolantFactoryMethodLinear = void 0;
ho.prototype.InterpolantFactoryMethodSmooth = void 0;
class ca extends mi {
}
ca.prototype.ValueTypeName = "vector";
class ID {
    constructor(e, t=-1, n, i=ib) {
        this.name = e,
        this.tracks = n,
        this.duration = t,
        this.blendMode = i,
        this.uuid = ti(),
        this.duration < 0 && this.resetDuration()
    }
    static parse(e) {
        const t = []
          , n = e.tracks
          , i = 1 / (e.fps || 1);
        for (let s = 0, a = n.length; s !== a; ++s)
            t.push(OD(n[s]).scale(i));
        const r = new this(e.name,e.duration,t,e.blendMode);
        return r.uuid = e.uuid,
        r
    }
    static toJSON(e) {
        const t = []
          , n = e.tracks
          , i = {
            name: e.name,
            duration: e.duration,
            tracks: t,
            uuid: e.uuid,
            blendMode: e.blendMode
        };
        for (let r = 0, s = n.length; r !== s; ++r)
            t.push(mi.toJSON(n[r]));
        return i
    }
    static CreateFromMorphTargetSequence(e, t, n, i) {
        const r = t.length
          , s = [];
        for (let a = 0; a < r; a++) {
            let l = []
              , u = [];
            l.push((a + r - 1) % r, a, (a + 1) % r),
            u.push(0, 1, 0);
            const c = AD(l);
            l = dp(l, 1, c),
            u = dp(u, 1, c),
            !i && l[0] === 0 && (l.push(r),
            u.push(u[0])),
            s.push(new ua(".morphTargetInfluences[" + t[a].name + "]",l,u).scale(1 / n))
        }
        return new this(e,-1,s)
    }
    static findByName(e, t) {
        let n = e;
        if (!Array.isArray(e)) {
            const i = e;
            n = i.geometry && i.geometry.animations || i.animations
        }
        for (let i = 0; i < n.length; i++)
            if (n[i].name === t)
                return n[i];
        return null
    }
    static CreateClipsFromMorphTargetSequences(e, t, n) {
        const i = {}
          , r = /^([\w-]*?)([\d]+)$/;
        for (let a = 0, l = e.length; a < l; a++) {
            const u = e[a]
              , c = u.name.match(r);
            if (c && c.length > 1) {
                const h = c[1];
                let f = i[h];
                f || (i[h] = f = []),
                f.push(u)
            }
        }
        const s = [];
        for (const a in i)
            s.push(this.CreateFromMorphTargetSequence(a, i[a], t, n));
        return s
    }
    static parseAnimation(e, t) {
        if (!e)
            return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
            null;
        const n = function(h, f, m, _, d) {
            if (m.length !== 0) {
                const p = []
                  , v = [];
                h_(m, p, v, _),
                p.length !== 0 && d.push(new h(f,p,v))
            }
        }
          , i = []
          , r = e.name || "default"
          , s = e.fps || 30
          , a = e.blendMode;
        let l = e.length || -1;
        const u = e.hierarchy || [];
        for (let h = 0; h < u.length; h++) {
            const f = u[h].keys;
            if (!(!f || f.length === 0))
                if (f[0].morphTargets) {
                    const m = {};
                    let _;
                    for (_ = 0; _ < f.length; _++)
                        if (f[_].morphTargets)
                            for (let d = 0; d < f[_].morphTargets.length; d++)
                                m[f[_].morphTargets[d]] = -1;
                    for (const d in m) {
                        const p = []
                          , v = [];
                        for (let x = 0; x !== f[_].morphTargets.length; ++x) {
                            const S = f[_];
                            p.push(S.time),
                            v.push(S.morphTarget === d ? 1 : 0)
                        }
                        i.push(new ua(".morphTargetInfluence[" + d + "]",p,v))
                    }
                    l = m.length * s
                } else {
                    const m = ".bones[" + t[h].name + "]";
                    n(ca, m + ".position", f, "pos", i),
                    n(ns, m + ".quaternion", f, "rot", i),
                    n(ca, m + ".scale", f, "scl", i)
                }
        }
        return i.length === 0 ? null : new this(r,l,i,a)
    }
    resetDuration() {
        const e = this.tracks;
        let t = 0;
        for (let n = 0, i = e.length; n !== i; ++n) {
            const r = this.tracks[n];
            t = Math.max(t, r.times[r.times.length - 1])
        }
        return this.duration = t,
        this
    }
    trim() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
        return this
    }
    validate() {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++)
            e = e && this.tracks[t].validate();
        return e
    }
    optimize() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].optimize();
        return this
    }
    clone() {
        const e = [];
        for (let t = 0; t < this.tracks.length; t++)
            e.push(this.tracks[t].clone());
        return new this.constructor(this.name,this.duration,e,this.blendMode)
    }
    toJSON() {
        return this.constructor.toJSON(this)
    }
}
function FD(o) {
    switch (o.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
        return ua;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
        return ca;
    case "color":
        return f_;
    case "quaternion":
        return ns;
    case "bool":
    case "boolean":
        return co;
    case "string":
        return ho
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + o)
}
function OD(o) {
    if (o.type === void 0)
        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e = FD(o.type);
    if (o.times === void 0) {
        const t = []
          , n = [];
        h_(o.keys, t, n, "value"),
        o.times = t,
        o.values = n
    }
    return e.parse !== void 0 ? e.parse(o) : new e(o.name,o.times,o.values,o.interpolation)
}
const so = {
    enabled: !1,
    files: {},
    add: function(o, e) {
        this.enabled !== !1 && (this.files[o] = e)
    },
    get: function(o) {
        if (this.enabled !== !1)
            return this.files[o]
    },
    remove: function(o) {
        delete this.files[o]
    },
    clear: function() {
        this.files = {}
    }
};
class ND {
    constructor(e, t, n) {
        const i = this;
        let r = !1, s = 0, a = 0, l;
        const u = [];
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = n,
        this.itemStart = function(c) {
            a++,
            r === !1 && i.onStart !== void 0 && i.onStart(c, s, a),
            r = !0
        }
        ,
        this.itemEnd = function(c) {
            s++,
            i.onProgress !== void 0 && i.onProgress(c, s, a),
            s === a && (r = !1,
            i.onLoad !== void 0 && i.onLoad())
        }
        ,
        this.itemError = function(c) {
            i.onError !== void 0 && i.onError(c)
        }
        ,
        this.resolveURL = function(c) {
            return l ? l(c) : c
        }
        ,
        this.setURLModifier = function(c) {
            return l = c,
            this
        }
        ,
        this.addHandler = function(c, h) {
            return u.push(c, h),
            this
        }
        ,
        this.removeHandler = function(c) {
            const h = u.indexOf(c);
            return h !== -1 && u.splice(h, 2),
            this
        }
        ,
        this.getHandler = function(c) {
            for (let h = 0, f = u.length; h < f; h += 2) {
                const m = u[h]
                  , _ = u[h + 1];
                if (m.global && (m.lastIndex = 0),
                m.test(c))
                    return _
            }
            return null
        }
    }
}
const kD = new ND;
class fo {
    constructor(e) {
        this.manager = e !== void 0 ? e : kD,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    load() {}
    loadAsync(e, t) {
        const n = this;
        return new Promise(function(i, r) {
            n.load(e, i, t, r)
        }
        )
    }
    parse() {}
    setCrossOrigin(e) {
        return this.crossOrigin = e,
        this
    }
    setWithCredentials(e) {
        return this.withCredentials = e,
        this
    }
    setPath(e) {
        return this.path = e,
        this
    }
    setResourcePath(e) {
        return this.resourcePath = e,
        this
    }
    setRequestHeader(e) {
        return this.requestHeader = e,
        this
    }
}
const wi = {};
class zD extends Error {
    constructor(e, t) {
        super(e),
        this.response = t
    }
}
class wh extends fo {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const r = so.get(e);
        if (r !== void 0)
            return this.manager.itemStart(e),
            setTimeout( () => {
                t && t(r),
                this.manager.itemEnd(e)
            }
            , 0),
            r;
        if (wi[e] !== void 0) {
            wi[e].push({
                onLoad: t,
                onProgress: n,
                onError: i
            });
            return
        }
        wi[e] = [],
        wi[e].push({
            onLoad: t,
            onProgress: n,
            onError: i
        });
        const s = new Request(e,{
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
        })
          , a = this.mimeType
          , l = this.responseType;
        fetch(s).then(u => {
            if (u.status === 200 || u.status === 0) {
                if (u.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                typeof ReadableStream > "u" || u.body === void 0 || u.body.getReader === void 0)
                    return u;
                const c = wi[e]
                  , h = u.body.getReader()
                  , f = u.headers.get("Content-Length")
                  , m = f ? parseInt(f) : 0
                  , _ = m !== 0;
                let d = 0;
                const p = new ReadableStream({
                    start(v) {
                        x();
                        function x() {
                            h.read().then( ({done: S, value: M}) => {
                                if (S)
                                    v.close();
                                else {
                                    d += M.byteLength;
                                    const T = new ProgressEvent("progress",{
                                        lengthComputable: _,
                                        loaded: d,
                                        total: m
                                    });
                                    for (let L = 0, P = c.length; L < P; L++) {
                                        const A = c[L];
                                        A.onProgress && A.onProgress(T)
                                    }
                                    v.enqueue(M),
                                    x()
                                }
                            }
                            )
                        }
                    }
                });
                return new Response(p)
            } else
                throw new zD(`fetch for "${u.url}" responded with ${u.status}: ${u.statusText}`,u)
        }
        ).then(u => {
            switch (l) {
            case "arraybuffer":
                return u.arrayBuffer();
            case "blob":
                return u.blob();
            case "document":
                return u.text().then(c => new DOMParser().parseFromString(c, a));
            case "json":
                return u.json();
            default:
                if (a === void 0)
                    return u.text();
                {
                    const h = /charset="?([^;"\s]*)"?/i.exec(a)
                      , f = h && h[1] ? h[1].toLowerCase() : void 0
                      , m = new TextDecoder(f);
                    return u.arrayBuffer().then(_ => m.decode(_))
                }
            }
        }
        ).then(u => {
            so.add(e, u);
            const c = wi[e];
            delete wi[e];
            for (let h = 0, f = c.length; h < f; h++) {
                const m = c[h];
                m.onLoad && m.onLoad(u)
            }
        }
        ).catch(u => {
            const c = wi[e];
            if (c === void 0)
                throw this.manager.itemError(e),
                u;
            delete wi[e];
            for (let h = 0, f = c.length; h < f; h++) {
                const m = c[h];
                m.onError && m.onError(u)
            }
            this.manager.itemError(e)
        }
        ).finally( () => {
            this.manager.itemEnd(e)
        }
        ),
        this.manager.itemStart(e)
    }
    setResponseType(e) {
        return this.responseType = e,
        this
    }
    setMimeType(e) {
        return this.mimeType = e,
        this
    }
}
class UD extends fo {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const r = this
          , s = so.get(e);
        if (s !== void 0)
            return r.manager.itemStart(e),
            setTimeout(function() {
                t && t(s),
                r.manager.itemEnd(e)
            }, 0),
            s;
        const a = la("img");
        function l() {
            c(),
            so.add(e, this),
            t && t(this),
            r.manager.itemEnd(e)
        }
        function u(h) {
            c(),
            i && i(h),
            r.manager.itemError(e),
            r.manager.itemEnd(e)
        }
        function c() {
            a.removeEventListener("load", l, !1),
            a.removeEventListener("error", u, !1)
        }
        return a.addEventListener("load", l, !1),
        a.addEventListener("error", u, !1),
        e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin),
        r.manager.itemStart(e),
        a.src = e,
        a
    }
}
class BD extends fo {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const r = this
          , s = new a_
          , a = new wh(this.manager);
        return a.setResponseType("arraybuffer"),
        a.setRequestHeader(this.requestHeader),
        a.setPath(this.path),
        a.setWithCredentials(r.withCredentials),
        a.load(e, function(l) {
            const u = r.parse(l);
            !u || (u.image !== void 0 ? s.image = u.image : u.data !== void 0 && (s.image.width = u.width,
            s.image.height = u.height,
            s.image.data = u.data),
            s.wrapS = u.wrapS !== void 0 ? u.wrapS : fn,
            s.wrapT = u.wrapT !== void 0 ? u.wrapT : fn,
            s.magFilter = u.magFilter !== void 0 ? u.magFilter : It,
            s.minFilter = u.minFilter !== void 0 ? u.minFilter : It,
            s.anisotropy = u.anisotropy !== void 0 ? u.anisotropy : 1,
            u.encoding !== void 0 && (s.encoding = u.encoding),
            u.flipY !== void 0 && (s.flipY = u.flipY),
            u.format !== void 0 && (s.format = u.format),
            u.type !== void 0 && (s.type = u.type),
            u.mipmaps !== void 0 && (s.mipmaps = u.mipmaps,
            s.minFilter = ss),
            u.mipmapCount === 1 && (s.minFilter = It),
            u.generateMipmaps !== void 0 && (s.generateMipmaps = u.generateMipmaps),
            s.needsUpdate = !0,
            t && t(s, u))
        }, n, i),
        s
    }
}
class VD extends fo {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const r = new tn
          , s = new UD(this.manager);
        return s.setCrossOrigin(this.crossOrigin),
        s.setPath(this.path),
        s.load(e, function(a) {
            r.image = a,
            r.needsUpdate = !0,
            t !== void 0 && t(r)
        }, n, i),
        r
    }
}
class Yl extends yt {
    constructor(e, t=1) {
        super(),
        this.isLight = !0,
        this.type = "Light",
        this.color = new ze(e),
        this.intensity = t
    }
    dispose() {}
    copy(e, t) {
        return super.copy(e, t),
        this.color.copy(e.color),
        this.intensity = e.intensity,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.color = this.color.getHex(),
        t.object.intensity = this.intensity,
        this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()),
        this.distance !== void 0 && (t.object.distance = this.distance),
        this.angle !== void 0 && (t.object.angle = this.angle),
        this.decay !== void 0 && (t.object.decay = this.decay),
        this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
        this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
        t
    }
}
const pp = new Ke
  , mp = new X
  , gp = new X;
class Mh {
    constructor(e) {
        this.camera = e,
        this.bias = 0,
        this.normalBias = 0,
        this.radius = 1,
        this.blurSamples = 8,
        this.mapSize = new Ze(512,512),
        this.map = null,
        this.mapPass = null,
        this.matrix = new Ke,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this._frustum = new mh,
        this._frameExtents = new Ze(1,1),
        this._viewportCount = 1,
        this._viewports = [new ct(0,0,1,1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(e) {
        const t = this.camera
          , n = this.matrix;
        mp.setFromMatrixPosition(e.matrixWorld),
        t.position.copy(mp),
        gp.setFromMatrixPosition(e.target.matrixWorld),
        t.lookAt(gp),
        t.updateMatrixWorld(),
        pp.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(pp),
        n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
        n.multiply(t.projectionMatrix),
        n.multiply(t.matrixWorldInverse)
    }
    getViewport(e) {
        return this._viewports[e]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(),
        this.mapPass && this.mapPass.dispose()
    }
    copy(e) {
        return this.camera = e.camera.clone(),
        this.bias = e.bias,
        this.radius = e.radius,
        this.mapSize.copy(e.mapSize),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        const e = {};
        return this.bias !== 0 && (e.bias = this.bias),
        this.normalBias !== 0 && (e.normalBias = this.normalBias),
        this.radius !== 1 && (e.radius = this.radius),
        (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
        e.camera = this.camera.toJSON(!1).object,
        delete e.camera.matrix,
        e
    }
}
class GD extends Mh {
    constructor() {
        super(new un(50,1,.5,500)),
        this.isSpotLightShadow = !0,
        this.focus = 1
    }
    updateMatrices(e) {
        const t = this.camera
          , n = aa * 2 * e.angle * this.focus
          , i = this.mapSize.width / this.mapSize.height
          , r = e.distance || t.far;
        (n !== t.fov || i !== t.aspect || r !== t.far) && (t.fov = n,
        t.aspect = i,
        t.far = r,
        t.updateProjectionMatrix()),
        super.updateMatrices(e)
    }
    copy(e) {
        return super.copy(e),
        this.focus = e.focus,
        this
    }
}
class HD extends Yl {
    constructor(e, t, n=0, i=Math.PI / 3, r=0, s=1) {
        super(e, t),
        this.isSpotLight = !0,
        this.type = "SpotLight",
        this.position.copy(yt.DefaultUp),
        this.updateMatrix(),
        this.target = new yt,
        this.distance = n,
        this.angle = i,
        this.penumbra = r,
        this.decay = s,
        this.map = null,
        this.shadow = new GD
    }
    get power() {
        return this.intensity * Math.PI
    }
    set power(e) {
        this.intensity = e / Math.PI
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.angle = e.angle,
        this.penumbra = e.penumbra,
        this.decay = e.decay,
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
const _p = new Ke
  , Mo = new X
  , $u = new X;
class WD extends Mh {
    constructor() {
        super(new un(90,1,.5,500)),
        this.isPointLightShadow = !0,
        this._frameExtents = new Ze(4,2),
        this._viewportCount = 6,
        this._viewports = [new ct(2,1,1,1), new ct(0,1,1,1), new ct(3,1,1,1), new ct(1,1,1,1), new ct(3,0,1,1), new ct(1,0,1,1)],
        this._cubeDirections = [new X(1,0,0), new X(-1,0,0), new X(0,0,1), new X(0,0,-1), new X(0,1,0), new X(0,-1,0)],
        this._cubeUps = [new X(0,1,0), new X(0,1,0), new X(0,1,0), new X(0,1,0), new X(0,0,1), new X(0,0,-1)]
    }
    updateMatrices(e, t=0) {
        const n = this.camera
          , i = this.matrix
          , r = e.distance || n.far;
        r !== n.far && (n.far = r,
        n.updateProjectionMatrix()),
        Mo.setFromMatrixPosition(e.matrixWorld),
        n.position.copy(Mo),
        $u.copy(n.position),
        $u.add(this._cubeDirections[t]),
        n.up.copy(this._cubeUps[t]),
        n.lookAt($u),
        n.updateMatrixWorld(),
        i.makeTranslation(-Mo.x, -Mo.y, -Mo.z),
        _p.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(_p)
    }
}
class jD extends Yl {
    constructor(e, t, n=0, i=1) {
        super(e, t),
        this.isPointLight = !0,
        this.type = "PointLight",
        this.distance = n,
        this.decay = i,
        this.shadow = new WD
    }
    get power() {
        return this.intensity * 4 * Math.PI
    }
    set power(e) {
        this.intensity = e / (4 * Math.PI)
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.decay = e.decay,
        this.shadow = e.shadow.clone(),
        this
    }
}
class qD extends Mh {
    constructor() {
        super(new _h(-5,5,5,-5,.5,500)),
        this.isDirectionalLightShadow = !0
    }
}
class XD extends Yl {
    constructor(e, t) {
        super(e, t),
        this.isDirectionalLight = !0,
        this.type = "DirectionalLight",
        this.position.copy(yt.DefaultUp),
        this.updateMatrix(),
        this.target = new yt,
        this.shadow = new qD
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e) {
        return super.copy(e),
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
class QT extends Yl {
    constructor(e, t) {
        super(e, t),
        this.isAmbientLight = !0,
        this.type = "AmbientLight"
    }
}
class Yr {
    static decodeText(e) {
        if (typeof TextDecoder < "u")
            return new TextDecoder().decode(e);
        let t = "";
        for (let n = 0, i = e.length; n < i; n++)
            t += String.fromCharCode(e[n]);
        try {
            return decodeURIComponent(escape(t))
        } catch {
            return t
        }
    }
    static extractUrlBase(e) {
        const t = e.lastIndexOf("/");
        return t === -1 ? "./" : e.slice(0, t + 1)
    }
    static resolveURL(e, t) {
        return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
    }
}
class YD extends fo {
    constructor(e) {
        super(e),
        this.isImageBitmapLoader = !0,
        typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        this.options = {
            premultiplyAlpha: "none"
        }
    }
    setOptions(e) {
        return this.options = e,
        this
    }
    load(e, t, n, i) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const r = this
          , s = so.get(e);
        if (s !== void 0)
            return r.manager.itemStart(e),
            setTimeout(function() {
                t && t(s),
                r.manager.itemEnd(e)
            }, 0),
            s;
        const a = {};
        a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include",
        a.headers = this.requestHeader,
        fetch(e, a).then(function(l) {
            return l.blob()
        }).then(function(l) {
            return createImageBitmap(l, Object.assign(r.options, {
                colorSpaceConversion: "none"
            }))
        }).then(function(l) {
            so.add(e, l),
            t && t(l),
            r.manager.itemEnd(e)
        }).catch(function(l) {
            i && i(l),
            r.manager.itemError(e),
            r.manager.itemEnd(e)
        }),
        r.manager.itemStart(e)
    }
}
const Sh = "\\[\\]\\.:\\/"
  , KD = new RegExp("[" + Sh + "]","g")
  , Dh = "[^" + Sh + "]"
  , $D = "[^" + Sh.replace("\\.", "") + "]"
  , ZD = /((?:WC+[\/:])*)/.source.replace("WC", Dh)
  , QD = /(WCOD+)?/.source.replace("WCOD", $D)
  , JD = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Dh)
  , eT = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Dh)
  , tT = new RegExp("^" + ZD + QD + JD + eT + "$")
  , nT = ["material", "materials", "bones", "map"];
class iT {
    constructor(e, t, n) {
        const i = n || rt.parseTrackName(t);
        this._targetGroup = e,
        this._bindings = e.subscribe_(t, i)
    }
    getValue(e, t) {
        this.bind();
        const n = this._targetGroup.nCachedObjects_
          , i = this._bindings[n];
        i !== void 0 && i.getValue(e, t)
    }
    setValue(e, t) {
        const n = this._bindings;
        for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
            n[i].setValue(e, t)
    }
    bind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
            e[t].bind()
    }
    unbind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
            e[t].unbind()
    }
}
class rt {
    constructor(e, t, n) {
        this.path = t,
        this.parsedPath = n || rt.parseTrackName(t),
        this.node = rt.findNode(e, this.parsedPath.nodeName) || e,
        this.rootNode = e,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
    static create(e, t, n) {
        return e && e.isAnimationObjectGroup ? new rt.Composite(e,t,n) : new rt(e,t,n)
    }
    static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(KD, "")
    }
    static parseTrackName(e) {
        const t = tT.exec(e);
        if (t === null)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        const n = {
            nodeName: t[2],
            objectName: t[3],
            objectIndex: t[4],
            propertyName: t[5],
            propertyIndex: t[6]
        }
          , i = n.nodeName && n.nodeName.lastIndexOf(".");
        if (i !== void 0 && i !== -1) {
            const r = n.nodeName.substring(i + 1);
            nT.indexOf(r) !== -1 && (n.nodeName = n.nodeName.substring(0, i),
            n.objectName = r)
        }
        if (n.propertyName === null || n.propertyName.length === 0)
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
        return n
    }
    static findNode(e, t) {
        if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
            return e;
        if (e.skeleton) {
            const n = e.skeleton.getBoneByName(t);
            if (n !== void 0)
                return n
        }
        if (e.children) {
            const n = function(r) {
                for (let s = 0; s < r.length; s++) {
                    const a = r[s];
                    if (a.name === t || a.uuid === t)
                        return a;
                    const l = n(a.children);
                    if (l)
                        return l
                }
                return null
            }
              , i = n(e.children);
            if (i)
                return i
        }
        return null
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName]
    }
    _getValue_array(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i)
            e[t++] = n[i]
    }
    _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t)
    }
    _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t]
    }
    _setValue_direct_setNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i)
            n[i] = e[t++]
    }
    _setValue_array_setNeedsUpdate(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i)
            n[i] = e[t++];
        this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i)
            n[i] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t]
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t)
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound(e, t) {
        this.bind(),
        this.getValue(e, t)
    }
    _setValue_unbound(e, t) {
        this.bind(),
        this.setValue(e, t)
    }
    bind() {
        let e = this.node;
        const t = this.parsedPath
          , n = t.objectName
          , i = t.propertyName;
        let r = t.propertyIndex;
        if (e || (e = rt.findNode(this.rootNode, t.nodeName) || this.rootNode,
        this.node = e),
        this.getValue = this._getValue_unavailable,
        this.setValue = this._setValue_unavailable,
        !e) {
            console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            return
        }
        if (n) {
            let u = t.objectIndex;
            switch (n) {
            case "materials":
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.materials) {
                    console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                    return
                }
                e = e.material.materials;
                break;
            case "bones":
                if (!e.skeleton) {
                    console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                    return
                }
                e = e.skeleton.bones;
                for (let c = 0; c < e.length; c++)
                    if (e[c].name === u) {
                        u = c;
                        break
                    }
                break;
            case "map":
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.map) {
                    console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                    return
                }
                e = e.material.map;
                break;
            default:
                if (e[n] === void 0) {
                    console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                    return
                }
                e = e[n]
            }
            if (u !== void 0) {
                if (e[u] === void 0) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                    return
                }
                e = e[u]
            }
        }
        const s = e[i];
        if (s === void 0) {
            const u = t.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + u + "." + i + " but it wasn't found.", e);
            return
        }
        let a = this.Versioning.None;
        this.targetObject = e,
        e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
        let l = this.BindingType.Direct;
        if (r !== void 0) {
            if (i === "morphTargetInfluences") {
                if (!e.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return
                }
                if (!e.geometry.morphAttributes) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    return
                }
                e.morphTargetDictionary[r] !== void 0 && (r = e.morphTargetDictionary[r])
            }
            l = this.BindingType.ArrayElement,
            this.resolvedProperty = s,
            this.propertyIndex = r
        } else
            s.fromArray !== void 0 && s.toArray !== void 0 ? (l = this.BindingType.HasFromToArray,
            this.resolvedProperty = s) : Array.isArray(s) ? (l = this.BindingType.EntireArray,
            this.resolvedProperty = s) : this.propertyName = i;
        this.getValue = this.GetterByBindingType[l],
        this.setValue = this.SetterByBindingTypeAndVersioning[l][a]
    }
    unbind() {
        this.node = null,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
}
rt.Composite = iT;
rt.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
};
rt.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
};
rt.prototype.GetterByBindingType = [rt.prototype._getValue_direct, rt.prototype._getValue_array, rt.prototype._getValue_arrayElement, rt.prototype._getValue_toArray];
rt.prototype.SetterByBindingTypeAndVersioning = [[rt.prototype._setValue_direct, rt.prototype._setValue_direct_setNeedsUpdate, rt.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [rt.prototype._setValue_array, rt.prototype._setValue_array_setNeedsUpdate, rt.prototype._setValue_array_setMatrixWorldNeedsUpdate], [rt.prototype._setValue_arrayElement, rt.prototype._setValue_arrayElement_setNeedsUpdate, rt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [rt.prototype._setValue_fromArray, rt.prototype._setValue_fromArray_setNeedsUpdate, rt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
const Li = rT();
function rT() {
    const o = new ArrayBuffer(4)
      , e = new Float32Array(o)
      , t = new Uint32Array(o)
      , n = new Uint32Array(512)
      , i = new Uint32Array(512);
    for (let l = 0; l < 256; ++l) {
        const u = l - 127;
        u < -27 ? (n[l] = 0,
        n[l | 256] = 32768,
        i[l] = 24,
        i[l | 256] = 24) : u < -14 ? (n[l] = 1024 >> -u - 14,
        n[l | 256] = 1024 >> -u - 14 | 32768,
        i[l] = -u - 1,
        i[l | 256] = -u - 1) : u <= 15 ? (n[l] = u + 15 << 10,
        n[l | 256] = u + 15 << 10 | 32768,
        i[l] = 13,
        i[l | 256] = 13) : u < 128 ? (n[l] = 31744,
        n[l | 256] = 64512,
        i[l] = 24,
        i[l | 256] = 24) : (n[l] = 31744,
        n[l | 256] = 64512,
        i[l] = 13,
        i[l | 256] = 13)
    }
    const r = new Uint32Array(2048)
      , s = new Uint32Array(64)
      , a = new Uint32Array(64);
    for (let l = 1; l < 1024; ++l) {
        let u = l << 13
          , c = 0;
        for (; (u & 8388608) === 0; )
            u <<= 1,
            c -= 8388608;
        u &= -8388609,
        c += 947912704,
        r[l] = u | c
    }
    for (let l = 1024; l < 2048; ++l)
        r[l] = 939524096 + (l - 1024 << 13);
    for (let l = 1; l < 31; ++l)
        s[l] = l << 23;
    s[31] = 1199570944,
    s[32] = 2147483648;
    for (let l = 33; l < 63; ++l)
        s[l] = 2147483648 + (l - 32 << 23);
    s[63] = 3347054592;
    for (let l = 1; l < 64; ++l)
        l !== 32 && (a[l] = 1024);
    return {
        floatView: e,
        uint32View: t,
        baseTable: n,
        shiftTable: i,
        mantissaTable: r,
        exponentTable: s,
        offsetTable: a
    }
}
function sT(o) {
    Math.abs(o) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    o = Wt(o, -65504, 65504),
    Li.floatView[0] = o;
    const e = Li.uint32View[0]
      , t = e >> 23 & 511;
    return Li.baseTable[t] + ((e & 8388607) >> Li.shiftTable[t])
}
function oT(o) {
    const e = o >> 10;
    return Li.uint32View[0] = Li.mantissaTable[Li.offsetTable[e] + (o & 1023)] + Li.exponentTable[e],
    Li.floatView[0]
}
var al = Object.freeze({
    __proto__: null,
    toHalfFloat: sT,
    fromHalfFloat: oT
});
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
    detail: {
        revision: hh
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = hh);
class JT extends fo {
    constructor(e) {
        super(e),
        this.dracoLoader = null,
        this.ktx2Loader = null,
        this.meshoptDecoder = null,
        this.pluginCallbacks = [],
        this.register(function(t) {
            return new hT(t)
        }),
        this.register(function(t) {
            return new vT(t)
        }),
        this.register(function(t) {
            return new xT(t)
        }),
        this.register(function(t) {
            return new dT(t)
        }),
        this.register(function(t) {
            return new pT(t)
        }),
        this.register(function(t) {
            return new mT(t)
        }),
        this.register(function(t) {
            return new gT(t)
        }),
        this.register(function(t) {
            return new cT(t)
        }),
        this.register(function(t) {
            return new _T(t)
        }),
        this.register(function(t) {
            return new fT(t)
        }),
        this.register(function(t) {
            return new lT(t)
        }),
        this.register(function(t) {
            return new yT(t)
        })
    }
    load(e, t, n, i) {
        const r = this;
        let s;
        this.resourcePath !== "" ? s = this.resourcePath : this.path !== "" ? s = this.path : s = Yr.extractUrlBase(e),
        this.manager.itemStart(e);
        const a = function(u) {
            i ? i(u) : console.error(u),
            r.manager.itemError(e),
            r.manager.itemEnd(e)
        }
          , l = new wh(this.manager);
        l.setPath(this.path),
        l.setResponseType("arraybuffer"),
        l.setRequestHeader(this.requestHeader),
        l.setWithCredentials(this.withCredentials),
        l.load(e, function(u) {
            try {
                r.parse(u, s, function(c) {
                    t(c),
                    r.manager.itemEnd(e)
                }, a)
            } catch (c) {
                a(c)
            }
        }, n, a)
    }
    setDRACOLoader(e) {
        return this.dracoLoader = e,
        this
    }
    setDDSLoader() {
        throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
    }
    setKTX2Loader(e) {
        return this.ktx2Loader = e,
        this
    }
    setMeshoptDecoder(e) {
        return this.meshoptDecoder = e,
        this
    }
    register(e) {
        return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
        this
    }
    unregister(e) {
        return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
        this
    }
    parse(e, t, n, i) {
        let r;
        const s = {}
          , a = {};
        if (typeof e == "string")
            r = e;
        else if (Yr.decodeText(new Uint8Array(e,0,4)) === d_) {
            try {
                s[je.KHR_BINARY_GLTF] = new bT(e)
            } catch (h) {
                i && i(h);
                return
            }
            r = s[je.KHR_BINARY_GLTF].content
        } else
            r = Yr.decodeText(new Uint8Array(e));
        const l = JSON.parse(r);
        if (l.asset === void 0 || l.asset.version[0] < 2) {
            i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
            return
        }
        const u = new FT(l,{
            path: t || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
        });
        u.fileLoader.setRequestHeader(this.requestHeader);
        for (let c = 0; c < this.pluginCallbacks.length; c++) {
            const h = this.pluginCallbacks[c](u);
            a[h.name] = h,
            s[h.name] = !0
        }
        if (l.extensionsUsed)
            for (let c = 0; c < l.extensionsUsed.length; ++c) {
                const h = l.extensionsUsed[c]
                  , f = l.extensionsRequired || [];
                switch (h) {
                case je.KHR_MATERIALS_UNLIT:
                    s[h] = new uT;
                    break;
                case je.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                    s[h] = new ST;
                    break;
                case je.KHR_DRACO_MESH_COMPRESSION:
                    s[h] = new wT(l,this.dracoLoader);
                    break;
                case je.KHR_TEXTURE_TRANSFORM:
                    s[h] = new MT;
                    break;
                case je.KHR_MESH_QUANTIZATION:
                    s[h] = new DT;
                    break;
                default:
                    f.indexOf(h) >= 0 && a[h] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".')
                }
            }
        u.setExtensions(s),
        u.setPlugins(a),
        u.parse(n, i)
    }
    parseAsync(e, t) {
        const n = this;
        return new Promise(function(i, r) {
            n.parse(e, t, i, r)
        }
        )
    }
}
function aT() {
    let o = {};
    return {
        get: function(e) {
            return o[e]
        },
        add: function(e, t) {
            o[e] = t
        },
        remove: function(e) {
            delete o[e]
        },
        removeAll: function() {
            o = {}
        }
    }
}
const je = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
};
class lT {
    constructor(e) {
        this.parser = e,
        this.name = je.KHR_LIGHTS_PUNCTUAL,
        this.cache = {
            refs: {},
            uses: {}
        }
    }
    _markDefs() {
        const e = this.parser
          , t = this.parser.json.nodes || [];
        for (let n = 0, i = t.length; n < i; n++) {
            const r = t[n];
            r.extensions && r.extensions[this.name] && r.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, r.extensions[this.name].light)
        }
    }
    _loadLight(e) {
        const t = this.parser
          , n = "light:" + e;
        let i = t.cache.get(n);
        if (i)
            return i;
        const r = t.json
          , l = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
        let u;
        const c = new ze(16777215);
        l.color !== void 0 && c.fromArray(l.color);
        const h = l.range !== void 0 ? l.range : 0;
        switch (l.type) {
        case "directional":
            u = new XD(c),
            u.target.position.set(0, 0, -1),
            u.add(u.target);
            break;
        case "point":
            u = new jD(c),
            u.distance = h;
            break;
        case "spot":
            u = new HD(c),
            u.distance = h,
            l.spot = l.spot || {},
            l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0,
            l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4,
            u.angle = l.spot.outerConeAngle,
            u.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle,
            u.target.position.set(0, 0, -1),
            u.add(u.target);
            break;
        default:
            throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type)
        }
        return u.position.set(0, 0, 0),
        u.decay = 2,
        l.intensity !== void 0 && (u.intensity = l.intensity),
        u.name = t.createUniqueName(l.name || "light_" + e),
        i = Promise.resolve(u),
        t.cache.add(n, i),
        i
    }
    createNodeAttachment(e) {
        const t = this
          , n = this.parser
          , r = n.json.nodes[e]
          , a = (r.extensions && r.extensions[this.name] || {}).light;
        return a === void 0 ? null : this._loadLight(a).then(function(l) {
            return n._getNodeRef(t.cache, a, l)
        })
    }
}
class uT {
    constructor() {
        this.name = je.KHR_MATERIALS_UNLIT
    }
    getMaterialType() {
        return Ur
    }
    extendParams(e, t, n) {
        const i = [];
        e.color = new ze(1,1,1),
        e.opacity = 1;
        const r = t.pbrMetallicRoughness;
        if (r) {
            if (Array.isArray(r.baseColorFactor)) {
                const s = r.baseColorFactor;
                e.color.fromArray(s),
                e.opacity = s[3]
            }
            r.baseColorTexture !== void 0 && i.push(n.assignTexture(e, "map", r.baseColorTexture, it))
        }
        return Promise.all(i)
    }
}
class cT {
    constructor(e) {
        this.parser = e,
        this.name = je.KHR_MATERIALS_EMISSIVE_STRENGTH
    }
    extendMaterialParams(e, t) {
        const i = this.parser.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const r = i.extensions[this.name].emissiveStrength;
        return r !== void 0 && (t.emissiveIntensity = r),
        Promise.resolve()
    }
}
class hT {
    constructor(e) {
        this.parser = e,
        this.name = je.KHR_MATERIALS_CLEARCOAT
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : as
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const r = []
          , s = i.extensions[this.name];
        if (s.clearcoatFactor !== void 0 && (t.clearcoat = s.clearcoatFactor),
        s.clearcoatTexture !== void 0 && r.push(n.assignTexture(t, "clearcoatMap", s.clearcoatTexture)),
        s.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = s.clearcoatRoughnessFactor),
        s.clearcoatRoughnessTexture !== void 0 && r.push(n.assignTexture(t, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)),
        s.clearcoatNormalTexture !== void 0 && (r.push(n.assignTexture(t, "clearcoatNormalMap", s.clearcoatNormalTexture)),
        s.clearcoatNormalTexture.scale !== void 0)) {
            const a = s.clearcoatNormalTexture.scale;
            t.clearcoatNormalScale = new Ze(a,a)
        }
        return Promise.all(r)
    }
}
class fT {
    constructor(e) {
        this.parser = e,
        this.name = je.KHR_MATERIALS_IRIDESCENCE
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : as
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const r = []
          , s = i.extensions[this.name];
        return s.iridescenceFactor !== void 0 && (t.iridescence = s.iridescenceFactor),
        s.iridescenceTexture !== void 0 && r.push(n.assignTexture(t, "iridescenceMap", s.iridescenceTexture)),
        s.iridescenceIor !== void 0 && (t.iridescenceIOR = s.iridescenceIor),
        t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]),
        s.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = s.iridescenceThicknessMinimum),
        s.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = s.iridescenceThicknessMaximum),
        s.iridescenceThicknessTexture !== void 0 && r.push(n.assignTexture(t, "iridescenceThicknessMap", s.iridescenceThicknessTexture)),
        Promise.all(r)
    }
}
class dT {
    constructor(e) {
        this.parser = e,
        this.name = je.KHR_MATERIALS_SHEEN
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : as
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const r = [];
        t.sheenColor = new ze(0,0,0),
        t.sheenRoughness = 0,
        t.sheen = 1;
        const s = i.extensions[this.name];
        return s.sheenColorFactor !== void 0 && t.sheenColor.fromArray(s.sheenColorFactor),
        s.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = s.sheenRoughnessFactor),
        s.sheenColorTexture !== void 0 && r.push(n.assignTexture(t, "sheenColorMap", s.sheenColorTexture, it)),
        s.sheenRoughnessTexture !== void 0 && r.push(n.assignTexture(t, "sheenRoughnessMap", s.sheenRoughnessTexture)),
        Promise.all(r)
    }
}
class pT {
    constructor(e) {
        this.parser = e,
        this.name = je.KHR_MATERIALS_TRANSMISSION
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : as
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const r = []
          , s = i.extensions[this.name];
        return s.transmissionFactor !== void 0 && (t.transmission = s.transmissionFactor),
        s.transmissionTexture !== void 0 && r.push(n.assignTexture(t, "transmissionMap", s.transmissionTexture)),
        Promise.all(r)
    }
}
class mT {
    constructor(e) {
        this.parser = e,
        this.name = je.KHR_MATERIALS_VOLUME
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : as
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const r = []
          , s = i.extensions[this.name];
        t.thickness = s.thicknessFactor !== void 0 ? s.thicknessFactor : 0,
        s.thicknessTexture !== void 0 && r.push(n.assignTexture(t, "thicknessMap", s.thicknessTexture)),
        t.attenuationDistance = s.attenuationDistance || 0;
        const a = s.attenuationColor || [1, 1, 1];
        return t.attenuationColor = new ze(a[0],a[1],a[2]),
        Promise.all(r)
    }
}
class gT {
    constructor(e) {
        this.parser = e,
        this.name = je.KHR_MATERIALS_IOR
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : as
    }
    extendMaterialParams(e, t) {
        const i = this.parser.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const r = i.extensions[this.name];
        return t.ior = r.ior !== void 0 ? r.ior : 1.5,
        Promise.resolve()
    }
}
class _T {
    constructor(e) {
        this.parser = e,
        this.name = je.KHR_MATERIALS_SPECULAR
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : as
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const r = []
          , s = i.extensions[this.name];
        t.specularIntensity = s.specularFactor !== void 0 ? s.specularFactor : 1,
        s.specularTexture !== void 0 && r.push(n.assignTexture(t, "specularIntensityMap", s.specularTexture));
        const a = s.specularColorFactor || [1, 1, 1];
        return t.specularColor = new ze(a[0],a[1],a[2]),
        s.specularColorTexture !== void 0 && r.push(n.assignTexture(t, "specularColorMap", s.specularColorTexture, it)),
        Promise.all(r)
    }
}
class vT {
    constructor(e) {
        this.parser = e,
        this.name = je.KHR_TEXTURE_BASISU
    }
    loadTexture(e) {
        const t = this.parser
          , n = t.json
          , i = n.textures[e];
        if (!i.extensions || !i.extensions[this.name])
            return null;
        const r = i.extensions[this.name]
          , s = t.options.ktx2Loader;
        if (!s) {
            if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
                throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null
        }
        return t.loadTextureImage(e, r.source, s)
    }
}
class xT {
    constructor(e) {
        this.parser = e,
        this.name = je.EXT_TEXTURE_WEBP,
        this.isSupported = null
    }
    loadTexture(e) {
        const t = this.name
          , n = this.parser
          , i = n.json
          , r = i.textures[e];
        if (!r.extensions || !r.extensions[t])
            return null;
        const s = r.extensions[t]
          , a = i.images[s.source];
        let l = n.textureLoader;
        if (a.uri) {
            const u = n.options.manager.getHandler(a.uri);
            u !== null && (l = u)
        }
        return this.detectSupport().then(function(u) {
            if (u)
                return n.loadTextureImage(e, s.source, l);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
                throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            return n.loadTexture(e)
        })
    }
    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise(function(e) {
            const t = new Image;
            t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
            t.onload = t.onerror = function() {
                e(t.height === 1)
            }
        }
        )),
        this.isSupported
    }
}
class yT {
    constructor(e) {
        this.name = je.EXT_MESHOPT_COMPRESSION,
        this.parser = e
    }
    loadBufferView(e) {
        const t = this.parser.json
          , n = t.bufferViews[e];
        if (n.extensions && n.extensions[this.name]) {
            const i = n.extensions[this.name]
              , r = this.parser.getDependency("buffer", i.buffer)
              , s = this.parser.options.meshoptDecoder;
            if (!s || !s.supported) {
                if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
                    throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                return null
            }
            return r.then(function(a) {
                const l = i.byteOffset || 0
                  , u = i.byteLength || 0
                  , c = i.count
                  , h = i.byteStride
                  , f = new Uint8Array(a,l,u);
                return s.decodeGltfBufferAsync ? s.decodeGltfBufferAsync(c, h, f, i.mode, i.filter).then(function(m) {
                    return m.buffer
                }) : s.ready.then(function() {
                    const m = new ArrayBuffer(c * h);
                    return s.decodeGltfBuffer(new Uint8Array(m), c, h, f, i.mode, i.filter),
                    m
                })
            })
        } else
            return null
    }
}
const d_ = "glTF"
  , So = 12
  , vp = {
    JSON: 1313821514,
    BIN: 5130562
};
class bT {
    constructor(e) {
        this.name = je.KHR_BINARY_GLTF,
        this.content = null,
        this.body = null;
        const t = new DataView(e,0,So);
        if (this.header = {
            magic: Yr.decodeText(new Uint8Array(e.slice(0, 4))),
            version: t.getUint32(4, !0),
            length: t.getUint32(8, !0)
        },
        this.header.magic !== d_)
            throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2)
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        const n = this.header.length - So
          , i = new DataView(e,So);
        let r = 0;
        for (; r < n; ) {
            const s = i.getUint32(r, !0);
            r += 4;
            const a = i.getUint32(r, !0);
            if (r += 4,
            a === vp.JSON) {
                const l = new Uint8Array(e,So + r,s);
                this.content = Yr.decodeText(l)
            } else if (a === vp.BIN) {
                const l = So + r;
                this.body = e.slice(l, l + s)
            }
            r += s
        }
        if (this.content === null)
            throw new Error("THREE.GLTFLoader: JSON content not found.")
    }
}
class wT {
    constructor(e, t) {
        if (!t)
            throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
        this.name = je.KHR_DRACO_MESH_COMPRESSION,
        this.json = e,
        this.dracoLoader = t,
        this.dracoLoader.preload()
    }
    decodePrimitive(e, t) {
        const n = this.json
          , i = this.dracoLoader
          , r = e.extensions[this.name].bufferView
          , s = e.extensions[this.name].attributes
          , a = {}
          , l = {}
          , u = {};
        for (const c in s) {
            const h = Nc[c] || c.toLowerCase();
            a[h] = s[c]
        }
        for (const c in e.attributes) {
            const h = Nc[c] || c.toLowerCase();
            if (s[c] !== void 0) {
                const f = n.accessors[e.attributes[c]]
                  , m = ha[f.componentType];
                u[h] = m.name,
                l[h] = f.normalized === !0
            }
        }
        return t.getDependency("bufferView", r).then(function(c) {
            return new Promise(function(h) {
                i.decodeDracoFile(c, function(f) {
                    for (const m in f.attributes) {
                        const _ = f.attributes[m]
                          , d = l[m];
                        d !== void 0 && (_.normalized = d)
                    }
                    h(f)
                }, a, u)
            }
            )
        })
    }
}
class MT {
    constructor() {
        this.name = je.KHR_TEXTURE_TRANSFORM
    }
    extendTexture(e, t) {
        return t.texCoord !== void 0 && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'),
        t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        e.needsUpdate = !0),
        e
    }
}
class Oc extends Xl {
    constructor(e) {
        super(),
        this.isGLTFSpecularGlossinessMaterial = !0;
        const t = ["#ifdef USE_SPECULARMAP", "	uniform sampler2D specularMap;", "#endif"].join(`
`)
          , n = ["#ifdef USE_GLOSSINESSMAP", "	uniform sampler2D glossinessMap;", "#endif"].join(`
`)
          , i = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "	vec4 texelSpecular = texture2D( specularMap, vUv );", "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "	specularFactor *= texelSpecular.rgb;", "#endif"].join(`
`)
          , r = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );", "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "	glossinessFactor *= texelGlossiness.a;", "#endif"].join(`
`)
          , s = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join(`
`)
          , a = {
            specular: {
                value: new ze().setHex(16777215)
            },
            glossiness: {
                value: 1
            },
            specularMap: {
                value: null
            },
            glossinessMap: {
                value: null
            }
        };
        this._extraUniforms = a,
        this.onBeforeCompile = function(l) {
            for (const u in a)
                l.uniforms[u] = a[u];
            l.fragmentShader = l.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", i).replace("#include <metalnessmap_fragment>", r).replace("#include <lights_physical_fragment>", s)
        }
        ,
        Object.defineProperties(this, {
            specular: {
                get: function() {
                    return a.specular.value
                },
                set: function(l) {
                    a.specular.value = l
                }
            },
            specularMap: {
                get: function() {
                    return a.specularMap.value
                },
                set: function(l) {
                    a.specularMap.value = l,
                    l ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                }
            },
            glossiness: {
                get: function() {
                    return a.glossiness.value
                },
                set: function(l) {
                    a.glossiness.value = l
                }
            },
            glossinessMap: {
                get: function() {
                    return a.glossinessMap.value
                },
                set: function(l) {
                    a.glossinessMap.value = l,
                    l ? (this.defines.USE_GLOSSINESSMAP = "",
                    this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP,
                    delete this.defines.USE_UV)
                }
            }
        }),
        delete this.metalness,
        delete this.roughness,
        delete this.metalnessMap,
        delete this.roughnessMap,
        this.setPhilosophy(e)
    }
    copy(e) {
        return super.copy(e),
        this.specularMap = e.specularMap,
        this.specular.copy(e.specular),
        this.glossinessMap = e.glossinessMap,
        this.glossiness = e.glossiness,
        delete this.metalness,
        delete this.roughness,
        delete this.metalnessMap,
        delete this.roughnessMap,
        this
    }
}
class ST {
    constructor() {
        this.name = je.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
        this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity"]
    }
    getMaterialType() {
        return Oc
    }
    extendParams(e, t, n) {
        const i = t.extensions[this.name];
        e.color = new ze(1,1,1),
        e.opacity = 1;
        const r = [];
        if (Array.isArray(i.diffuseFactor)) {
            const s = i.diffuseFactor;
            e.color.fromArray(s),
            e.opacity = s[3]
        }
        if (i.diffuseTexture !== void 0 && r.push(n.assignTexture(e, "map", i.diffuseTexture, it)),
        e.emissive = new ze(0,0,0),
        e.glossiness = i.glossinessFactor !== void 0 ? i.glossinessFactor : 1,
        e.specular = new ze(1,1,1),
        Array.isArray(i.specularFactor) && e.specular.fromArray(i.specularFactor),
        i.specularGlossinessTexture !== void 0) {
            const s = i.specularGlossinessTexture;
            r.push(n.assignTexture(e, "glossinessMap", s)),
            r.push(n.assignTexture(e, "specularMap", s, it))
        }
        return Promise.all(r)
    }
    createMaterial(e) {
        const t = new Oc(e);
        return t.fog = !0,
        t.color = e.color,
        t.map = e.map === void 0 ? null : e.map,
        t.lightMap = null,
        t.lightMapIntensity = 1,
        t.aoMap = e.aoMap === void 0 ? null : e.aoMap,
        t.aoMapIntensity = 1,
        t.emissive = e.emissive,
        t.emissiveIntensity = e.emissiveIntensity === void 0 ? 1 : e.emissiveIntensity,
        t.emissiveMap = e.emissiveMap === void 0 ? null : e.emissiveMap,
        t.bumpMap = e.bumpMap === void 0 ? null : e.bumpMap,
        t.bumpScale = 1,
        t.normalMap = e.normalMap === void 0 ? null : e.normalMap,
        t.normalMapType = fh,
        e.normalScale && (t.normalScale = e.normalScale),
        t.displacementMap = null,
        t.displacementScale = 1,
        t.displacementBias = 0,
        t.specularMap = e.specularMap === void 0 ? null : e.specularMap,
        t.specular = e.specular,
        t.glossinessMap = e.glossinessMap === void 0 ? null : e.glossinessMap,
        t.glossiness = e.glossiness,
        t.alphaMap = null,
        t.envMap = e.envMap === void 0 ? null : e.envMap,
        t.envMapIntensity = 1,
        t
    }
}
class DT {
    constructor() {
        this.name = je.KHR_MESH_QUANTIZATION
    }
}
class p_ extends _a {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    copySampleValue_(e) {
        const t = this.resultBuffer
          , n = this.samplePhilosophy
          , i = this.valueSize
          , r = e * i * 3 + i;
        for (let s = 0; s !== i; s++)
            t[s] = n[r + s];
        return t
    }
    interpolate_(e, t, n, i) {
        const r = this.resultBuffer
          , s = this.samplePhilosophy
          , a = this.valueSize
          , l = a * 2
          , u = a * 3
          , c = i - t
          , h = (n - t) / c
          , f = h * h
          , m = f * h
          , _ = e * u
          , d = _ - u
          , p = -2 * m + 3 * f
          , v = m - f
          , x = 1 - p
          , S = v - f + h;
        for (let M = 0; M !== a; M++) {
            const T = s[d + M + a]
              , L = s[d + M + l] * c
              , P = s[_ + M + a]
              , A = s[_ + M] * c;
            r[M] = x * T + S * L + p * P + v * A
        }
        return r
    }
}
const TT = new os;
class ET extends p_ {
    interpolate_(e, t, n, i) {
        const r = super.interpolate_(e, t, n, i);
        return TT.fromArray(r).normalize().toArray(r),
        r
    }
}
const Mi = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123
}
  , ha = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
}
  , xp = {
    9728: Vt,
    9729: It,
    9984: Ac,
    9985: Vg,
    9986: Cc,
    9987: ss
}
  , yp = {
    33071: fn,
    33648: Nl,
    10497: to
}
  , bp = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
}
  , Nc = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex"
}
  , tr = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences"
}
  , AT = {
    CUBICSPLINE: void 0,
    LINEAR: io,
    STEP: oa
}
  , Zu = {
    OPAQUE: "OPAQUE",
    MASK: "MASK",
    BLEND: "BLEND"
};
function CT(o) {
    return o.DefaultMaterial === void 0 && (o.DefaultMaterial = new Xl({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: Jr
    })),
    o.DefaultMaterial
}
function Do(o, e, t) {
    for (const n in t.extensions)
        o[n] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {},
        e.userData.gltfExtensions[n] = t.extensions[n])
}
function Lr(o, e) {
    e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(o.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
}
function LT(o, e, t) {
    let n = !1
      , i = !1
      , r = !1;
    for (let u = 0, c = e.length; u < c; u++) {
        const h = e[u];
        if (h.POSITION !== void 0 && (n = !0),
        h.NORMAL !== void 0 && (i = !0),
        h.COLOR_0 !== void 0 && (r = !0),
        n && i && r)
            break
    }
    if (!n && !i && !r)
        return Promise.resolve(o);
    const s = []
      , a = []
      , l = [];
    for (let u = 0, c = e.length; u < c; u++) {
        const h = e[u];
        if (n) {
            const f = h.POSITION !== void 0 ? t.getDependency("accessor", h.POSITION) : o.attributes.position;
            s.push(f)
        }
        if (i) {
            const f = h.NORMAL !== void 0 ? t.getDependency("accessor", h.NORMAL) : o.attributes.normal;
            a.push(f)
        }
        if (r) {
            const f = h.COLOR_0 !== void 0 ? t.getDependency("accessor", h.COLOR_0) : o.attributes.color;
            l.push(f)
        }
    }
    return Promise.all([Promise.all(s), Promise.all(a), Promise.all(l)]).then(function(u) {
        const c = u[0]
          , h = u[1]
          , f = u[2];
        return n && (o.morphAttributes.position = c),
        i && (o.morphAttributes.normal = h),
        r && (o.morphAttributes.color = f),
        o.morphTargetsRelative = !0,
        o
    })
}
function RT(o, e) {
    if (o.updateMorphTargets(),
    e.weights !== void 0)
        for (let t = 0, n = e.weights.length; t < n; t++)
            o.morphTargetInfluences[t] = e.weights[t];
    if (e.extras && Array.isArray(e.extras.targetNames)) {
        const t = e.extras.targetNames;
        if (o.morphTargetInfluences.length === t.length) {
            o.morphTargetDictionary = {};
            for (let n = 0, i = t.length; n < i; n++)
                o.morphTargetDictionary[t[n]] = n
        } else
            console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
    }
}
function PT(o) {
    const e = o.extensions && o.extensions[je.KHR_DRACO_MESH_COMPRESSION];
    let t;
    return e ? t = "draco:" + e.bufferView + ":" + e.indices + ":" + wp(e.attributes) : t = o.indices + ":" + wp(o.attributes) + ":" + o.mode,
    t
}
function wp(o) {
    let e = "";
    const t = Object.keys(o).sort();
    for (let n = 0, i = t.length; n < i; n++)
        e += t[n] + ":" + o[t[n]] + ";";
    return e
}
function kc(o) {
    switch (o) {
    case Int8Array:
        return 1 / 127;
    case Uint8Array:
        return 1 / 255;
    case Int16Array:
        return 1 / 32767;
    case Uint16Array:
        return 1 / 65535;
    default:
        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
    }
}
function IT(o) {
    return o.search(/\.jpe?g($|\?)/i) > 0 || o.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : o.search(/\.webp($|\?)/i) > 0 || o.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png"
}
class FT {
    constructor(e={}, t={}) {
        this.json = e,
        this.extensions = {},
        this.plugins = {},
        this.options = t,
        this.cache = new aT,
        this.associations = new Map,
        this.primitiveCache = {},
        this.meshCache = {
            refs: {},
            uses: {}
        },
        this.cameraCache = {
            refs: {},
            uses: {}
        },
        this.lightCache = {
            refs: {},
            uses: {}
        },
        this.sourceCache = {},
        this.textureCache = {},
        this.nodeNamesUsed = {};
        const n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0
          , i = navigator.userAgent.indexOf("Firefox") > -1
          , r = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
        typeof createImageBitmap > "u" || n || i && r < 98 ? this.textureLoader = new VD(this.options.manager) : this.textureLoader = new YD(this.options.manager),
        this.textureLoader.setCrossOrigin(this.options.crossOrigin),
        this.textureLoader.setRequestHeader(this.options.requestHeader),
        this.fileLoader = new wh(this.options.manager),
        this.fileLoader.setResponseType("arraybuffer"),
        this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0)
    }
    setExtensions(e) {
        this.extensions = e
    }
    setPlugins(e) {
        this.plugins = e
    }
    parse(e, t) {
        const n = this
          , i = this.json
          , r = this.extensions;
        this.cache.removeAll(),
        this._invokeAll(function(s) {
            return s._markDefs && s._markDefs()
        }),
        Promise.all(this._invokeAll(function(s) {
            return s.beforeRoot && s.beforeRoot()
        })).then(function() {
            return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
        }).then(function(s) {
            const a = {
                scene: s[0][i.scene || 0],
                scenes: s[0],
                animations: s[1],
                cameras: s[2],
                asset: i.asset,
                parser: n,
                userData: {}
            };
            Do(r, a, i),
            Lr(a, i),
            Promise.all(n._invokeAll(function(l) {
                return l.afterRoot && l.afterRoot(a)
            })).then(function() {
                e(a)
            })
        }).catch(t)
    }
    _markDefs() {
        const e = this.json.nodes || []
          , t = this.json.skins || []
          , n = this.json.meshes || [];
        for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i].joints;
            for (let a = 0, l = s.length; a < l; a++)
                e[s[a]].isBone = !0
        }
        for (let i = 0, r = e.length; i < r; i++) {
            const s = e[i];
            s.mesh !== void 0 && (this._addNodeRef(this.meshCache, s.mesh),
            s.skin !== void 0 && (n[s.mesh].isSkinnedMesh = !0)),
            s.camera !== void 0 && this._addNodeRef(this.cameraCache, s.camera)
        }
    }
    _addNodeRef(e, t) {
        t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0),
        e.refs[t]++)
    }
    _getNodeRef(e, t, n) {
        if (e.refs[t] <= 1)
            return n;
        const i = n.clone()
          , r = (s, a) => {
            const l = this.associations.get(s);
            l != null && this.associations.set(a, l);
            for (const [u,c] of s.children.entries())
                r(c, a.children[u])
        }
        ;
        return r(n, i),
        i.name += "_instance_" + e.uses[t]++,
        i
    }
    _invokeOne(e) {
        const t = Object.values(this.plugins);
        t.push(this);
        for (let n = 0; n < t.length; n++) {
            const i = e(t[n]);
            if (i)
                return i
        }
        return null
    }
    _invokeAll(e) {
        const t = Object.values(this.plugins);
        t.unshift(this);
        const n = [];
        for (let i = 0; i < t.length; i++) {
            const r = e(t[i]);
            r && n.push(r)
        }
        return n
    }
    getDependency(e, t) {
        const n = e + ":" + t;
        let i = this.cache.get(n);
        if (!i) {
            switch (e) {
            case "scene":
                i = this.loadScene(t);
                break;
            case "node":
                i = this.loadNode(t);
                break;
            case "mesh":
                i = this._invokeOne(function(r) {
                    return r.loadMesh && r.loadMesh(t)
                });
                break;
            case "accessor":
                i = this.loadAccessor(t);
                break;
            case "bufferView":
                i = this._invokeOne(function(r) {
                    return r.loadBufferView && r.loadBufferView(t)
                });
                break;
            case "buffer":
                i = this.loadBuffer(t);
                break;
            case "material":
                i = this._invokeOne(function(r) {
                    return r.loadMaterial && r.loadMaterial(t)
                });
                break;
            case "texture":
                i = this._invokeOne(function(r) {
                    return r.loadTexture && r.loadTexture(t)
                });
                break;
            case "skin":
                i = this.loadSkin(t);
                break;
            case "animation":
                i = this._invokeOne(function(r) {
                    return r.loadAnimation && r.loadAnimation(t)
                });
                break;
            case "camera":
                i = this.loadCamera(t);
                break;
            default:
                throw new Error("Unknown type: " + e)
            }
            this.cache.add(n, i)
        }
        return i
    }
    getDependencies(e) {
        let t = this.cache.get(e);
        if (!t) {
            const n = this
              , i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
            t = Promise.all(i.map(function(r, s) {
                return n.getDependency(e, s)
            })),
            this.cache.add(e, t)
        }
        return t
    }
    loadBuffer(e) {
        const t = this.json.buffers[e]
          , n = this.fileLoader;
        if (t.type && t.type !== "arraybuffer")
            throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
        if (t.uri === void 0 && e === 0)
            return Promise.resolve(this.extensions[je.KHR_BINARY_GLTF].body);
        const i = this.options;
        return new Promise(function(r, s) {
            n.load(Yr.resolveURL(t.uri, i.path), r, void 0, function() {
                s(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
            })
        }
        )
    }
    loadBufferView(e) {
        const t = this.json.bufferViews[e];
        return this.getDependency("buffer", t.buffer).then(function(n) {
            const i = t.byteLength || 0
              , r = t.byteOffset || 0;
            return n.slice(r, r + i)
        })
    }
    loadAccessor(e) {
        const t = this
          , n = this.json
          , i = this.json.accessors[e];
        if (i.bufferView === void 0 && i.sparse === void 0)
            return Promise.resolve(null);
        const r = [];
        return i.bufferView !== void 0 ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null),
        i.sparse !== void 0 && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)),
        r.push(this.getDependency("bufferView", i.sparse.values.bufferView))),
        Promise.all(r).then(function(s) {
            const a = s[0]
              , l = bp[i.type]
              , u = ha[i.componentType]
              , c = u.BYTES_PER_ELEMENT
              , h = c * l
              , f = i.byteOffset || 0
              , m = i.bufferView !== void 0 ? n.bufferViews[i.bufferView].byteStride : void 0
              , _ = i.normalized === !0;
            let d, p;
            if (m && m !== h) {
                const v = Math.floor(f / m)
                  , x = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + v + ":" + i.count;
                let S = t.cache.get(x);
                S || (d = new u(a,v * m,i.count * m / c),
                S = new bD(d,m / c),
                t.cache.add(x, S)),
                p = new xh(S,l,f % m / c,_)
            } else
                a === null ? d = new u(i.count * l) : d = new u(a,f,i.count * l),
                p = new gn(d,l,_);
            if (i.sparse !== void 0) {
                const v = bp.SCALAR
                  , x = ha[i.sparse.indices.componentType]
                  , S = i.sparse.indices.byteOffset || 0
                  , M = i.sparse.values.byteOffset || 0
                  , T = new x(s[1],S,i.sparse.count * v)
                  , L = new u(s[2],M,i.sparse.count * l);
                a !== null && (p = new gn(p.array.slice(),p.itemSize,p.normalized));
                for (let P = 0, A = T.length; P < A; P++) {
                    const C = T[P];
                    if (p.setX(C, L[P * l]),
                    l >= 2 && p.setY(C, L[P * l + 1]),
                    l >= 3 && p.setZ(C, L[P * l + 2]),
                    l >= 4 && p.setW(C, L[P * l + 3]),
                    l >= 5)
                        throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                }
            }
            return p
        })
    }
    loadTexture(e) {
        const t = this.json
          , n = this.options
          , r = t.textures[e].source
          , s = t.images[r];
        let a = this.textureLoader;
        if (s.uri) {
            const l = n.manager.getHandler(s.uri);
            l !== null && (a = l)
        }
        return this.loadTextureImage(e, r, a)
    }
    loadTextureImage(e, t, n) {
        const i = this
          , r = this.json
          , s = r.textures[e]
          , a = r.images[t]
          , l = (a.uri || a.bufferView) + ":" + s.sampler;
        if (this.textureCache[l])
            return this.textureCache[l];
        const u = this.loadImageSource(t, n).then(function(c) {
            c.flipY = !1,
            s.name && (c.name = s.name);
            const f = (r.samplers || {})[s.sampler] || {};
            return c.magFilter = xp[f.magFilter] || It,
            c.minFilter = xp[f.minFilter] || ss,
            c.wrapS = yp[f.wrapS] || to,
            c.wrapT = yp[f.wrapT] || to,
            i.associations.set(c, {
                textures: e
            }),
            c
        }).catch(function() {
            return null
        });
        return this.textureCache[l] = u,
        u
    }
    loadImageSource(e, t) {
        const n = this
          , i = this.json
          , r = this.options;
        if (this.sourceCache[e] !== void 0)
            return this.sourceCache[e].then(h => h.clone());
        const s = i.images[e]
          , a = self.URL || self.webkitURL;
        let l = s.uri || ""
          , u = !1;
        if (s.bufferView !== void 0)
            l = n.getDependency("bufferView", s.bufferView).then(function(h) {
                u = !0;
                const f = new Blob([h],{
                    type: s.mimeType
                });
                return l = a.createObjectURL(f),
                l
            });
        else if (s.uri === void 0)
            throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
        const c = Promise.resolve(l).then(function(h) {
            return new Promise(function(f, m) {
                let _ = f;
                t.isImageBitmapLoader === !0 && (_ = function(d) {
                    const p = new tn(d);
                    p.needsUpdate = !0,
                    f(p)
                }
                ),
                t.load(Yr.resolveURL(h, r.path), _, void 0, m)
            }
            )
        }).then(function(h) {
            return u === !0 && a.revokeObjectURL(l),
            h.userData.mimeType = s.mimeType || IT(s.uri),
            h
        }).catch(function(h) {
            throw console.error("THREE.GLTFLoader: Couldn't load texture", l),
            h
        });
        return this.sourceCache[e] = c,
        c
    }
    assignTexture(e, t, n, i) {
        const r = this;
        return this.getDependency("texture", n.index).then(function(s) {
            if (n.texCoord !== void 0 && n.texCoord != 0 && !(t === "aoMap" && n.texCoord == 1) && console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + t + " not yet supported."),
            r.extensions[je.KHR_TEXTURE_TRANSFORM]) {
                const a = n.extensions !== void 0 ? n.extensions[je.KHR_TEXTURE_TRANSFORM] : void 0;
                if (a) {
                    const l = r.associations.get(s);
                    s = r.extensions[je.KHR_TEXTURE_TRANSFORM].extendTexture(s, a),
                    r.associations.set(s, l)
                }
            }
            return i !== void 0 && (s.encoding = i),
            e[t] = s,
            s
        })
    }
    assignFinalMaterial(e) {
        const t = e.geometry;
        let n = e.material;
        const i = t.attributes.tangent === void 0
          , r = t.attributes.color !== void 0
          , s = t.attributes.normal === void 0;
        if (e.isPoints) {
            const a = "PointsMaterial:" + n.uuid;
            let l = this.cache.get(a);
            l || (l = new u_,
            fi.prototype.copy.call(l, n),
            l.color.copy(n.color),
            l.map = n.map,
            l.sizeAttenuation = !1,
            this.cache.add(a, l)),
            n = l
        } else if (e.isLine) {
            const a = "LineBasicMaterial:" + n.uuid;
            let l = this.cache.get(a);
            l || (l = new l_,
            fi.prototype.copy.call(l, n),
            l.color.copy(n.color),
            this.cache.add(a, l)),
            n = l
        }
        if (i || r || s) {
            let a = "ClonedMaterial:" + n.uuid + ":";
            n.isGLTFSpecularGlossinessMaterial && (a += "specular-glossiness:"),
            i && (a += "derivative-tangents:"),
            r && (a += "vertex-colors:"),
            s && (a += "flat-shading:");
            let l = this.cache.get(a);
            l || (l = n.clone(),
            r && (l.vertexColors = !0),
            s && (l.flatShading = !0),
            i && (l.normalScale && (l.normalScale.y *= -1),
            l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
            this.cache.add(a, l),
            this.associations.set(l, this.associations.get(n))),
            n = l
        }
        n.aoMap && t.attributes.uv2 === void 0 && t.attributes.uv !== void 0 && t.setAttribute("uv2", t.attributes.uv),
        e.material = n
    }
    getMaterialType() {
        return Xl
    }
    loadMaterial(e) {
        const t = this
          , n = this.json
          , i = this.extensions
          , r = n.materials[e];
        let s;
        const a = {}
          , l = r.extensions || {}
          , u = [];
        if (l[je.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
            const h = i[je.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
            s = h.getMaterialType(),
            u.push(h.extendParams(a, r, t))
        } else if (l[je.KHR_MATERIALS_UNLIT]) {
            const h = i[je.KHR_MATERIALS_UNLIT];
            s = h.getMaterialType(),
            u.push(h.extendParams(a, r, t))
        } else {
            const h = r.pbrMetallicRoughness || {};
            if (a.color = new ze(1,1,1),
            a.opacity = 1,
            Array.isArray(h.baseColorFactor)) {
                const f = h.baseColorFactor;
                a.color.fromArray(f),
                a.opacity = f[3]
            }
            h.baseColorTexture !== void 0 && u.push(t.assignTexture(a, "map", h.baseColorTexture, it)),
            a.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1,
            a.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1,
            h.metallicRoughnessTexture !== void 0 && (u.push(t.assignTexture(a, "metalnessMap", h.metallicRoughnessTexture)),
            u.push(t.assignTexture(a, "roughnessMap", h.metallicRoughnessTexture))),
            s = this._invokeOne(function(f) {
                return f.getMaterialType && f.getMaterialType(e)
            }),
            u.push(Promise.all(this._invokeAll(function(f) {
                return f.extendMaterialParams && f.extendMaterialParams(e, a)
            })))
        }
        r.doubleSided === !0 && (a.side = Oi);
        const c = r.alphaMode || Zu.OPAQUE;
        if (c === Zu.BLEND ? (a.transparent = !0,
        a.depthWrite = !1) : (a.transparent = !1,
        c === Zu.MASK && (a.alphaTest = r.alphaCutoff !== void 0 ? r.alphaCutoff : .5)),
        r.normalTexture !== void 0 && s !== Ur && (u.push(t.assignTexture(a, "normalMap", r.normalTexture)),
        a.normalScale = new Ze(1,1),
        r.normalTexture.scale !== void 0)) {
            const h = r.normalTexture.scale;
            a.normalScale.set(h, h)
        }
        return r.occlusionTexture !== void 0 && s !== Ur && (u.push(t.assignTexture(a, "aoMap", r.occlusionTexture)),
        r.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = r.occlusionTexture.strength)),
        r.emissiveFactor !== void 0 && s !== Ur && (a.emissive = new ze().fromArray(r.emissiveFactor)),
        r.emissiveTexture !== void 0 && s !== Ur && u.push(t.assignTexture(a, "emissiveMap", r.emissiveTexture, it)),
        Promise.all(u).then(function() {
            let h;
            return s === Oc ? h = i[je.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : h = new s(a),
            r.name && (h.name = r.name),
            Lr(h, r),
            t.associations.set(h, {
                materials: e
            }),
            r.extensions && Do(i, h, r),
            h
        })
    }
    createUniqueName(e) {
        const t = rt.sanitizeNodeName(e || "");
        let n = t;
        for (let i = 1; this.nodeNamesUsed[n]; ++i)
            n = t + "_" + i;
        return this.nodeNamesUsed[n] = !0,
        n
    }
    loadGeometries(e) {
        const t = this
          , n = this.extensions
          , i = this.primitiveCache;
        function r(a) {
            return n[je.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function(l) {
                return Mp(l, a, t)
            })
        }
        const s = [];
        for (let a = 0, l = e.length; a < l; a++) {
            const u = e[a]
              , c = PT(u)
              , h = i[c];
            if (h)
                s.push(h.promise);
            else {
                let f;
                u.extensions && u.extensions[je.KHR_DRACO_MESH_COMPRESSION] ? f = r(u) : f = Mp(new pi, u, t),
                i[c] = {
                    primitive: u,
                    promise: f
                },
                s.push(f)
            }
        }
        return Promise.all(s)
    }
    loadMesh(e) {
        const t = this
          , n = this.json
          , i = this.extensions
          , r = n.meshes[e]
          , s = r.primitives
          , a = [];
        for (let l = 0, u = s.length; l < u; l++) {
            const c = s[l].material === void 0 ? CT(this.cache) : this.getDependency("material", s[l].material);
            a.push(c)
        }
        return a.push(t.loadGeometries(s)),
        Promise.all(a).then(function(l) {
            const u = l.slice(0, l.length - 1)
              , c = l[l.length - 1]
              , h = [];
            for (let m = 0, _ = c.length; m < _; m++) {
                const d = c[m]
                  , p = s[m];
                let v;
                const x = u[m];
                if (p.mode === Mi.TRIANGLES || p.mode === Mi.TRIANGLE_STRIP || p.mode === Mi.TRIANGLE_FAN || p.mode === void 0)
                    v = r.isSkinnedMesh === !0 ? new MD(d,x) : new Vn(d,x),
                    v.isSkinnedMesh === !0 && !v.geometry.attributes.skinWeight.normalized && v.normalizeSkinWeights(),
                    p.mode === Mi.TRIANGLE_STRIP ? v.geometry = Sp(v.geometry, rb) : p.mode === Mi.TRIANGLE_FAN && (v.geometry = Sp(v.geometry, Hg));
                else if (p.mode === Mi.LINES)
                    v = new DD(d,x);
                else if (p.mode === Mi.LINE_STRIP)
                    v = new bh(d,x);
                else if (p.mode === Mi.LINE_LOOP)
                    v = new TD(d,x);
                else if (p.mode === Mi.POINTS)
                    v = new ED(d,x);
                else
                    throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + p.mode);
                Object.keys(v.geometry.morphAttributes).length > 0 && RT(v, r),
                v.name = t.createUniqueName(r.name || "mesh_" + e),
                Lr(v, r),
                p.extensions && Do(i, v, p),
                t.assignFinalMaterial(v),
                h.push(v)
            }
            for (let m = 0, _ = h.length; m < _; m++)
                t.associations.set(h[m], {
                    meshes: e,
                    primitives: m
                });
            if (h.length === 1)
                return h[0];
            const f = new Br;
            t.associations.set(f, {
                meshes: e
            });
            for (let m = 0, _ = h.length; m < _; m++)
                f.add(h[m]);
            return f
        })
    }
    loadCamera(e) {
        let t;
        const n = this.json.cameras[e]
          , i = n[n.type];
        if (!i) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return
        }
        return n.type === "perspective" ? t = new un(wb.radToDeg(i.yfov),i.aspectRatio || 1,i.znear || 1,i.zfar || 2e6) : n.type === "orthographic" && (t = new _h(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),
        n.name && (t.name = this.createUniqueName(n.name)),
        Lr(t, n),
        Promise.resolve(t)
    }
    loadSkin(e) {
        const t = this.json.skins[e]
          , n = {
            joints: t.joints
        };
        return t.inverseBindMatrices === void 0 ? Promise.resolve(n) : this.getDependency("accessor", t.inverseBindMatrices).then(function(i) {
            return n.inverseBindMatrices = i,
            n
        })
    }
    loadAnimation(e) {
        const n = this.json.animations[e]
          , i = []
          , r = []
          , s = []
          , a = []
          , l = [];
        for (let u = 0, c = n.channels.length; u < c; u++) {
            const h = n.channels[u]
              , f = n.samplers[h.sampler]
              , m = h.target
              , _ = m.node
              , d = n.parameters !== void 0 ? n.parameters[f.input] : f.input
              , p = n.parameters !== void 0 ? n.parameters[f.output] : f.output;
            i.push(this.getDependency("node", _)),
            r.push(this.getDependency("accessor", d)),
            s.push(this.getDependency("accessor", p)),
            a.push(f),
            l.push(m)
        }
        return Promise.all([Promise.all(i), Promise.all(r), Promise.all(s), Promise.all(a), Promise.all(l)]).then(function(u) {
            const c = u[0]
              , h = u[1]
              , f = u[2]
              , m = u[3]
              , _ = u[4]
              , d = [];
            for (let v = 0, x = c.length; v < x; v++) {
                const S = c[v]
                  , M = h[v]
                  , T = f[v]
                  , L = m[v]
                  , P = _[v];
                if (S === void 0)
                    continue;
                S.updateMatrix();
                let A;
                switch (tr[P.path]) {
                case tr.weights:
                    A = ua;
                    break;
                case tr.rotation:
                    A = ns;
                    break;
                case tr.position:
                case tr.scale:
                default:
                    A = ca;
                    break
                }
                const C = S.name ? S.name : S.uuid
                  , N = L.interpolation !== void 0 ? AT[L.interpolation] : io
                  , G = [];
                tr[P.path] === tr.weights ? S.traverse(function(g) {
                    g.morphTargetInfluences && G.push(g.name ? g.name : g.uuid)
                }) : G.push(C);
                let q = T.array;
                if (T.normalized) {
                    const g = kc(q.constructor)
                      , w = new Float32Array(q.length);
                    for (let E = 0, R = q.length; E < R; E++)
                        w[E] = q[E] * g;
                    q = w
                }
                for (let g = 0, w = G.length; g < w; g++) {
                    const E = new A(G[g] + "." + tr[P.path],M.array,q,N);
                    L.interpolation === "CUBICSPLINE" && (E.createInterpolant = function(z) {
                        const b = this instanceof ns ? ET : p_;
                        return new b(this.times,this.values,this.getValueSize() / 3,z)
                    }
                    ,
                    E.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0),
                    d.push(E)
                }
            }
            const p = n.name ? n.name : "animation_" + e;
            return new ID(p,void 0,d)
        })
    }
    createNodeMesh(e) {
        const t = this.json
          , n = this
          , i = t.nodes[e];
        return i.mesh === void 0 ? null : n.getDependency("mesh", i.mesh).then(function(r) {
            const s = n._getNodeRef(n.meshCache, i.mesh, r);
            return i.weights !== void 0 && s.traverse(function(a) {
                if (!!a.isMesh)
                    for (let l = 0, u = i.weights.length; l < u; l++)
                        a.morphTargetInfluences[l] = i.weights[l]
            }),
            s
        })
    }
    loadNode(e) {
        const t = this.json
          , n = this.extensions
          , i = this
          , r = t.nodes[e]
          , s = r.name ? i.createUniqueName(r.name) : "";
        return function() {
            const a = []
              , l = i._invokeOne(function(u) {
                return u.createNodeMesh && u.createNodeMesh(e)
            });
            return l && a.push(l),
            r.camera !== void 0 && a.push(i.getDependency("camera", r.camera).then(function(u) {
                return i._getNodeRef(i.cameraCache, r.camera, u)
            })),
            i._invokeAll(function(u) {
                return u.createNodeAttachment && u.createNodeAttachment(e)
            }).forEach(function(u) {
                a.push(u)
            }),
            Promise.all(a)
        }().then(function(a) {
            let l;
            if (r.isBone === !0 ? l = new o_ : a.length > 1 ? l = new Br : a.length === 1 ? l = a[0] : l = new yt,
            l !== a[0])
                for (let u = 0, c = a.length; u < c; u++)
                    l.add(a[u]);
            if (r.name && (l.userData.name = r.name,
            l.name = s),
            Lr(l, r),
            r.extensions && Do(n, l, r),
            r.matrix !== void 0) {
                const u = new Ke;
                u.fromArray(r.matrix),
                l.applyMatrix4(u)
            } else
                r.translation !== void 0 && l.position.fromArray(r.translation),
                r.rotation !== void 0 && l.quaternion.fromArray(r.rotation),
                r.scale !== void 0 && l.scale.fromArray(r.scale);
            return i.associations.has(l) || i.associations.set(l, {}),
            i.associations.get(l).nodes = e,
            l
        })
    }
    loadScene(e) {
        const t = this.json
          , n = this.extensions
          , i = this.json.scenes[e]
          , r = this
          , s = new Br;
        i.name && (s.name = r.createUniqueName(i.name)),
        Lr(s, i),
        i.extensions && Do(n, s, i);
        const a = i.nodes || []
          , l = [];
        for (let u = 0, c = a.length; u < c; u++)
            l.push(m_(a[u], s, t, r));
        return Promise.all(l).then(function() {
            const u = c => {
                const h = new Map;
                for (const [f,m] of r.associations)
                    (f instanceof fi || f instanceof tn) && h.set(f, m);
                return c.traverse(f => {
                    const m = r.associations.get(f);
                    m != null && h.set(f, m)
                }
                ),
                h
            }
            ;
            return r.associations = u(s),
            s
        })
    }
}
function m_(o, e, t, n) {
    const i = t.nodes[o];
    return n.getDependency("node", o).then(function(r) {
        if (i.skin === void 0)
            return r;
        let s;
        return n.getDependency("skin", i.skin).then(function(a) {
            s = a;
            const l = [];
            for (let u = 0, c = s.joints.length; u < c; u++)
                l.push(n.getDependency("node", s.joints[u]));
            return Promise.all(l)
        }).then(function(a) {
            return r.traverse(function(l) {
                if (!l.isMesh)
                    return;
                const u = []
                  , c = [];
                for (let h = 0, f = a.length; h < f; h++) {
                    const m = a[h];
                    if (m) {
                        u.push(m);
                        const _ = new Ke;
                        s.inverseBindMatrices !== void 0 && _.fromArray(s.inverseBindMatrices.array, h * 16),
                        c.push(_)
                    } else
                        console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', s.joints[h])
                }
                l.bind(new yh(u,c), l.matrixWorld)
            }),
            r
        })
    }).then(function(r) {
        e.add(r);
        const s = [];
        if (i.children) {
            const a = i.children;
            for (let l = 0, u = a.length; l < u; l++) {
                const c = a[l];
                s.push(m_(c, r, t, n))
            }
        }
        return Promise.all(s)
    })
}
function OT(o, e, t) {
    const n = e.attributes
      , i = new ao;
    if (n.POSITION !== void 0) {
        const a = t.json.accessors[n.POSITION]
          , l = a.min
          , u = a.max;
        if (l !== void 0 && u !== void 0) {
            if (i.set(new X(l[0],l[1],l[2]), new X(u[0],u[1],u[2])),
            a.normalized) {
                const c = kc(ha[a.componentType]);
                i.min.multiplyScalar(c),
                i.max.multiplyScalar(c)
            }
        } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            return
        }
    } else
        return;
    const r = e.targets;
    if (r !== void 0) {
        const a = new X
          , l = new X;
        for (let u = 0, c = r.length; u < c; u++) {
            const h = r[u];
            if (h.POSITION !== void 0) {
                const f = t.json.accessors[h.POSITION]
                  , m = f.min
                  , _ = f.max;
                if (m !== void 0 && _ !== void 0) {
                    if (l.setX(Math.max(Math.abs(m[0]), Math.abs(_[0]))),
                    l.setY(Math.max(Math.abs(m[1]), Math.abs(_[1]))),
                    l.setZ(Math.max(Math.abs(m[2]), Math.abs(_[2]))),
                    f.normalized) {
                        const d = kc(ha[f.componentType]);
                        l.multiplyScalar(d)
                    }
                    a.max(l)
                } else
                    console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
            }
        }
        i.expandByVector(a)
    }
    o.boundingBox = i;
    const s = new lo;
    i.getCenter(s.center),
    s.radius = i.min.distanceTo(i.max) / 2,
    o.boundingSphere = s
}
function Mp(o, e, t) {
    const n = e.attributes
      , i = [];
    function r(s, a) {
        return t.getDependency("accessor", s).then(function(l) {
            o.setAttribute(a, l)
        })
    }
    for (const s in n) {
        const a = Nc[s] || s.toLowerCase();
        a in o.attributes || i.push(r(n[s], a))
    }
    if (e.indices !== void 0 && !o.index) {
        const s = t.getDependency("accessor", e.indices).then(function(a) {
            o.setIndex(a)
        });
        i.push(s)
    }
    return Lr(o, e),
    OT(o, e, t),
    Promise.all(i).then(function() {
        return e.targets !== void 0 ? LT(o, e.targets, t) : o
    })
}
function Sp(o, e) {
    let t = o.getIndex();
    if (t === null) {
        const s = []
          , a = o.getAttribute("position");
        if (a !== void 0) {
            for (let l = 0; l < a.count; l++)
                s.push(l);
            o.setIndex(s),
            t = o.getIndex()
        } else
            return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
            o
    }
    const n = t.count - 2
      , i = [];
    if (e === Hg)
        for (let s = 1; s <= n; s++)
            i.push(t.getX(0)),
            i.push(t.getX(s)),
            i.push(t.getX(s + 1));
    else
        for (let s = 0; s < n; s++)
            s % 2 === 0 ? (i.push(t.getX(s)),
            i.push(t.getX(s + 1)),
            i.push(t.getX(s + 2))) : (i.push(t.getX(s + 2)),
            i.push(t.getX(s + 1)),
            i.push(t.getX(s)));
    i.length / 3 !== n && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const r = o.clone();
    return r.setIndex(i),
    r
}
class eE extends BD {
    constructor(e) {
        super(e),
        this.type = Ni
    }
    parse(e) {
        const a = function(S, M) {
            switch (S) {
            case 1:
                console.error("THREE.RGBELoader Read Error: " + (M || ""));
                break;
            case 2:
                console.error("THREE.RGBELoader Write Error: " + (M || ""));
                break;
            case 3:
                console.error("THREE.RGBELoader Bad File Format: " + (M || ""));
                break;
            default:
            case 4:
                console.error("THREE.RGBELoader: Error: " + (M || ""))
            }
            return -1
        }
          , h = `
`
          , f = function(S, M, T) {
            M = M || 1024;
            let P = S.pos
              , A = -1
              , C = 0
              , N = ""
              , G = String.fromCharCode.apply(null, new Uint16Array(S.subarray(P, P + 128)));
            for (; 0 > (A = G.indexOf(h)) && C < M && P < S.byteLength; )
                N += G,
                C += G.length,
                P += 128,
                G += String.fromCharCode.apply(null, new Uint16Array(S.subarray(P, P + 128)));
            return -1 < A ? (T !== !1 && (S.pos += C + A + 1),
            N + G.slice(0, A)) : !1
        }
          , m = function(S) {
            const M = /^#\?(\S+)/
              , T = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/
              , L = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/
              , P = /^\s*FORMAT=(\S+)\s*$/
              , A = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/
              , C = {
                valid: 0,
                string: "",
                comments: "",
                programtype: "RGBE",
                format: "",
                gamma: 1,
                exposure: 1,
                width: 0,
                height: 0
            };
            let N, G;
            if (S.pos >= S.byteLength || !(N = f(S)))
                return a(1, "no header found");
            if (!(G = N.match(M)))
                return a(3, "bad initial token");
            for (C.valid |= 1,
            C.programtype = G[1],
            C.string += N + `
`; N = f(S),
            N !== !1; ) {
                if (C.string += N + `
`,
                N.charAt(0) === "#") {
                    C.comments += N + `
`;
                    continue
                }
                if ((G = N.match(T)) && (C.gamma = parseFloat(G[1])),
                (G = N.match(L)) && (C.exposure = parseFloat(G[1])),
                (G = N.match(P)) && (C.valid |= 2,
                C.format = G[1]),
                (G = N.match(A)) && (C.valid |= 4,
                C.height = parseInt(G[1], 10),
                C.width = parseInt(G[2], 10)),
                C.valid & 2 && C.valid & 4)
                    break
            }
            return C.valid & 2 ? C.valid & 4 ? C : a(3, "missing image size specifier") : a(3, "missing format specifier")
        }
          , _ = function(S, M, T) {
            const L = M;
            if (L < 8 || L > 32767 || S[0] !== 2 || S[1] !== 2 || S[2] & 128)
                return new Uint8Array(S);
            if (L !== (S[2] << 8 | S[3]))
                return a(3, "wrong scanline width");
            const P = new Uint8Array(4 * M * T);
            if (!P.length)
                return a(4, "unable to allocate buffer space");
            let A = 0
              , C = 0;
            const N = 4 * L
              , G = new Uint8Array(4)
              , q = new Uint8Array(N);
            let g = T;
            for (; g > 0 && C < S.byteLength; ) {
                if (C + 4 > S.byteLength)
                    return a(1);
                if (G[0] = S[C++],
                G[1] = S[C++],
                G[2] = S[C++],
                G[3] = S[C++],
                G[0] != 2 || G[1] != 2 || (G[2] << 8 | G[3]) != L)
                    return a(3, "bad rgbe scanline format");
                let w = 0, E;
                for (; w < N && C < S.byteLength; ) {
                    E = S[C++];
                    const z = E > 128;
                    if (z && (E -= 128),
                    E === 0 || w + E > N)
                        return a(3, "bad scanline data");
                    if (z) {
                        const b = S[C++];
                        for (let y = 0; y < E; y++)
                            q[w++] = b
                    } else
                        q.set(S.subarray(C, C + E), w),
                        w += E,
                        C += E
                }
                const R = L;
                for (let z = 0; z < R; z++) {
                    let b = 0;
                    P[A] = q[z + b],
                    b += L,
                    P[A + 1] = q[z + b],
                    b += L,
                    P[A + 2] = q[z + b],
                    b += L,
                    P[A + 3] = q[z + b],
                    A += 4
                }
                g--
            }
            return P
        }
          , d = function(S, M, T, L) {
            const P = S[M + 3]
              , A = Math.pow(2, P - 128) / 255;
            T[L + 0] = S[M + 0] * A,
            T[L + 1] = S[M + 1] * A,
            T[L + 2] = S[M + 2] * A,
            T[L + 3] = 1
        }
          , p = function(S, M, T, L) {
            const P = S[M + 3]
              , A = Math.pow(2, P - 128) / 255;
            T[L + 0] = al.toHalfFloat(Math.min(S[M + 0] * A, 65504)),
            T[L + 1] = al.toHalfFloat(Math.min(S[M + 1] * A, 65504)),
            T[L + 2] = al.toHalfFloat(Math.min(S[M + 2] * A, 65504)),
            T[L + 3] = al.toHalfFloat(1)
        }
          , v = new Uint8Array(e);
        v.pos = 0;
        const x = m(v);
        if (x !== -1) {
            const S = x.width
              , M = x.height
              , T = _(v.subarray(v.pos), S, M);
            if (T !== -1) {
                let L, P, A;
                switch (this.type) {
                case Qn:
                    A = T.length / 4;
                    const C = new Float32Array(A * 4);
                    for (let G = 0; G < A; G++)
                        d(T, G * 4, C, G * 4);
                    L = C,
                    P = Qn;
                    break;
                case Ni:
                    A = T.length / 4;
                    const N = new Uint16Array(A * 4);
                    for (let G = 0; G < A; G++)
                        p(T, G * 4, N, G * 4);
                    L = N,
                    P = Ni;
                    break;
                default:
                    console.error("THREE.RGBELoader: unsupported type: ", this.type);
                    break
                }
                return {
                    width: S,
                    height: M,
                    data: L,
                    header: x.string,
                    gamma: x.gamma,
                    exposure: x.exposure,
                    type: P
                }
            }
        }
        return null
    }
    setDataType(e) {
        return this.type = e,
        this
    }
    load(e, t, n, i) {
        function r(s, a) {
            switch (s.type) {
            case Qn:
            case Ni:
                s.encoding = pr,
                s.minFilter = It,
                s.magFilter = It,
                s.generateMipmaps = !1,
                s.flipY = !0;
                break
            }
            t && t(s, a)
        }
        return super.load(e, r, n, i)
    }
}
var g_ = {
    exports: {}
};
function Th() {}
Th.prototype = {
    on: function(o, e, t) {
        var n = this.e || (this.e = {});
        return (n[o] || (n[o] = [])).push({
            fn: e,
            ctx: t
        }),
        this
    },
    once: function(o, e, t) {
        var n = this;
        function i() {
            n.off(o, i),
            e.apply(t, arguments)
        }
        return i._ = e,
        this.on(o, i, t)
    },
    emit: function(o) {
        var e = [].slice.call(arguments, 1)
          , t = ((this.e || (this.e = {}))[o] || []).slice()
          , n = 0
          , i = t.length;
        for (n; n < i; n++)
            t[n].fn.apply(t[n].ctx, e);
        return this
    },
    off: function(o, e) {
        var t = this.e || (this.e = {})
          , n = t[o]
          , i = [];
        if (n && e)
            for (var r = 0, s = n.length; r < s; r++)
                n[r].fn !== e && n[r].fn._ !== e && i.push(n[r]);
        return i.length ? t[o] = i : delete t[o],
        this
    }
};
g_.exports = Th;
var NT = g_.exports.TinyEmitter = Th
  , __ = {
    exports: {}
};
(function(o, e) {
    (function(t, n) {
        o.exports = n()
    }
    )(hi, function() {
        var t = 0;
        function n(d) {
            return "__private_" + t++ + "_" + d
        }
        function i(d, p) {
            if (!Object.prototype.hasOwnProperty.call(d, p))
                throw new TypeError("attempted to use private field on non-instance");
            return d
        }
        function r() {}
        r.prototype = {
            on: function(d, p, v) {
                var x = this.e || (this.e = {});
                return (x[d] || (x[d] = [])).push({
                    fn: p,
                    ctx: v
                }),
                this
            },
            once: function(d, p, v) {
                var x = this;
                function S() {
                    x.off(d, S),
                    p.apply(v, arguments)
                }
                return S._ = p,
                this.on(d, S, v)
            },
            emit: function(d) {
                for (var p = [].slice.call(arguments, 1), v = ((this.e || (this.e = {}))[d] || []).slice(), x = 0, S = v.length; x < S; x++)
                    v[x].fn.apply(v[x].ctx, p);
                return this
            },
            off: function(d, p) {
                var v = this.e || (this.e = {})
                  , x = v[d]
                  , S = [];
                if (x && p)
                    for (var M = 0, T = x.length; M < T; M++)
                        x[M].fn !== p && x[M].fn._ !== p && S.push(x[M]);
                return S.length ? v[d] = S : delete v[d],
                this
            }
        };
        var s = r;
        s.TinyEmitter = r;
        var a, l = "virtualscroll", u = n("options"), c = n("el"), h = n("emitter"), f = n("event"), m = n("touchStart"), _ = n("bodyTouchAction");
        return function() {
            function d(v) {
                var x = this;
                Object.defineProperty(this, u, {
                    writable: !0,
                    value: void 0
                }),
                Object.defineProperty(this, c, {
                    writable: !0,
                    value: void 0
                }),
                Object.defineProperty(this, h, {
                    writable: !0,
                    value: void 0
                }),
                Object.defineProperty(this, f, {
                    writable: !0,
                    value: void 0
                }),
                Object.defineProperty(this, m, {
                    writable: !0,
                    value: void 0
                }),
                Object.defineProperty(this, _, {
                    writable: !0,
                    value: void 0
                }),
                this._onWheel = function(S) {
                    var M = i(x, u)[u]
                      , T = i(x, f)[f];
                    T.deltaX = S.wheelDeltaX || -1 * S.deltaX,
                    T.deltaY = S.wheelDeltaY || -1 * S.deltaY,
                    a.isFirefox && S.deltaMode === 1 && (T.deltaX *= M.firefoxMultiplier,
                    T.deltaY *= M.firefoxMultiplier),
                    T.deltaX *= M.mouseMultiplier,
                    T.deltaY *= M.mouseMultiplier,
                    x._notify(S)
                }
                ,
                this._onMouseWheel = function(S) {
                    var M = i(x, f)[f];
                    M.deltaX = S.wheelDeltaX ? S.wheelDeltaX : 0,
                    M.deltaY = S.wheelDeltaY ? S.wheelDeltaY : S.wheelDelta,
                    x._notify(S)
                }
                ,
                this._onTouchStart = function(S) {
                    var M = S.targetTouches ? S.targetTouches[0] : S;
                    i(x, m)[m].x = M.pageX,
                    i(x, m)[m].y = M.pageY
                }
                ,
                this._onTouchMove = function(S) {
                    var M = i(x, u)[u];
                    M.preventTouch && !S.target.classList.contains(M.unpreventTouchClass) && S.preventDefault();
                    var T = i(x, f)[f]
                      , L = S.targetTouches ? S.targetTouches[0] : S;
                    T.deltaX = (L.pageX - i(x, m)[m].x) * M.touchMultiplier,
                    T.deltaY = (L.pageY - i(x, m)[m].y) * M.touchMultiplier,
                    i(x, m)[m].x = L.pageX,
                    i(x, m)[m].y = L.pageY,
                    x._notify(S)
                }
                ,
                this._onKeyDown = function(S) {
                    var M = i(x, f)[f];
                    M.deltaX = M.deltaY = 0;
                    var T = window.innerHeight - 40;
                    switch (S.keyCode) {
                    case 37:
                    case 38:
                        M.deltaY = i(x, u)[u].keyStep;
                        break;
                    case 39:
                    case 40:
                        M.deltaY = -i(x, u)[u].keyStep;
                        break;
                    case 32:
                        M.deltaY = T * (S.shiftKey ? 1 : -1);
                        break;
                    default:
                        return
                    }
                    x._notify(S)
                }
                ,
                i(this, c)[c] = window,
                v && v.el && (i(this, c)[c] = v.el,
                delete v.el),
                a || (a = {
                    hasWheelEvent: "onwheel"in document,
                    hasMouseWheelEvent: "onmousewheel"in document,
                    hasTouch: "ontouchstart"in document,
                    hasTouchWin: navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 1,
                    hasPointer: !!window.navigator.msPointerEnabled,
                    hasKeyDown: "onkeydown"in document,
                    isFirefox: navigator.userAgent.indexOf("Firefox") > -1
                }),
                i(this, u)[u] = Object.assign({
                    mouseMultiplier: 1,
                    touchMultiplier: 2,
                    firefoxMultiplier: 15,
                    keyStep: 120,
                    preventTouch: !1,
                    unpreventTouchClass: "vs-touchmove-allowed",
                    useKeyboard: !0,
                    useTouch: !0
                }, v),
                i(this, h)[h] = new s,
                i(this, f)[f] = {
                    y: 0,
                    x: 0,
                    deltaX: 0,
                    deltaY: 0
                },
                i(this, m)[m] = {
                    x: null,
                    y: null
                },
                i(this, _)[_] = null,
                i(this, u)[u].passive !== void 0 && (this.listenerOptions = {
                    passive: i(this, u)[u].passive
                })
            }
            var p = d.prototype;
            return p._notify = function(v) {
                var x = i(this, f)[f];
                x.x += x.deltaX,
                x.y += x.deltaY,
                i(this, h)[h].emit(l, {
                    x: x.x,
                    y: x.y,
                    deltaX: x.deltaX,
                    deltaY: x.deltaY,
                    originalEvent: v
                })
            }
            ,
            p._bind = function() {
                a.hasWheelEvent && i(this, c)[c].addEventListener("wheel", this._onWheel, this.listenerOptions),
                a.hasMouseWheelEvent && i(this, c)[c].addEventListener("mousewheel", this._onMouseWheel, this.listenerOptions),
                a.hasTouch && i(this, u)[u].useTouch && (i(this, c)[c].addEventListener("touchstart", this._onTouchStart, this.listenerOptions),
                i(this, c)[c].addEventListener("touchmove", this._onTouchMove, this.listenerOptions)),
                a.hasPointer && a.hasTouchWin && (i(this, _)[_] = document.body.style.msTouchAction,
                document.body.style.msTouchAction = "none",
                i(this, c)[c].addEventListener("MSPointerDown", this._onTouchStart, !0),
                i(this, c)[c].addEventListener("MSPointerMove", this._onTouchMove, !0)),
                a.hasKeyDown && i(this, u)[u].useKeyboard && document.addEventListener("keydown", this._onKeyDown)
            }
            ,
            p._unbind = function() {
                a.hasWheelEvent && i(this, c)[c].removeEventListener("wheel", this._onWheel),
                a.hasMouseWheelEvent && i(this, c)[c].removeEventListener("mousewheel", this._onMouseWheel),
                a.hasTouch && (i(this, c)[c].removeEventListener("touchstart", this._onTouchStart),
                i(this, c)[c].removeEventListener("touchmove", this._onTouchMove)),
                a.hasPointer && a.hasTouchWin && (document.body.style.msTouchAction = i(this, _)[_],
                i(this, c)[c].removeEventListener("MSPointerDown", this._onTouchStart, !0),
                i(this, c)[c].removeEventListener("MSPointerMove", this._onTouchMove, !0)),
                a.hasKeyDown && i(this, u)[u].useKeyboard && document.removeEventListener("keydown", this._onKeyDown)
            }
            ,
            p.on = function(v, x) {
                i(this, h)[h].on(l, v, x);
                var S = i(this, h)[h].e;
                S && S[l] && S[l].length === 1 && this._bind()
            }
            ,
            p.off = function(v, x) {
                i(this, h)[h].off(l, v, x);
                var S = i(this, h)[h].e;
                (!S[l] || S[l].length <= 0) && this._unbind()
            }
            ,
            p.destroy = function() {
                i(this, h)[h].off(),
                this._unbind()
            }
            ,
            d
        }()
    })
}
)(__);
const kT = __.exports;
function Dp(o, e) {
    for (var t = 0; t < e.length; t++) {
        var n = e[t];
        n.enumerable = n.enumerable || !1,
        n.configurable = !0,
        "value"in n && (n.writable = !0),
        Object.defineProperty(o, n.key, n)
    }
}
function v_(o, e, t) {
    return e && Dp(o.prototype, e),
    t && Dp(o, t),
    Object.defineProperty(o, "prototype", {
        writable: !1
    }),
    o
}
function Xo() {
    return Xo = Object.assign ? Object.assign.bind() : function(o) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var n in t)
                Object.prototype.hasOwnProperty.call(t, n) && (o[n] = t[n])
        }
        return o
    }
    ,
    Xo.apply(this, arguments)
}
function zc(o, e) {
    return zc = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, n) {
        return t.__proto__ = n,
        t
    }
    ,
    zc(o, e)
}
function Tp(o, e) {
    var t = o % e;
    return (e > 0 && t < 0 || e < 0 && t > 0) && (t += e),
    t
}
var zT = ["duration", "easing"]
  , UT = function() {
    function o() {}
    var e = o.prototype;
    return e.to = function(t, n) {
        var i = this
          , r = n === void 0 ? {} : n
          , s = r.duration
          , a = s === void 0 ? 1 : s
          , l = r.easing
          , u = l === void 0 ? function(h) {
            return h
        }
        : l
          , c = function(h, f) {
            if (h == null)
                return {};
            var m, _, d = {}, p = Object.keys(h);
            for (_ = 0; _ < p.length; _++)
                f.indexOf(m = p[_]) >= 0 || (d[m] = h[m]);
            return d
        }(r, zT);
        this.target = t,
        this.fromKeys = Xo({}, c),
        this.toKeys = Xo({}, c),
        this.keys = Object.keys(Xo({}, c)),
        this.keys.forEach(function(h) {
            i.fromKeys[h] = t[h]
        }),
        this.duration = a,
        this.easing = u,
        this.currentTime = 0,
        this.isRunning = !0
    }
    ,
    e.stop = function() {
        this.isRunning = !1
    }
    ,
    e.raf = function(t) {
        var n = this;
        if (this.isRunning) {
            this.currentTime = Math.min(this.currentTime + t, this.duration);
            var i = this.progress >= 1 ? 1 : this.easing(this.progress);
            this.keys.forEach(function(r) {
                var s = n.fromKeys[r];
                n.target[r] = s + (n.toKeys[r] - s) * i
            }),
            i === 1 && this.stop()
        }
    }
    ,
    v_(o, [{
        key: "progress",
        get: function() {
            return this.currentTime / this.duration
        }
    }]),
    o
}()
  , tE = function(o) {
    var e, t;
    function n(r) {
        var s, a, l, u, c = r === void 0 ? {} : r, h = c.duration, f = h === void 0 ? 1.2 : h, m = c.easing, _ = m === void 0 ? function(b) {
            return Math.min(1, 1.001 - Math.pow(2, -10 * b))
        }
        : m, d = c.smooth, p = d === void 0 || d, v = c.mouseMultiplier, x = v === void 0 ? 1 : v, S = c.smoothTouch, M = S !== void 0 && S, T = c.touchMultiplier, L = T === void 0 ? 2 : T, P = c.direction, A = P === void 0 ? "vertical" : P, C = c.gestureDirection, N = C === void 0 ? "vertical" : C, G = c.infinite, q = G !== void 0 && G, g = c.wrapper, w = g === void 0 ? window : g, E = c.content, R = E === void 0 ? document.body : E;
        (u = o.call(this) || this).onWindowResize = function() {
            u.wrapperWidth = window.innerWidth,
            u.wrapperHeight = window.innerHeight
        }
        ,
        u.onWrapperResize = function(b) {
            var y = b[0];
            if (y) {
                var D = y.contentRect;
                u.wrapperWidth = D.width,
                u.wrapperHeight = D.height
            }
        }
        ,
        u.onContentResize = function(b) {
            var y = b[0];
            if (y) {
                var D = y.contentRect;
                u.contentWidth = D.width,
                u.contentHeight = D.height
            }
        }
        ,
        u.onVirtualScroll = function(b) {
            var y = b.deltaY
              , D = b.deltaX
              , I = b.originalEvent;
            if (!(u.gestureDirection === "vertical" && y === 0 || u.gestureDirection === "horizontal" && D === 0)) {
                var F = !!I.composedPath().find(function(B) {
                    return B.hasAttribute && B.hasAttribute("data-lenis-prevent")
                });
                I.ctrlKey || F || (u.smooth = I.changedTouches ? u.smoothTouch : u.options.smooth,
                u.stopped ? I.preventDefault() : u.smooth && I.buttons !== 4 && (u.smooth && I.preventDefault(),
                u.targetScroll -= u.gestureDirection === "both" ? D + y : u.gestureDirection === "horizontal" ? D : y,
                u.scrollTo(u.targetScroll)))
            }
        }
        ,
        u.onScroll = function(b) {
            u.isScrolling && u.smooth || (u.targetScroll = u.scroll = u.lastScroll = u.wrapperNode[u.scrollProperty],
            u.notify())
        }
        ,
        window.lenisVersion = "0.2.28",
        u.options = {
            duration: f,
            easing: _,
            smooth: p,
            mouseMultiplier: x,
            smoothTouch: M,
            touchMultiplier: L,
            direction: A,
            gestureDirection: N,
            infinite: q,
            wrapper: w,
            content: R
        },
        u.duration = f,
        u.easing = _,
        u.smooth = p,
        u.mouseMultiplier = x,
        u.smoothTouch = M,
        u.touchMultiplier = L,
        u.direction = A,
        u.gestureDirection = N,
        u.infinite = q,
        u.wrapperNode = w,
        u.contentNode = R,
        u.wrapperNode.addEventListener("scroll", u.onScroll),
        u.wrapperNode === window ? (u.wrapperNode.addEventListener("resize", u.onWindowResize),
        u.onWindowResize()) : (u.wrapperHeight = u.wrapperNode.offsetHeight,
        u.wrapperWidth = u.wrapperNode.offsetWidth,
        u.wrapperObserver = new ResizeObserver(u.onWrapperResize),
        u.wrapperObserver.observe(u.wrapperNode)),
        u.contentHeight = u.contentNode.offsetHeight,
        u.contentWidth = u.contentNode.offsetWidth,
        u.contentObserver = new ResizeObserver(u.onContentResize),
        u.contentObserver.observe(u.contentNode),
        u.targetScroll = u.scroll = u.lastScroll = u.wrapperNode[u.scrollProperty],
        u.animate = new UT;
        var z = ((s = navigator) == null || (a = s.userAgentData) == null ? void 0 : a.platform) || ((l = navigator) == null ? void 0 : l.platform) || "unknown";
        return u.virtualScroll = new kT({
            el: u.wrapperNode,
            firefoxMultiplier: 50,
            mouseMultiplier: u.mouseMultiplier * (z.includes("Win") || z.includes("Linux") ? .84 : .4),
            touchMultiplier: u.touchMultiplier,
            passive: !1,
            useKeyboard: !1,
            useTouch: !0
        }),
        u.virtualScroll.on(u.onVirtualScroll),
        u
    }
    t = o,
    (e = n).prototype = Object.create(t.prototype),
    e.prototype.constructor = e,
    zc(e, t);
    var i = n.prototype;
    return i.start = function() {
        var r = this.wrapperNode;
        this.wrapperNode === window && (r = document.documentElement),
        r.classList.remove("lenis-stopped"),
        this.stopped = !1
    }
    ,
    i.stop = function() {
        var r = this.wrapperNode;
        this.wrapperNode === window && (r = document.documentElement),
        r.classList.add("lenis-stopped"),
        this.stopped = !0,
        this.animate.stop()
    }
    ,
    i.destroy = function() {
        var r;
        this.wrapperNode === window && this.wrapperNode.removeEventListener("resize", this.onWindowResize),
        this.wrapperNode.removeEventListener("scroll", this.onScroll),
        this.virtualScroll.destroy(),
        (r = this.wrapperObserver) == null || r.disconnect(),
        this.contentObserver.disconnect()
    }
    ,
    i.raf = function(r) {
        var s = r - (this.now || 0);
        this.now = r,
        !this.stopped && this.smooth && (this.lastScroll = this.scroll,
        this.animate.raf(.001 * s),
        this.scroll === this.targetScroll && (this.lastScroll = this.scroll),
        this.isScrolling && (this.setScroll(this.scroll),
        this.notify()),
        this.isScrolling = this.scroll !== this.targetScroll)
    }
    ,
    i.setScroll = function(r) {
        var s = this.infinite ? Tp(r, this.limit) : r;
        this.direction === "horizontal" ? this.wrapperNode.scrollTo(s, 0) : this.wrapperNode.scrollTo(0, s)
    }
    ,
    i.notify = function() {
        var r = this.infinite ? Tp(this.scroll, this.limit) : this.scroll;
        this.emit("scroll", {
            scroll: r,
            limit: this.limit,
            velocity: this.velocity,
            direction: this.velocity === 0 ? 0 : this.velocity > 0 ? 1 : -1,
            progress: r / this.limit
        })
    }
    ,
    i.scrollTo = function(r, s) {
        var a = s === void 0 ? {} : s
          , l = a.offset
          , u = l === void 0 ? 0 : l
          , c = a.immediate
          , h = c !== void 0 && c
          , f = a.duration
          , m = f === void 0 ? this.duration : f
          , _ = a.easing
          , d = _ === void 0 ? this.easing : _;
        if (r != null && !this.stopped) {
            var p;
            if (typeof r == "number")
                p = r;
            else if (r === "top" || r === "#top")
                p = 0;
            else if (r === "bottom")
                p = this.limit;
            else {
                var v;
                if (typeof r == "string")
                    v = document.querySelector(r);
                else {
                    if (r == null || !r.nodeType)
                        return;
                    v = r
                }
                if (!v)
                    return;
                var x = 0;
                if (this.wrapperNode !== window) {
                    var S = this.wrapperNode.getBoundingClientRect();
                    x = this.direction === "horizontal" ? S.left : S.top
                }
                var M = v.getBoundingClientRect();
                p = (this.direction === "horizontal" ? M.left : M.top) + this.scroll - x
            }
            p += u,
            this.targetScroll = this.infinite ? p : Math.max(0, Math.min(p, this.limit)),
            !this.smooth || h ? (this.animate.stop(),
            this.scroll = this.lastScroll = this.targetScroll,
            this.setScroll(this.targetScroll)) : this.animate.to(this, {
                duration: m,
                easing: d,
                scroll: this.targetScroll
            })
        }
    }
    ,
    v_(n, [{
        key: "scrollProperty",
        get: function() {
            return this.wrapperNode === window ? this.direction === "horizontal" ? "scrollX" : "scrollY" : this.direction === "horizontal" ? "scrollLeft" : "scrollTop"
        }
    }, {
        key: "limit",
        get: function() {
            return this.direction === "horizontal" ? this.contentWidth - this.wrapperWidth : this.contentHeight - this.wrapperHeight
        }
    }, {
        key: "velocity",
        get: function() {
            return this.scroll - this.lastScroll
        }
    }]),
    n
}(NT);
export {QT as A, pi as B, GT as C, pD as D, Vl as E, Bi as F, YT as G, BT as H, $T as I, th as J, jT as K, ky as L, wb as M, yt as O, un as P, os as Q, ZT as R, XT as S, VD as T, ra as U, Ze as V, xD as W, nt as a, bv as b, X as c, KT as d, ts as e, _h as f, I0 as g, Vn as h, JT as i, eE as j, to as k, Nl as l, Lc as m, Gf as n, ED as o, Id as p, vr as q, WT as r, it as s, Wo as t, VT as u, sa as v, tE as w, qT as x, Nn as y, HT as z};
